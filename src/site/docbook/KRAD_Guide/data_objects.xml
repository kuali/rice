<?xml version='1.0' encoding='UTF-8'?> 
<!--

    Copyright 2005-2013 The Kuali Foundation

    Licensed under the Educational Community License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.opensource.org/licenses/ecl2.php

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->
<chapter xml:id="data_objects" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://docbook.org/ns/docbook"  version="5.0">    
    <title> Data Objects and Persistence </title>
    <note>
        <para>This document outlines the KRAD Data Framework as of Kuali Rice 2.4+. If you are
            working with older KRAD code and OJB, you will want to reference this document in pre
            2.4 versions of the KRAD Guide. See <link xlink:show="new"
                xlink:href="http://rice.kuali.org/docs">http://rice.kuali.org/docs</link> for links
            to older versions of the Kuali Rice documentation.</para>
    </note>
    <section>
        <title>Data Framework</title>
        <para>KRAD includes a "krad-data" module which provides data and persistence-related
            services. The data framework provided by this module has a number of goals:<orderedlist>
                <listitem>
                    <para>Provide CRUD (Create, Read, Update, Delete) operations for data.</para>
                </listitem>
                <listitem>
                    <para>Maintain a Metadata repository for storing additional information about
                        data objects and their attributes.</para>
                </listitem>
                <listitem>
                    <para>Provide a mechanism to integrate custom persistence and metadata
                        providers.</para>
                </listitem>
                <listitem>
                    <para>Include a default implementation based on the Java Persistence API
                        (JPA).</para>
                </listitem>
            </orderedlist>As stated, it is intended that data which is consumed and processed by a
            KRAD application may be stored in any number of backend data stores or accessed using
            any number of different technologies.</para>
        <para>For many KRAD applications, this data will be stored in a relational database and
            accessed using the Java Persistence API (JPA). This is the default persistence
            technology that KRAD supports, however the design of the data framework facilitates
            integration with other technologies (plain JDBC and SQL, spring-data, web services,
            etc.) and backend data stores (key-value stores, document databases, object databases,
            etc.). This is accomplished through a service provider interface (SPI) that allows for
            the creation and integration of custom providers.</para>
        <para>In addition to providing persistence operations, the krad-data module also provides a
            Metadata repository which stores various bits of metadata about the data objects that it
            is managing. Specifically, this includes information about what the keys and
            relationships are between data objects. It also contains information like human-readable
            labels for data object properties and constraints related to the valid representation of
            the data.</para>
        <para>The krad-data module provides an API to interact with data objects and their metadata
            which is then consumed by the other components within the KRAD framework whenever they
            need to perform data-related operations. This API can also be used elsewhere within the
            application when it needs to interact with its data objects.</para>
    </section>
    <section>
        <title> Data Objects </title>
        <section>
            <title>Data Objects</title>
            <para>We begin our training for the Kuali Rapid Application Development framework with the
                data access layer. Enterprise applications generally have a large number of CRUD (Create
                Read Update Delete) operations; therefore, the access of data is a very important
                concern of development. KRAD builds on top of other tools to provide general facilities
                that greatly reduce the development time. These facilities are known as the KRAD
                Persistence Framework. </para>
            <para>The foundation of the KRAD Persistence Framework is the third party ORM (Object
                Relational Mapping) tool. ORM tools target the persistence of data with a relational
                database. This is achieved by mapping a Java object that contains the data to one or
                more database tables. When a persistence operation is requested, the ORM tool performs
                the work of translating the request along with the corresponding object(s) to the
                necessary DML statement. This provides a great advantage to the application as it
                generally requires no database dependent code (database specific code might be required
                in certain cases). More information on particular ORM tooling will be provided in the
                sections 'OJB Primer' and 'Using JPA'. </para>
            <para>In order to prepare our application for persisting data using an ORM tool, we must
                build the objects that will hold the application data. From the established data model,
                we can determine the objects needed using a mapping strategy. Although the strategies
                and options available depend on the ORM solution we are using, generally we have the
                following mapping options: <orderedlist>
                    <listitem>
                        <para> One table to one object </para>
                    </listitem>
                    <listitem>
                        <para> One table to multiple objects (polymorphism) </para>
                    </listitem>
                    <listitem>
                        <para> Multiple tables to one object </para>
                    </listitem>
                </orderedlist></para>
            <para>Once we have determined how an object will relate with its database table(s), each
                object property is associated with a table column through configuration. This
                configuration will also give the ORM tool information on data type conversion and
                constraints. The final piece to our object mapping is specifying any relationships.
                This includes one-to-one, one-to-many, and many-to-many relationships. </para>
            <tip><para>Referential Integrity: It is not required to have referential integrity set up in the database
                    for relationships declared for the persistent metadata. However, it is generally
                    good practice to do so.</para></tip>
            <para>Now let's set aside the mapping concerns and have a closer look at our 'data' objects.
                Technically, these objects are not complex at all. First, they must adhere to the POJO
                (Plain Old Java Object) and JavaBean guidelines. These guidelines are as follows: <orderedlist>
                    <listitem>
                        <para>Is Serializable (implements the java.io. Serializable interface) </para>
                    </listitem>
                    <listitem>
                        <para>Has a no-arg constructor </para>
                    </listitem>
                    <listitem>
                        <para>Provides property getter and setter methods using the conventional
                            (get{PropertyName} for getter, set{PropertyName} for setter, and
                            is{PropertyName} for Booleans) </para>
                    </listitem>
                </orderedlist></para>
            <para>In addition to the 'primitive' property types a data object may contain, a data
                object may also be composed of nested data objects (representing a one-to-one
                relationship), or a collection of data objects (representing a one-to-many
                relationship). </para>
            <tip><para><emphasis role="keyword">Related Data Objects</emphasis>: It is important to setup the related
                    data object properties. As we will see later on, the framework can take care of
                    many things for us automatically based on the metadata derived from these
                    relationships. </para></tip>
            <para>Next, well that's it! However, as we will see in just a bit, in order to take
                advantage of the additional persistence features KRAD provides, there is one
                additional thing we need to add. </para>
            <para>KRAD refers to any object that provides data as a 'Data Object'. Data objects provide
                a very central role in an enterprise application. Within the suggested KRAD
                architecture, they are not bound to just the data access layer, but can freely move
                between the other application layers as well. This means we can use data objects in our
                services, and we can use them to build our user interfaces. </para>
            <tip><para><emphasis role="keyword">'Data Object'</emphasis>: The 'Data Object' term can refer to objects
                    that are mapped to a persistence mechanism, but also might not be. For example,
                    it might be an object whose data is assembled by a service call, which in turn
                    interacts with other persisted objects or other services. This flexibility is
                    important for allowing other KRAD modules to be used with a variety of data
                    sources and strategies.</para></tip>
            <para><emphasis role="bold">Best Practice</emphasis>: Keep data objects simple! Try to avoid
                introducing any business logic or presentation logic into the objects. </para>
        </section>
        <section>
            <title>Business Objects </title>
            <para>A special type of data object in KRAD is known as a Business Object. These are
                data objects that implement the interface org.kuali.rice.krad.bo.BusinessObject.
                There are two primary types of business object: those that persist to the database
                and those that do not. Those business objects that do persist to the database should
                implement the org.kuali.rice.krad.bo.PersistableBusinessObject interface. This
                interface adds persistence related methods that are invoked throughout the
                framework. </para>
            <para>Generally, when creating a new data object, it is more convenient to extend one of
                the provided base classes that implement the necessary interfaces. For persistable
                objects, this base class is org.kuali.rice.krad.bo. PersistableBusinessObjectBase.
                Within this base class, default implementations for the persistable methods exist
                along with properties for the common fields required for all persisted objects.
                These are described in more detail later on in this section. Business objects that
                do not persist to the database can extend
                org.kuali.rice.krad.bo.TransientBusinessObjectBase. </para>
            <tip><para><emphasis role="keyword">Transient Business Objects</emphasis>: Transient business objects were
                    necessary in earlier versions of Rice, due to the framework requiring all
                    objects to be business objects (including the UI generation). With version 2.0
                    of Rice and KRAD, this restriction no longer exists; therefore there is really
                    no need for the transient business object concept. </para></tip>
            <para>In order to take advantage of all the features KRAD provides, it is recommended
                that all persistable objects (and therefore tables) contain two properties: <orderedlist>
                    <listitem>
                        <para>Version Number – This property holds a version for the record that is
                            maintained by the ORM tool to perform optimistic locking. The number is
                            initially set to 0. Each time the record is updated, the version number
                            is incremented. Before updating the record, the ORM tool performs a
                            comparison between the version number on the data object, and the
                            version number of the record in the database. If they are different, the
                            tool knows the record has been updated since the record was pulled and
                            throws an optimistic lock exception. </para>
                    </listitem>
                    <listitem>
                        <para>Object Id – This property holds a GUID value for each record in the
                            database. This is used in the framework as an alternate key for the
                            record. Example usages of the object id include the notes and
                            attachments framework. Notes are associated with a record by its object
                            id. Another example is its use within the multi-value lookup framework.
                            Selected records are identified and retrieved based on their unique
                            object ids. </para>
                    </listitem>
                </orderedlist></para>
        </section>
        <section>
            <title>Special Business Objects </title>
            <para>Additional functionality exists for a few special types of business objects. One
                of these special types is business objects that have an active status. That is, each
                record has a state of active (which generally means the record is valid for using)
                or inactive (meaning the record should not be used due to being old or not currently
                valid). Objects of this type should implement the Inactivatable interface. This
                interface requires the methods isActive() and setActive(Boolean active) to be
                implemented. </para>
            <para>The simplest form of inactivatable business objects are those that maintain a
                single field that indicates the active status as a Boolean field. Another common
                case is that of an active date range (also known as effective dating). These objects
                maintain two fields that work together for determining the active status. This first
                of these fields is the active begin date which indicates the date on which the
                record becomes active. This field can have a null value indicating the record is
                active for all dates before the end date. The second field is the active end date
                which indicates the date on which the record becomes inactive. This field can have a
                null value indicating the record has no inactive date set. </para>
            <para> Record is active if:
                <programlisting linenumbering = "numbered">(activeFromDate == null ||
    asOfDate >= activeFromDate.getMillis()) &amp;&amp;  (activeToDate == null ||
    asOfDate &lt; activeToDate.getMillis());   </programlisting>
                where the asOfDate is the current date or a date we wish to simulate the active
                check for. </para>
            <para>For inactivatable business objects that use effective dating, the
                org.kuali.rice.krad.bo.InactivatableFromToImpl class can be extended which holds the
                necessary properties and implements the logic necessary to determine the active
                status (note that this class implements the Inactivatable and InactivatableFromTo
                interfaces). </para>
            <para>When an object is marked as inactivatable, KRAD will give us some nice features
                for handling the active status: <itemizedlist>
                    <listitem>
                        <para><emphasis role="bold">Validation of active status for foreign key
                                fields </emphasis></para>
                        <para>As we will see later on in the section 'Automatic Validation', KRAD
                            can perform a lot of the common validation tasks for us. One of these is
                            known as default existence checks. This is validation that is performed
                            on one or more user inputted fields to verify the value given exists in
                            the related database table. To perform this validation, the framework
                            uses the configured relationship for the inputted fields (inputted
                            fields are the foreign keys). In addition to performing the existence
                            checks, we can ask for the active status to be verified as well. If the
                            record exists but the active flag is false, an error message will be
                            displayed to the user. </para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">Inactivation Blocking </emphasis></para>
                        <para>Changing the active status for a record to false (or inactive) is
                            known as inactivation. Problems with data integrity can occur if we
                            inactivate a record that is referenced (by a foreign key relationship)
                            by another active record. For these cases we want to ensure the record
                            with the relationship is inactivated before the related record. Using a
                            feature known as Inactivation Blocking we can disallow the user from
                            inactivating a record when this condition exists. </para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">Inactive Collection Row Filtering</emphasis>
                        </para>
                        <para>When displaying a collection with the UIF (User Interface Framework)
                            whose items implement the Inactivatable interface, a filter is presented
                            allow the user to view all records or only those that are active.
                        </para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">Key Value Finders</emphasis>
                        </para>
                        <para>UI controls like the select and radio group can get their option
                            values from a class known as KeyValueFinder (more on this in 'Types of
                            Controls'). For easy building of these option classes, the UIF provides
                            a generic configurable KeyValueFinder that will exclude inactive records
                            from the options list if the option providing class implements
                            Inactivatable. </para>
                    </listitem>
                </itemizedlist></para>
            <para>Another special type of business objects are code/name objects. These objects all
                contain a field that represents a code, and a field that gives the name for that
                code (or description). In many cases these are the only two fields present. Business
                objects of this type should implement the org.kuali.rice.krad.bo.KualiCode interface
                (or extend org.kuali.rice.krad.bo.KualiCodeBase). When presenting code values that
                have a related object of type KualiCode, the framework will do translation to
                display the name or the code and name. </para>
            <tip><para><emphasis role="bold">Planned Feature</emphasis></para>
                <para><emphasis role="bold">Code Table:</emphasis> In the future KRAD will provide
                    the facilities for storing KualiCode objects in a single code table. This will
                    allow new codes to be created quickly (without the need for a table and
                    mapping). </para></tip>
        </section>
        <section role="NotInToc">
            <title>RECAP</title>
            <itemizedlist>
                <listitem>
                    <para>Data objects are standard JavaBeans that hold application data. Generally,
                        the data from these objects is persisted to the database with use of an ORM
                        tool.</para>
                </listitem>
                <listitem>
                    <para>Metadata provides the mapping between a data object class and a database
                        table. Each object property is mapped to a table field, and one-to-one,
                        one-to-many, and many-to-many relationships can be configured. </para>
                </listitem>
                <listitem>
                    <para>Data objects are a central piece to the KRAD framework. These objects and
                        their metadata are used to provide features such as inquiries, lookups,
                        maintenance, and validation. </para>
                </listitem>
                <listitem>
                    <para>A business object is a special kind of data object that provides
                        properties and methods for persistence and other framework functionality.
                    </para>
                </listitem>
                <listitem>
                    <para>All persistable data objects should have the version number and object id
                        properties. </para>
                </listitem>
                <listitem>
                    <para>Business objects that have an active status implement the Inactivatable
                        interface.</para>
                </listitem>
                <listitem>
                    <para>KRAD provides additional functionality for inactivatable objects. </para>
                </listitem>
                <listitem>
                    <para>KualiCode represents a business object that has a code and name property.
                    </para>
                </listitem>
            </itemizedlist>
        </section>
    </section>
    <section>
        <title>Java Persistence API and Kuali Rice</title>
        <para>In JPA there are several ways to execute queries. The following are the best practices
            that should be used when using JPA in Kuali applications. In general the order of
            consideration for a query should go as the following:<orderedlist>
                <listitem>
                    <para>Use DataObjectService methods in service methods.</para>
                </listitem>
                <listitem>
                    <para>Create custom DAOs method to use NamedQuery in JPA.</para>
                </listitem>
                <listitem>
                    <para>Use Rice Criteria API if query is too complicated and would require
                        dynamic generation(String concatenation).</para>
                </listitem>
                <listitem>
                    <para>Use JPA Criteria API if query requires functions not supported in Rice
                        Criteria API.</para>
                </listitem>
            </orderedlist><emphasis role="bold"> Simple DataObjectService fetch by Primary
                Key</emphasis><programlisting>CountryBo countryBo = getDataObjectService().find(CountryBo.class,code);

//Fetch by Compound Primary Key
final Map&lt;String, Object> map = new HashMap&lt;String, Object>();
map.put("countryCode", countryCode);
map.put("code", code);
StateBo stateBo = getDataObjectService().find(StateBo.class,new CompoundKey(map)));</programlisting>
            <emphasis role="bold">DataObjectService query for matching results</emphasis>
            <programlisting>//Fetch all matching results by countryCode and that have active equivalent to true
final Map&lt;String, Object> map = new HashMap&lt;String, Object>();
map.put("countryCode", countryCode);
map.put("active", Boolean.TRUE);

QueryResults&lt;PostalCodeBo> postalCodeBoQueryResults = getDataObjectService().
    findMatching(PostalCodeBo.class,QueryByCriteria.Builder.andAttributes(map).build());

//Fetch all Countries that have alternateCountryCode equal to value passed in
QueryByCriteria qbc = QueryByCriteria.Builder.forAttribute(KRADPropertyConstants.ALTERNATE_POSTAL_COUNTRY_CODE,
                alternateCode).build();
QueryResults&lt;CountryBo> countryBoQueryResults = getDataObjectService().findMatching(CountryBo.class,qbc);
List&lt;CountryBo> countryList = countryBoQueryResults.getResults();</programlisting><emphasis
                role="bold"> DataObjectService query returning the count based on Criteria </emphasis><programlisting>//Fetch count based on document id and principal id and current indicator being true
QueryByCriteria.Builder criteria = QueryByCriteria.Builder.create().setPredicates(
                                       equal(DOCUMENT_ID, documentId),
                   	                equal(PRINCIPAL_ID, principalId),
                   	                equal(CURRENT_INDICATOR, Boolean.TRUE)
                    	        );
criteria.setCountFlag(CountFlag.ONLY);
return getDataObjectService().findMatching(ActionTakenValue.class, criteria.build()).getTotalRowCount();</programlisting>
            <emphasis role="bold">Injecting the Shared Entity Manager</emphasis></para>
        <programlisting>//Add the following to your Spring DAO implementation to assign the appropriate Persistence 
//Unit to your DAO

public class DocumentTypeDAOJpa implements DocumentTypeDAO {

@PersistenceContext(unitName="kew")
private EntityManager entityManager;

}</programlisting>
        <para>
            <emphasis role="bold"> Simple example of Named Query in Rice</emphasis>
            <programlisting>//Fetch Application Document ID by Document ID
//Define constants for named query in DAO - In this case DocumentRouteHeaderDAOJpa
//Name your queries such that they start with the Entity name 
//like @NamedQuery(name="ParameterBo.findAll", query="SELECT p FROM ParameterBo")

public static final String GET_APP_DOC_STATUS_NAME = "DocumentRouteHeaderValue.GetAppDocStatus";
public static final String GET_APP_DOC_STATUS_QUERY = "SELECT d.appDocStatus from "
            + "DocumentRouteHeaderValue as d where d.documentId = :documentId";

//Definition of NamedQuery on Queried Entity(DocumentRouteHeaderValue)
    @NamedQuery(name=DocumentRouteHeaderDAOJpa.GET_APP_DOC_STATUS_NAME, query=
            DocumentRouteHeaderDAOJpa.GET_APP_DOC_STATUS_QUERY)

//Code to call NamedQuery
TypedQuery&lt;String> query = getEntityManager().createNamedQuery(
                            "DocumentRouteHeaderValue.GetAppDocId",String.class);
query.setParameter("documentId",documentId);

String applicationDocId = null;
if(query.getResultList() != null &amp;&amp; !query.getResultList().isEmpty()){
    applicationDocId = query.getResultList().get(0);
}
return applicationDocId;</programlisting>
            <emphasis role="bold">More Complex example of NamedQuery </emphasis><programlisting>//Fetch all distinct document IDs by document type and application document ID
public static final String GET_DOCUMENT_ID_BY_DOC_TYPE_APP_ID_NAME =
            "DocumentRouteHeaderValue.GetDocumentIdByDocTypeAndAppId";
public static final String GET_DOCUMENT_ID_BY_DOC_TYPE_APP_ID_QUERY = "SELECT "
            + "DISTINCT(DH.documentId) FROM DocumentRouteHeaderValue DH, DocumentType DT "
            + "WHERE DH.appDocId = :appDocId AND DH.documentTypeId = DT.documentTypeId  AND DT.name = :name";

@NamedQuery(name=DocumentRouteHeaderDAOJpa.GET_DOCUMENT_ID_BY_DOC_TYPE_APP_ID_NAME, query =
            DocumentRouteHeaderDAOJpa.GET_DOCUMENT_ID_BY_DOC_TYPE_APP_ID_QUERY)

TypedQuery&lt;String> query = getEntityManager().createNamedQuery(GET_DOCUMENT_ID_BY_DOC_TYPE_APP_ID_NAME,
                String.class);
query.setParameter("appDocId",appId);
query.setParameter("name",documentTypeName);
return query.getResultList();</programlisting>
            <tip>
                <para> When building named queries you must use an alias the object  "select
                        <emphasis role="bold">r</emphasis> from KUL_RICE_T <emphasis role="bold"
                        >r</emphasis>". If you get the below error you are probably missing an
                    alias.
                    <programlisting>Caused by: java.lang.ClassCastException: 
                    org.eclipse.persistence.jpa.jpql.parser.NullExpression 
                    cannot be cast to org.eclipse.persistence.jpa.jpql.parser.IdentificationVariable
                 </programlisting>
                </para>
            </tip>
            <emphasis role="bold">Using Rice Criteria API </emphasis>
            <programlisting>//Example of Dynamic query, this query needs to add date checks dates 
//if effectiveDate parameter is not null

//This should be in a DAO class - RuleDAOJpa in this case

public List&lt;RuleBaseValues> fetchAllCurrentRulesForTemplateDocCombination(String ruleTemplateId, List documentTypes, Timestamp effectiveDate) {
       QueryByCriteria.Builder builder = QueryByCriteria.Builder.create();
        List&lt;Predicate> predicates = new ArrayList&lt;Predicate>();
        predicates.add(equal("ruleTemplateId",ruleTemplateId));
        predicates.add(in("docTypeName", documentTypes));
        predicates.add(equal("active", Boolean.TRUE));
        predicates.add(equal("delegateRule",Boolean.FALSE));
        predicates.add(equal("templateRuleInd",Boolean.FALSE));

        if(effectiveDate != null){
            predicates.add(lessThanOrEqual("activationDate",effectiveDate));
            predicates.add(greaterThanOrEqual("deactivationDate", effectiveDate));
        }
        List&lt;Predicate> datePredicateList = generateFromToDatePredicate(new Date());
        Predicate[] datePreds = generateFromToDatePredicate(new Date()).
                toArray(new Predicate[datePredicateList.size()]);
        predicates.add(and(datePreds));
        Predicate[] preds = predicates.toArray(new Predicate[predicates.size()]);
        builder.setPredicates(preds);
        QueryResults&lt;RuleBaseValues> results = getDataObjectService().findMatching(RuleBaseValues.class,
                                            builder.build());
        return results.getResults();
	}

    public List&lt;Predicate> generateFromToDatePredicate(Date date){
        List&lt;Predicate> datePredicates = new ArrayList&lt;Predicate>();

        Predicate orFromDateValue = or(lessThanOrEqual("fromDateValue",new Timestamp(date.getTime())),
              isNull("fromDateValue"));
        Predicate orToDateValue = or(greaterThanOrEqual("toDateValue",new Timestamp(date.getTime())),
              isNull("toDateValue"));

        datePredicates.add(orFromDateValue);
        datePredicates.add(orToDateValue);

        return datePredicates;
    }
            </programlisting>
            <emphasis role="bold">Using JPA Criteria API </emphasis>
            <programlisting>//Using JPA Criteria Builder

	public List&lt;RuleBaseValues> search(String docTypeName, String ruleId, String ruleTemplateId, String ruleDescription,
 String groupId, String principalId, Boolean delegateRule, Boolean activeInd, Map extensionValues, String workflowIdDirective) {
        CriteriaBuilder cb = getEntityManager().getCriteriaBuilder();
        CriteriaQuery&lt;RuleBaseValues> cq = cb.createQuery(RuleBaseValues.class);
        Root&lt;RuleBaseValues> root = cq.from(RuleBaseValues.class);
        List&lt;javax.persistence.criteria.Predicate> predicates = getSearchCriteria(root,cq,docTypeName,
 ruleTemplateId, ruleDescription, delegateRule, activeInd, extensionValues);

        if (ruleId != null) {
            predicates.add(cb.equal(root.get("id"),ruleId));
        }
        if (groupId != null) {
            predicates.add(cb.in(root.get("id")).value(getRuleResponsibilitySubQuery(
                    groupId, cq)));
        }
        Collection&lt;String> kimGroupIds = new HashSet&lt;String>();
        Boolean searchUser = Boolean.FALSE;
        Boolean searchUserInWorkgroups = Boolean.FALSE;
        
        if ("group".equals(workflowIdDirective)) {
            searchUserInWorkgroups = Boolean.TRUE;
        } else if (StringUtils.isBlank(workflowIdDirective)) {
            searchUser = Boolean.TRUE;
            searchUserInWorkgroups = Boolean.TRUE;
        } else {
            searchUser = Boolean.TRUE;
        }
        
        if (!org.apache.commons.lang.StringUtils.isEmpty(principalId) &amp;&amp; searchUserInWorkgroups) {
            Principal principal = null;

            principal = KimApiServiceLocator.getIdentityService().getPrincipal(principalId);

            if (principal == null)
            {
            	throw new RiceRuntimeException("Failed to locate user for the given principal id: " + principalId);
            }
            kimGroupIds = KimApiServiceLocator.getGroupService().getGroupIdsByPrincipalId(principalId);
        }
        Subquery&lt;RuleResponsibilityBo> subquery = addResponsibilityCriteria(cq,kimGroupIds, principalId, searchUser, searchUserInWorkgroups);

        if(subquery != null){
            predicates.add(cb.in(root.get("id")).value(subquery));
        }
        cq.distinct(true);
        javax.persistence.criteria.Predicate[] preds = predicates.toArray(
                new javax.persistence.criteria.Predicate[predicates.size()]);
        cq.where(preds);
        TypedQuery&lt;RuleBaseValues> q = getEntityManager().createQuery(cq);

        return q.getResultList();
	}

    private Subquery&lt;RuleResponsibilityBo> getRuleResponsibilitySubQuery(String ruleRespName,
                        CriteriaQuery&lt;RuleBaseValues> query){
        CriteriaBuilder cb = getEntityManager().getCriteriaBuilder();
        Subquery&lt;RuleResponsibilityBo> subquery = query.subquery(RuleResponsibilityBo.class);
        Root fromResp = subquery.from(RuleResponsibilityBo.class);
        subquery.where(cb.equal(fromResp.get("ruleResponsibilityName"),ruleRespName));
        subquery.select(fromResp.get("ruleBaseValuesId"));

        return subquery;
    }
        </programlisting>
            <emphasis role="bold">Miscellaneous JPA information </emphasis><tip>
                <para>
                    <programlisting>//Relationship foreign key updating can go wrong if missing 
//"nullable" on JoinColumn.  It can insert null into the column instead of
//the actual value of the foreign entity key

public class RouteNodeInstance implements Serializable {
    @ManyToOne
    @JoinColumn(name="RTE_NODE_ID", <emphasis role="bold">nullable = false</emphasis>)
    private RouteNode routeNode;
}
                  </programlisting>
                </para>
            </tip>
        </para>
    </section>
<!-- TODO
    <section>
        <title> The Business Object Service </title>
        <para></para>
    </section>
    <section>
        <title> Building DAOs and using Spring Templates </title>
        <para></para>
    </section>
    <section>
        <title> Persistence Metadata </title>
        <para></para>
    </section>
-->    
</chapter>
