<?xml version='1.0' encoding='UTF-8'?> 
<chapter xml:id="TRG_KNS" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">
    <title>KNS</title>
    <sect1>
        <title>KNS Configuration Guide</title>
        <para>The Kuali Nervous System (KNS) is, primarily, an application development framework.
            Each Rice client application can use the KNS to construct various screens and build
            pieces of the application with the built-in components and services that the KNS
            provides.</para>
        <para>To this end, configuration of the KNS in a client application can be accomplished by
            following these steps:<orderedlist>
                <listitem>
                    <para>Creation of database tables in the client application’s database that the
                        KNS requires to function. </para>
                </listitem>
                <listitem>
                    <para>Loading of the <emphasis role="bold">KNSConfigurer</emphasis> inside of
                        the <emphasis role="bold">RiceConfigurer</emphasis> Spring bean. This
                        includes configuring connections to the databases. </para>
                </listitem>
                <listitem>
                    <para>Loading of the KNS struts module for the various UI components that the
                        KNS provides in addition to any filters or servlets that need to be defined
                        in the client application’s <emphasis role="bold">web.xml</emphasis>. </para>
                </listitem>
                <listitem>
                    <para>Creation of a <emphasis role="bold">ModuleConfiguration</emphasis> for the
                        application which instructs the KNS about which Data Dictionary files and
                            <link xlink:href="http://db.apache.org/ojb/">OJB</link> repository
                        mapping files to load. </para>
                </listitem>
                <listitem>
                    <para>Customization of the various configuration parameters that the KNS
                        supports. </para>
                </listitem>
            </orderedlist></para>
        <sect2>
            <title>Database Creation</title>
            <para>In order for the KNS services to work, many of them require the ability to access
                special tables within the client application’s database. These tables are used to
                store various pieces of data; from notes and attachments on documents to maintenance
                document data and much more.</para>
            <para>These tables are included as part of either the demo-client-dataset or the
                bootstrap-client-dataset. These datasets are provided with the Kuali Rice binary
                distributions and instructions on how to install them can be found in the
                Installation Guide. </para>
            <note><para>It’s important to note that these tables should be installed in the client
                application’s database, and not the Rice standalone server database.</para></note>
        </sect2>
        <sect2>
            <title>KNSConfigurer and RiceConfigurer</title>
            <para>As with the other modules, a <emphasis role="bold">KNSConfigurer</emphasis> needs
                to be injected into the <emphasis role="bold">RiceConfigurer</emphasis> in order to
                instruct Rice to initialize the KNS module. The main purpose of this is to allow for
                the <emphasis role="bold">applicationDataSource</emphasis> and the <emphasis
                    role="bold">serverDataSource</emphasis> to be specified.</para>
            <para>The <emphasis role="bold">applicationDataSource</emphasis> should point to the
                client application’s database. That database should contain the tables from one of
                the client datasets.</para>
            <para>The <emphasis role="bold">serverDataSource</emphasis> should point to the database
                of the Rice standalone server. This is used for allowing access to the various KNS
                central services that use data in the Rice server database. This includes such data
                as System Parameters, Namespaces, Campuses, States and Countries.</para>
            <para>Here is an example of Spring configuration for a KNS client:</para>
            <programlisting>&lt;bean id="rice" class="org.kuali.rice.core.config.RiceConfigurer">
    ...
    &lt;property name="knsConfigurer">
        &lt;bean class="org.kuali.rice.kns.config.KNSConfigurer"
>
            &lt;property name=”applicationDataSource” ref=”applicationDataSource”/>
            &lt;property name=”serverDataSource” ref=”riceServerDataSource”/>
        &lt;/bean>
    &lt;/property>
    ...
&lt;/bean></programlisting>
            <para>Alternatively, you can just set the <emphasis role="bold">dataSource</emphasis>
                and <emphasis role="bold">serverDataSource</emphasis> on the <emphasis role="bold"
                    >RiceConfigurer</emphasis> itself and that will be used for the KNS <emphasis
                    role="bold">applicationDataSource</emphasis> and <emphasis role="bold"
                    >serverDataSource</emphasis> respectively. This is useful when using the same
                database for all the different modules of Rice.</para>
            <para>The <emphasis role="bold">KNSConfigurer</emphasis> supports some other properties
                as well. See the javadocs of <emphasis role="bold">KNSConfigurer</emphasis> for more
                information.</para>
        </sect2>
        <sect2>
            <title>Configuring the KNS Web Application Components</title>
            <sect3>
                <title>Loading the KNS Struts Modules</title>
                <para>The web application framework of the KNS is built on top of the <link
                        xlink:href="http://struts.apache.org/1.x/">Apache Struts</link> framework.
                    As a result of this, the web application components of the KNS are loaded into
                    the client application as a struts module. The struts module and various pieces
                    of the Rice web content can be found in the binary distribution. They should be
                    copied into the root directory of your web application.</para>
                <para>A special implementation of the Struts <emphasis role="bold"
                        >ActionServlet</emphasis> is provided to help with the loading of the struts
                    modules. It can be configured in the application’s <emphasis role="bold"
                        >web.xml</emphasis> as in the following example:</para>
                <programlisting>&lt;servlet>
    &lt;servlet-name>action&lt;/servlet-name>
    &lt;servlet-class>org.kuali.rice.kns.web.struts.action.KualiActionServlet&lt;/servlet-class>
    &lt;init-param>
        &lt;param-name>config&lt;/param-name>
        &lt;param-value>/WEB-INF/struts-config.xml&lt;/param-value>
    &lt;/init-param>
    &lt;load-on-startup>0&lt;/load-on-startup>
&lt;/servlet></programlisting>
                <para>Notice the <emphasis role="bold">init-param</emphasis> above points to a
                    Struts configuration file. This file is intended to be the struts configuration
                    file for the client application. It’s used by the KNS for doing redirects back
                    to the main application and is also used for adding KNS-based screens within the
                    client application. Specifically, this is where action mappings go if using the
                    transactional document framework of the KNS.</para>
                <para>There is an example file in the distributions under <emphasis role="bold"
                        >config/examples/struts-config.example.xml</emphasis>. This will need to be
                    renamed to <emphasis role="bold">struts-config.xml</emphasis> and copied to your
                    web application’s <emphasis role="bold">WEB-INF</emphasis> directory. It can
                    then be loaded using the KualiActionServlet as seen in the example above.</para>
                <para>In this example file you will see a reference to a message resource properties
                    file. As is the case with a standard Struts-based application, the resource
                    properties file is used to load text strings for internationalization purposes.
                    The KNS framework requires that at least the app.title property to be set, as in
                    the following example:</para>
                <programlisting>app.title=Recipe Sample Application</programlisting>
            </sect3>
            <sect3>
                <title>Configuring KNS Servlet Context Listeners</title>
                <para>The KNS framework requires a couple of ServletContextListener classes to be
                    configured in the application’s web.xml. These include:<itemizedlist>
                        <listitem>
                            <para><emphasis role="bold"
                                    >org.kuali.rice.kns.web.listener.JstlConstantsInitListener</emphasis>
                            </para>
                        </listitem>
                        <listitem>
                            <para><emphasis role="bold"
                                    >org.kuali.rice.kns.web.listener.KualiHttpSessionListener</emphasis>
                            </para>
                        </listitem>
                    </itemizedlist></para>
                <para>These should be included in the <emphasis role="bold">web.xml</emphasis>
                    <emphasis role="italic">after</emphasis> any listeners or servlets that might be
                    used to actually initialize the Spring context that loads Rice.</para>
                <para>Here is an example of what this configuration might look like in
                web.xml:</para>
                <programlisting>&lt;listener>
    &lt;listener-class>my.app.package.ListenerThatStartsRice&lt;/listener-class>

&lt;/listener>


&lt;listener>
    &lt;listener-class>org.kuali.rice.kns.web.listener.JstlConstantsInitListener&lt;/listener-class>

&lt;/listener>



&lt;listener>
    &lt;listener-class>org.kuali.rice.kns.web.listener.KualiHttpSessionListener&lt;/listener-class>
&lt;/listener></programlisting>
            </sect3>
            <sect3>
                <title>Configuring KNS Message Resources</title>
                <para>As of Rice version 1.0.1.1, messages are loaded through the new
                    KualiPropertyMessageResourcesFactory. This class is a factory of
                    KualiPropertyMessageResources, which takes in a comma delimited list of
                    .properties files.</para>
                <para>This is set up in the struts-config.xml files near the end of the file:</para>
                <programlisting>&lt;message-resources factory=”org.kuali.rice.kns.web.struts.action.KualiPropertyMessageResourceFactory” parameter=”” /></programlisting>
                <para>When the parameter above is set to an empty string, Rice uses the default
                    value of properties files. The default value is set by the
                    rice.struts.message.resources property the common-config-defaults.xml file. This
                    is the default setting:</para>
                <programlisting>&lt;param name=”rice.struts.message.resources”>KR-ApplicationResources,org.kuali.rice.kew.ApplicationResources,org.kuali.rice.ksb.messaging.ApplicationResources,KIM-ApplicationResources” /></programlisting>
                <para>This can be overridden in rice-config.xml. This value should be in a comma
                    delimited format. The list of files is loaded from left to right, with any
                    duplicated properties being overridden in that order. Therefore, in the list
                    default list if a property key in KR-ApplicationResources was duplicated in
                    KIM-ApplicationResources, the value used would be the one set in
                    KIM-ApplicationResources. </para>
            </sect3>
            <sect3>
                <title>Configuring AJAX Support</title>
                <para>The KNS uses <link xlink:href="http://directwebremoting.org/dwr/index.html"
                        >DWR</link> to provide AJAX support. In order to enable this, the <emphasis
                        role="bold">org.kuali.rice.kns.web.servlet.KualiDWRServlet</emphasis> must
                    be configured in the application’s <emphasis role="bold">web.xml </emphasis>as
                    follows:</para>
                <programlisting>&lt;servlet>
    &lt;servlet-name>dwr-invoker&lt;/servlet-name>
    &lt;servlet-class>org.kuali.rice.kns.web.servlet.KualiDWRServlet&lt;/servlet-class>
    &lt;init-param>
        &lt;param-name>debug&lt;/param-name>
        &lt;param-value>true&lt;/param-value>
    &lt;/init-param>
    &lt;init-param>
        &lt;param-name>springpath&lt;/param-name>
        &lt;param-value>true&lt;/param-value>
    &lt;/init-param>
    &lt;load-on-startup>1&lt;/load-on-startup>
&lt;/servlet>

...

&lt;servlet-mapping>
    &lt;servlet-name>dwr-invoker&lt;/servlet-name>
    &lt;url-pattern>/dwr/*&lt;/url-pattern>
&lt;/servlet-mapping></programlisting>
            </sect3>
        </sect2>
        <sect2>
            <title>Module Configuration – Loading Data Dictionary and OJB Files</title>
            <para>One of the most important pieces of the KNS framework is the Data Dictionary. It’s
                used to define various pieces of metadata about business objects, maintenance
                documents, lookups, inquiries and more. These Data Dictionary files are authored in
                XML and are loaded using a <emphasis role="bold">ModuleConfiguration</emphasis>.
                Additionally, business objects in the KNS are mapped to the database using an object
                relational mapping library called <link xlink:href="http://db.apache.org/ojb/"
                    >Apache OJB</link>. The <emphasis role="bold">ModuleConfiguration</emphasis> is
                also used to load those mapping files.</para>
            <para>A <emphasis role="bold">ModuleConfiguration</emphasis> is a bean wired in Spring
                XML that instructs the KNS to load various pieces of configuration for a particular
                module. A client application could create a single module or multiple modules,
                depending on how it is organized. This configuration allows for the specification of
                the following:<itemizedlist>
                    <listitem>
                        <para>The module’s namespace </para>
                    </listitem>
                    <listitem>
                        <para>The Data Dictionary files to load </para>
                    </listitem>
                    <listitem>
                        <para>The OJB repository files to load </para>
                    </listitem>
                    <listitem>
                        <para>The package prefix of business objects in this module </para>
                    </listitem>
                    <listitem>
                        <para>Externalizable business object definitions </para>
                    </listitem>
                </itemizedlist></para>
            <para>Here is an example of what this configuration might look like:</para>
            <programlisting>&lt;bean id="sampleAppModuleConfiguration"
 class="org.kuali.rice.kns.bo.ModuleConfiguration">
    &lt;property name="namespaceCode" value="tv"/>
    &lt;property name="initializeDataDictionary" value="true"/>
    &lt;property name="dataDictionaryPackages">
        &lt;list>
            &lt;value>classpath:edu/sampleu/travel/datadictionary&lt;/value>
        &lt;/list>
    &lt;/property>
    &lt;property name="databaseRepositoryFilePaths">
        &lt;list>
            &lt;value>OJB-repository-sampleapp.xml&lt;/value>
        &lt;/list>
    &lt;/property>
    &lt;property name="packagePrefixes">
        &lt;list>
            &lt;value>edu.sampleu.travel&lt;/value>
        &lt;/list>
    &lt;/property>
&lt;/bean></programlisting>
            <para>When the module is initialized by the KNS, it will load all of the Data Dictionary
                files into the Data Dictionary service. Additionally, all OJB files will be loaded
                and merged into the main OJB repository. The <emphasis role="bold"
                    >packagePrefixes</emphasis> are used to identify which business objects this
                module is responsible for.</para>
            <para>There are more configuration options on the <emphasis role="bold"
                    >ModuleConfiguration</emphasis>. See the javadocs on this class for more
                information.</para>
        </sect2>
        <sect2>
            <title>KNS Configuration Parameters</title>
            <para>The KNS supports numerous configuration parameters that can be set in the Rice
                configuration file. Below is a list of these with descriptions and defaults.</para>
            <para>
                <table frame="none">
                    <title>KNS Configuration Parameters</title>
                    <tgroup cols="3">
                        <colspec colname="c1" colnum="1" colwidth="1.0*"/>
                        <colspec colname="c2" colnum="2" colwidth="1.0*"/>
                        <colspec colname="c3" colnum="3" colwidth="1.0*"/>
                        <thead>
                            <row>
                                <entry>Property </entry>
                                <entry>Description </entry>
                                <entry>Default </entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>application.url </entry>
                                <entry>Base URL of the application. Example:
                                    http://localhost/kr-dev</entry>
                                <entry>${appserver.url}/${app.context.name}</entry>
                            </row>
                            <row>
                                <entry>attachments.directory</entry>
                                <entry>Directory in which to store attachments </entry>
                                <entry>${java.io.tmpdir}/${environment}/attachments</entry>
                            </row>
                            <row>
                                <entry>attachments.pending.directory</entry>
                                <entry>Directory in which to store attachments on a document or
                                    object which have not yet been persisted</entry>
                                <entry>${java.io.tmpdir}/${environment}/attachments/pending</entry>
                            </row>
                            <row>
                                <entry>classpath.resource.prefix</entry>
                                <entry>The location, in the classpath, of methods that may be called
                                    by DWR.</entry>
                                <entry>/WEB-INF/classes/</entry>
                            </row>
                            <row>
                                <entry>externalizable.help.url</entry>
                                <entry>Base URL at which web-based help content will be
                                    located</entry>
                                <entry>/${app.context.name}/kr/static/help/</entry>
                            </row>
                            <row>
                                <entry>externalizable.images.url</entry>
                                <entry>Base URL at which images are located </entry>
                                <entry>/${app.context.name}/kr/static/images/</entry>
                            </row>
                            <row>
                                <entry>kr.externalizable.images.url</entry>
                                <entry>Base URL at which images that are part of the standard Kuali
                                    Rice image set are stored </entry>
                                <entry>/${app.context.name}/kr/static/images/</entry>
                            </row>
                            <row>
                                <entry>kr.url</entry>
                                <entry>Base URL of the KNS struts module. Includes the various
                                    built-in GUI components such as lookups, inquiries, etc.</entry>
                                <entry> ${application.url}/kr</entry>
                            </row>
                            <row>
                                <entry>production.environment.code</entry>
                                <entry>The environment code that will be used to identify this
                                    application as a “production” instance. Certain features are
                                    turned off in non-production instances (email, for example) </entry>
                                <entry>PRD</entry>
                            </row>
                            <row>
                                <entry>mail.relay.server</entry>
                                <entry>Name of the SMTP server to use for sending emails from the
                                    KNS</entry>
                                <entry/>
                            </row>
                            <row>
                                <entry>kr.incident.mailing.list</entry>
                                <entry>The email address where exception and incident reports should
                                    be sent</entry>
                                <entry/>
                            </row>
                            <row>
                                <entry>javascript.files</entry>
                                <entry>A comma-separated list of javascript files to load on every
                                    KNS-based web page </entry>
                                <entry>See
                                    impl/src/main/resources/resources/META-INF/common-config-defaults.xml
                                    in the source distribution</entry>
                            </row>
                            <row>
                                <entry>css.files</entry>
                                <entry>A comma-separated list of css files to load on every
                                    KNS-based web page</entry>
                                <entry>See
                                    impl/src/main/resources/resources/META-INF/common-config-defaults.xml
                                    in the source distribution</entry>
                            </row>
                            <row>
                                <entry>enable.nonproduction.data.unmasking</entry>
                                <entry>If the current application is running in an non-production
                                    environment, this determines if all fields should be unmasked in
                                    the Nervous System, even if the field would otherwise be
                                    masked.</entry>
                                <entry>false</entry>
                            </row>
                            <row>
                                <entry>kns.cache.parameter.max.size</entry>
                                <entry>The maximum number of parameters that can be stored in the
                                    kns parameter cache</entry>
                                <entry>200</entry>
                            </row>
                            <row>
                                <entry>kns.cache.parameter.max.age.seconds</entry>
                                <entry>The maxiumum age (in seconds) of entries in the parameter
                                    cache </entry>
                                <entry>3600</entry>
                            </row>
                            <row>
                                <entry>kns.cache.nonDatabaseComponent.max.size </entry>
                                <entry>The maximum size of the cache that is used to store parameter
                                    components that don’t come from the database (i.e. are loaded
                                    from the Data Dictionary and other locations) </entry>
                                <entry>50</entry>
                            </row>
                            <row>
                                <entry>kns.cache.nonDatabaseComponent.max.age.seconds</entry>
                                <entry>The maximum ago (in seconds) of entries in the parameter
                                    non-database component cache</entry>
                                <entry>3600</entry>
                            </row>
                            <row>
                                <entry>session.document.cache.size</entry>
                                <entry>The max size of the cache used to store document
                                    sessions</entry>
                                <entry>100</entry>
                            </row>
                            <row>
                                <entry>portal.javascript.files</entry>
                                <entry>A list of Javascript files to be included int the "portal",
                                    ie the frame around the application pages.</entry>
                                <entry/>
                            </row>
                            <row>
                                <entry>portal.css.files</entry>
                                <entry>A list of CSS files to be used in the "portal", ie the frame
                                    around the application pages.</entry>
                                <entry>rice-portal/css/portal.css</entry>
                            </row>
                            <row>
                                <entry>rice.kns.struts.config.files</entry>
                                <entry>The struts-config.xml configuration file that the KNS portion
                                    of the Rice application will use.</entry>
                                <entry>/kr/WEB-INF/struts-config.xml</entry>
                            </row>
                            <row>
                                <entry>rice.kns.illegalBusinessObjectsForSave</entry>
                                <entry>A comma-separated list of business objects that the KNS
                                    should not be allowed to save</entry>
                                <entry/>
                            </row>
                            <row>
                                <entry>rice.kns.illegalBusinessObjectsForSave.applyCheck</entry>
                                <entry>If set to true, the check for illegal business objects to
                                    save will be performed, if false, it will not</entry>
                                <entry>true</entry>
                            </row>
                            <row>
                                <entry>encryption.key</entry>
                                <entry>The DES key to use for encrypting data elements that are
                                    configured for encryption in the KNS</entry>
                                <entry/>
                            </row>
                            <row>
                                <entry>rice.struts.message.resources</entry>
                                <entry>The key used to load message property files. The value should
                                    be a comma delimited list or properties files.</entry>
                                <entry>KR-ApplicationResources,org.kuali.rice.kew.ApplicationResources,org.kuali.rice.ksb.messaging.ApplicationResources,KIM-ApplicationResources</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>
        </sect2>
    </sect1>
    <sect1>
        <title>KNS Business Object Framework</title>
        <sect2>
            <title>Business Object Database Table Definition</title>
            <para>Business object instances are typically java object representations of rows of a
                database table.</para>
            <para>The addition of following columns to each database table is strongly suggested:<itemizedlist>
                    <listitem>
                        <para>Object ID</para>
                    </listitem>
                    <listitem>
                        <para>Version number</para>
                    </listitem>
                </itemizedlist></para>
            <para>The Object ID is used as a globally unique identifier (or GUID) of each row across
                all database tables. That is, every row in every table should have a different
                Object ID value. It is typically defined as a VARCHAR field of 36 characters, and
                should be named "OBJ_ID" in the database. A unique constraint should be applied to
                the object ID column, but must NOT be part of the primary key. The KNS system will
                assume that each row has a unique value.</para>
            <para>The object ID value is automatically stored by the framework and/or the database
                layer.</para>
            <para>KFS/Rice uses optimistic locking to provide concurrency control. Optimistic
                locking requires the use of a version number field, named "VER_NBR". On Oracle, the
                field is defined as a NUMBER(8,0). On MySQL, the field is defined as a DECIMAL(8).
                This column should NOT be part of the primary key.</para>
            <sect3>
                <title>About optimistic locking</title>
                <para>Optimistic locking helps to prevent updates to stale data and consists of two steps:<orderedlist>
                        <listitem>
                            <para>Retrieval of a row from a database, including the value of the
                                version number column </para>
                        </listitem>
                        <listitem>
                            <para>Updating/deleting a row from the database with the same primary
                                key and version number criteria. If updating the table, the version
                                number will be incremented by one. </para>
                        </listitem>
                    </orderedlist></para>
                <para>The following series of steps demonstrates how optimistic locking works:<orderedlist>
                        <listitem>
                            <para>User A retrieves the row for chart code "BL". The row has version
                                number of 3. </para>
                        </listitem>
                        <listitem>
                            <para>User A performs an update of the "BL" record. The SQL query that
                                updates the record would read something like "UPDATE CA_CHART_T SET
                                &lt;some updates>, VER_NBR = 4 WHERE FIN_COA_CD = "BL" and VER_NBR =
                                3. (The "4" refers to the incremented version number.) </para>
                        </listitem>
                        <listitem>
                            <para>User B retrieves the row for chart code "BL". The version number
                                is now 4. </para>
                        </listitem>
                        <listitem>
                            <para>User B performs an update of the "BL" record. The SQL query that
                                updates the record would read something like "UPDATE CA_CHART_T SET
                                &lt;some updates>, VER_NBR = 5 WHERE FIN_COA_CD = "BL" and VER_NBR =
                                4. (The "5" refers to the incremented version number.) </para>
                        </listitem>
                    </orderedlist></para>
                <para>The following series of steps demonstrates how optimistic locking prevents
                    concurrency problems.<orderedlist>
                        <listitem>
                            <para>User A retrieves the row for chart code "BL". The row has version
                                number of 3. </para>
                        </listitem>
                        <listitem>
                            <para>User B retrieves the row for chart code "BL". Like user A, the
                                version number is 3. </para>
                        </listitem>
                        <listitem>
                            <para>User A performs a update of the "BL" record. The SQL query that
                                updates the record would read something like "UPDATE CA_CHART_T SET
                                &lt;some updates>, VER_NBR = 4 WHERE FIN_COA_CD = "BL" and VER_NBR =
                                3. (The "4" refers to the incremented version number.) </para>
                        </listitem>
                        <listitem>
                            <para>User B performs a update of the "BL" record. The SQL query that
                                updates the record would read something like what User A executed
                                above (notice the version numbers). However, the previous step
                                already updated the version number to 4 from 3, so this update does
                                nothing (i.e. update row count = 0) because it was trying to update
                                the BL chart with a version number of 3. The system detects the 0
                                update row count, and throws an OptimisticLockingException. This
                                exception indicates that the system tried to update stale data.
                            </para>
                        </listitem>
                    </orderedlist></para>
            </sect3>
            <sect3>
                <title>Business Object Database Mapping</title>
                <para>The default mapping library used by the KNS for this release is OJB from
                    Apache. More information can be found on the OJB website: <link
                        xlink:href="http://db.apache.org/ojb/"
                    >http://db.apache.org/ojb/</link>.</para>
                <sect4>
                    <title>Purpose of OJB mappings</title>
                    <para>OJB repository files map the following information:<orderedlist>
                            <listitem>
                                <para>The BusinessObject (BO) mapped to a given database table
                                </para>
                            </listitem>
                            <listitem>
                                <para>The getter/setter method in the BO mapped to a given database
                                    column </para>
                            </listitem>
                            <listitem>
                                <para>The fields(s) comprising foreign keys between a business
                                    object and its reference(s) </para>
                            </listitem>
                        </orderedlist></para>
                </sect4>
                <sect4>
                    <title>OJB documentation</title>
                    <para>Currently, OJB is used as the underlying persistence layer. It converts
                        database rows into java objects upon retrieval, and vice versa upon
                        updates/deletes. This section assumes that the reader is familiar with the
                        basic mapping constructs/principles described on these pages:<itemizedlist>
                            <listitem>
                                <para>http://db.apache.org/ojb/docu/guides/repository.html#class-descriptor-N104E3</para>
                            </listitem>
                            <listitem>
                                <para>http://db.apache.org/ojb/docu/guides/repository.html#field-descriptor-N105C6</para>
                            </listitem>
                            <listitem>
                                <para>http://db.apache.org/ojb/docu/guides/repository.html#field-descriptor-N105C6</para>
                            </listitem>
                            <listitem>
                                <para>http://db.apache.org/ojb/docu/guides/repository.html#collection-descriptor-N10770</para>
                            </listitem>
                            <listitem>
                                <para>http://db.apache.org/ojb/docu/guides/repository.html#foreignkey
                                </para>
                            </listitem>
                            <listitem>
                                <para>http://db.apache.org/ojb/docu/guides/repository.html#inverse-foreignkey
                                </para>
                            </listitem>
                            <listitem>
                                <para>http://db.apache.org/ojb/docu/guides/basic-technique.html
                                </para>
                            </listitem>
                        </itemizedlist></para>
                </sect4>
                <sect4>
                    <title>OJB field-level conversions</title>
                    <para>OJB provides a way to convert data before they are persisted to and
                        retrieved from the database. This is accomplished by specifying a class that
                        implements org.apache.ojb.broker.accesslayer.conversions.FieldConversion in
                        the &lt;field-descriptor> element.</para>
                    <para>The following are the more often used converters in KFS/Rice:<itemizedlist>
                            <listitem>
                                <para>org.kuali.core.util.OjbCharBooleanConversion: since boolean
                                    flags are typically stored as "Y" or "N" (i.e. strings) in the
                                    database but represented as booleans within business objects,
                                    this converter automatically allows converts between the string
                                    and the boolean representation </para>
                            </listitem>
                            <listitem>
                                <para>org.kuali.core.util.OjbKualiEncryptDecryptFieldConversion:
                                    provides seamless encryption of values when persisting, and
                                    decryption when retrieving from the database. Beware that the
                                    business object itself holds an unencrypted value, and as such,
                                    care should be taken to ensure that unencrypted sensitive data
                                    are not exposed to unauthorized parties. </para>
                            </listitem>
                        </itemizedlist></para>
                    <para>Both OJB and the KNS offer a number of FieldConversion implementations
                        beyond these two for use in client applications.</para>
                    <para>Example converter declaration for a sample Business Object</para>
                    <programlisting>&lt;field-descriptor name="bankAccountNbr" column="BNK_ACCT_NBR" jdbc-type="VARCHAR" conversion="org.kuali.core.util.OjbKualiEncryptDecryptFieldConversion"/></programlisting>
                </sect4>
                <sect4>
                    <title>When to use OJB vs. data dictionary relationships</title>
                    <para>OJB relationships should be used to define relationships between tables
                        that are guaranteed to exist within the same database.</para>
                    <para>For example, assume a sample Business Object class “Bank”. The Bank class
                        contains a BankType reference object. Typically a BankType class table would
                        exist in the same database as the Bank class table. In this example the
                        relationship between Bank and BankType can be defined by OJB. However, a
                        “User” business object table typically will exist in an external system
                        since it will likely be referenced by more than one Rice client application.
                        If a BO had a relationship with a “User” BO, the mapping would require that
                        the relationship be set up via the data dictionary files (which will be
                        discussed in detail later in this document). Any business object
                        implementing the org.kuali.rice.kns.bo.ExternalizableBusinessObject
                        interface needs to be related to via the data dictionary.</para>
                </sect4>
                <sect4>
                    <title>Example OJB Mapping</title>
                    <para>Here is an example directly from Rice in the file
                        OJB-repository-kns.xml:</para>
                    <programlisting>&lt;class-descriptor class="org.kuali.rice.kns.bo.StateImpl" table="KR_STATE_T">
    &lt;field-descriptor name="postalCountryCode" column="POSTAL_CNTRY_CD" jdbc-type="VARCHAR" primarykey="true" index="true" />
    &lt;field-descriptor name="postalStateCode" column="POSTAL_STATE_CD" jdbc-type="VARCHAR" primarykey="true" index="true" />
    &lt;field-descriptor name="postalStateName" column="POSTAL_STATE_NM" jdbc-type="VARCHAR" />
    &lt;field-descriptor name="objectId" column="OBJ_ID" jdbc-type="VARCHAR" index="true" />
    &lt;field-descriptor name="versionNumber" column="VER_NBR" jdbc-type="BIGINT" locking="true" />
    &lt;field-descriptor name="active" column="ACTV_IND" jdbc-type="VARCHAR" conversion="org.kuali.rice.kns.util.OjbCharBooleanConversion"/>

    &lt;reference-descriptor name="country" class-ref="org.kuali.rice.kns.bo.CountryImpl" auto-retrieve="true" auto-update="none" auto-delete="none">
        &lt;foreignkey field-ref="postalCountryCode" />
    &lt;/reference-descriptor>
&lt;/class-descriptor></programlisting>
                    <para>In this OJB mapping, we can determine the following information:<orderedlist>
                            <listitem>
                                <para>The KR_STATE_T table is mapped to the
                                    org.kuali.rice.kns.bo.StateImpl business object </para>
                            </listitem>
                            <listitem>
                                <para>The POSTAL_CNTRY_CD column is mapped to the
                                    "postalCountryCode" property of the BO (i.e. accessed using the
                                    getPostalCountryCode and setPostalCountryCode methods), is a
                                    VARCHAR, is indexed, and is one of the fields in the primary key
                                </para>
                            </listitem>
                            <listitem>
                                <para>The POSTAL_STATE_CD column is mapped to the "postalStateCode"
                                    property of the BO, is a VARCHAR, is indexed, and is one of the
                                    fields in the primary key </para>
                            </listitem>
                            <listitem>
                                <para>The OBJ_ID column is mapped to the "objectId" property, is
                                    indexed, and is a VARCHAR </para>
                            </listitem>
                            <listitem>
                                <para>The VER_NBR column is mapped to the "verionNumber" property,
                                    is a BIGINT, and is used for locking </para>
                            </listitem>
                            <listitem>
                                <para>The ACTV_IND column is mapped to the “active” property, is a
                                    VARCHAR, and uses the conversion class <emphasis role="bold"
                                        >org.kuali.rice.kns.util.OjbCharBooleanConversion</emphasis>
                                </para>
                            </listitem>
                    </orderedlist></para>
                    <para>We can determine the following information about the "country" reference object:<orderedlist>
                            <listitem>
                                <para>It is of type <emphasis role="bold"
                                        >org.kuali.rice.kns.bo.CountryImpl</emphasis>
                                </para>
                            </listitem>
                            <listitem>
                                <para>the auto-retrieve attribute is true: When the StateImpl is
                                    retrieved from OJB, the CountryImpl object will behave like it
                                    was retrieved as well (the <emphasis role="bold"
                                        >proxy</emphasis> attribute of the ‘field-descriptor’ tag
                                    can be set to true or false to determine whether the CountryImpl
                                    is really retrieved when the account is retrieved or not)
                                </para>
                            </listitem>
                            <listitem>
                                <para>the auto-update attribute is none: When the StateImpl is
                                    updated using OJB, the CountryImpl object will not be updated
                                    even if changes have been made to it </para>
                            </listitem>
                            <listitem>
                                <para>the auto-delete attribute is none: When the StateImpl is
                                    deleted using OJB, the CountryImpl object will not be deleted
                                </para>
                            </listitem>
                            <listitem>
                                <para>The &lt;foreignkey> tag specifies the fields in the StateImpl
                                    BO that are in a foreign key relationship and their order with
                                    the primary key fields in the CountryImpl BO. The CountryImpl BO
                                    has one primary key field, and the value from StateImpl's
                                    “postalCountryCode” property is used as the value for
                                    CountryImpl’s primary key value. </para>
                            </listitem>
                        </orderedlist></para>
                </sect4>
                <sect4>
                    <title>Example OJB Mapping for Collection Descriptor</title>
                    <para>A mapping may also define a collection-descriptor tag as follows:</para>
                    <programlisting>&lt;class-descriptor class="org.kuali.rice.kns.test.document.bo.AccountManager" table="TRV_ACCT_FO">
    &lt;field-descriptor name="id" column="acct_fo_id" jdbc-type="BIGINT" primarykey="true" autoincrement="true" sequence-name="TRV_FO_ID_S" />
    &lt;field-descriptor name="userName" column="acct_fo_user_name" jdbc-type="VARCHAR" />

    &lt;collection-descriptor name="accounts" collection-class="org.apache.ojb.broker.util.collections.ManageableArrayList" element-class-ref="org.kuali.rice.kns.test.document.bo.Account" auto-retrieve="true" auto-update="object" auto-delete="object" proxy="true" >
        &lt;orderby name="accountNumber" sort="ASC" />
        &lt;inverse-foreignkey field-ref="amId" />
    &lt;/collection-descriptor>
&lt;/class-descriptor>
</programlisting>
                    <para>We can determine the following information about the "accounts" collection reference:<orderedlist>
                            <listitem>
                                <para>The collection itself is of type
                                    org.apache.ojb.broker.util.collections.ManageableArrayList,
                                    which keeps track of which elements have been removed from the
                                    array, to help when deleting elements. </para>
                            </listitem>
                            <listitem>
                                <para>Each element of the collection is of type
                                    org.kuali.rice.kns.test.document.bo.Account. </para>
                            </listitem>
                            <listitem>
                                <para>The auto-retrieve attribute is true: when the AccountManager
                                    is retrieved from the database, the collection will be populated
                                    or behave as if it were populated upon accessing the collection.
                                    (the proxy setting determines whether the database is queried
                                    when the AccountManager is retrieved from the DB or whether it
                                    will retrieve from the DB only when the collection is accessed
                                    (i.e. lazy loading)). </para>
                            </listitem>
                            <listitem>
                                <para>The auto-update attribute is object: when the AccountManager
                                    is inserted or updated, the accounts collection is inserted or
                                    updated accordingly. </para>
                            </listitem>
                            <listitem>
                                <para>The auto-delete attribute is object: when the AccountManager
                                    is deleted, the corresponding accounts will be deleted as well.
                                </para>
                            </listitem>
                            <listitem>
                                <para>The &lt;orderby> tag specifies the sort order of elements in
                                    the collection. In this case, the account numbers will be in
                                    ascending order in the collection. </para>
                            </listitem>
                            <listitem>
                                <para>The &lt;inverse-foreignkey> specifies the fields of the
                                    element BO (i.e. Account) that will match the primary key fields
                                    of the AccountManager BO. The “amId” attribute in the Account
                                    table will be used to find objects that match the primary key of
                                    the AccountManager object, or in this case the “id” attribute.
                                </para>
                            </listitem>
                        </orderedlist></para>
                </sect4>
            </sect3>
        </sect2>
        <sect2>
            <title>Business Object Java Definition</title>
            <para>Business Objects are java classes that implement the <emphasis role="bold"
                    >org.kuali.core.bo.BusinessObject</emphasis> interface. However, a majority of
                business objects extend <emphasis role="bold"
                    >org.kuali.core.bo.PersistableBusinessObjectBase</emphasis>, which implements
                    <emphasis role="bold">org.kuali.core.bo.PersistableBusinessObject</emphasis> and
                    <emphasis role="bold">org.kuali.core.bo.BusinessObject</emphasis>. Business
                Objects which extend from the class <emphasis role="bold"
                    >PersistableBusinessObjectBase</emphasis> also have an advantage in that they
                will inherit getter and setter methods for the attributes ‘version number’ and
                ‘object id’.</para>
            <para><emphasis role="bold">In each application, all simple class names (i.e. ignoring
                    the package) should be unique. If multiple packages contain the same class name,
                    the data dictionary may not load the duplicated classes
                properly.</emphasis></para>
            <para>Business objects need to implement getter and setter methods for each field that
                is mapped between java business objects and the database table (the mapping is
                described later). Therefore, if, in java, the ACCOUNT_NM database column is named
                "accountName", then the getter method should be called getAccountName and the setter
                should be setAccountName (i.e. the conventions follow the standard Java bean getters
                and setters practices).</para>
            <para>Objects that extend <emphasis role="bold"
                    >org.kuali.core.bo.BusinessObjectBase</emphasis> must also implement the
                toStringMapper method, which returns a map of the BO's fields to be used in
                toString.</para>
            <para>The <emphasis role="bold"
                    >org.kuali.core.bo.PersistableBusinessObjectBase</emphasis> class has several
                more methods that can be overridden that customize the behavior of the business
                object. Just a few examples are customizations that can be made upon persistence and
                retrieval of the business object, and how reference objects of the business object
                are refreshed, as well as other methods.</para>
            <sect3>
                <title>Reference Objects</title>
                <para>A reference object is a member variable of a business object that also
                    implements the BusinessObject interface. It refers to the database row
                    referenced by the values in a foreign key relationship. For example, the
                    CampusImpl BO/table has a column for a campus type code (CAMPUS_TYP_CD).
                    Therefore, the CampusImpl BO may have a referenced CampusTypeImpl object, which
                    represents the campus type row referred to by the campus’ campus type code. Here
                    is the CampusImpl OJB mapping:</para>
                <programlisting>&lt;class-descriptor class="org.kuali.rice.kns.bo.CampusImpl" table="KRNS_CAMPUS_T">
    &lt;field-descriptor name="campusCode" column="CAMPUS_CD" jdbc-type="VARCHAR" primarykey="true" index="true" />
    &lt;field-descriptor name="campusName" column="CAMPUS_NM" jdbc-type="VARCHAR" />
    &lt;field-descriptor name="campusShortName" column="CAMPUS_SHRT_NM" jdbc-type="VARCHAR" />
    &lt;field-descriptor name="campusTypeCode" column="CAMPUS_TYP_CD" jdbc-type="VARCHAR" />
    &lt;field-descriptor name="objectId" column="OBJ_ID" jdbc-type="VARCHAR" index="true" />
    &lt;field-descriptor name="versionNumber" column="VER_NBR" jdbc-type="BIGINT" locking="true" />
    &lt;field-descriptor name="active" column="ACTV_IND" jdbc-type="VARCHAR" conversion="org.kuali.rice.kns.util.OjbCharBooleanConversion" />
    &lt;reference-descriptor name="campusType" class-ref="org.kuali.rice.kns.bo.CampusTypeImpl" auto-retrieve="true" auto-update="none" auto-delete="none">
        &lt;foreignkey field-ref="campusTypeCode" />
    &lt;/reference-descriptor>
&lt;/class-descriptor></programlisting>
                <para>Here are bits of the CampusImpl class file:</para>
                <programlisting>public class CampusImpl extends PersistableBusinessObjectBase implements Campus, Inactivateable {
    private String campusCode;
    private String campusName;
    private String campusShortName;
    private String campusTypeCode;
protected boolean active;

    private CampusType campusType;
...</programlisting>
                <para>A collection reference is a member variable of a business object that
                    implements java.util.Collection, with each element in the collection being a
                    BusinessObject. A collection reference would be appropriate to model something
                    like the list of Kuali Financial sub accounts of the Kuali Financial account
                    business object.</para>
                <para>A reference object or collection is defined in two steps:<orderedlist>
                        <listitem>
                            <para>A field in a business object is created for either the reference
                                object or collection reference </para>
                        </listitem>
                        <listitem>
                            <para>A relationship is mapped within either OJB (See above) or the data
                                dictionary (See below) </para>
                        </listitem>
                    </orderedlist></para>
                <para>To refresh (or retrieve) a reference object is to reload the referenced row
                    from the database, in case the foreign key field values or referenced data have
                    changed.</para>
                <para>For references mapped within the data dictionary, the framework does not have
                    the logic to enable refreshing of a reference. The code must both implement the
                    logic to refresh a data dictionary defined reference and the logic to invoke
                    refreshing. A specific explanation can be found below.</para>
                <sect4>
                    <title>Refreshing reference objects mapped in OJB</title>
                    <para>For references mapped within OJB, the framework automatically takes care of
                        the logic to enable refreshing of a reference. Under certain circumstances, it's
                        able to automatically refresh references upon retrieval of the main BO from the
                        database, and refreshing can also be invoked manually.</para>
                    <para>Note that this means that if the value of a foreign key field is changed, the
                        corresponding reference object is not refreshed automatically. Taking the
                        CampusImpl BO example above, if the code alters the CampusImpl’s campusTypeCode
                        field, the framework will not automatically retrieve the new associated
                        CampusTypeImpl BO reference object. To refresh the CampusImpl’s CampusTypeImpl
                        reference object with the new campus type code, refresh/retrieve must be
                        manually called (see below).</para>
                </sect4>
                <sect4>
                    <title>Refreshing reference objects not mapped in OJB</title>
                    <para>For references with relationships that are not mapped in OJB, code will need
                        to be written to accommodate refreshing. A common example of this is Person
                        object references, because institutions may decide to use another source for
                        Identity Management (e.g. LDAP).</para>
                    <para>Although there are alternative strategies for accommodating refreshing,
                        typically getter methods of these non-OJB mapped reference objects include the
                        code that retrieves the reference object from the underlying datasource.</para>
                    <para>In contrast to OJB-mapped references, note that this strategy allows for the
                        automatic refreshing of reference objects when a foreign key field value has
                        been changed. If, in our example using CampusImpl above, the reference object
                        for CampusTypeImpl was not defined in OJB, the string campusTypeCode may be
                        changed and that would be enough to alter the getter method for CampusTypeImpl
                        to properly retrieve the correct row from the database.</para>
                </sect4>
                <sect4>
                    <title>Initializing collection references</title>
                    <para>Business objects fall into two broad, and for the most part mutually
                        exclusive, categories: those that are edited by maintenance documents and
                        those that are not. This section refers only to business objects that are
                        edited by maintenance documents that have updatable collections.</para>
                    <para>When constructing this type of BusinessObject, initialize each of the
                        updatable collection references to an instance of
                        org.kuali.rice.kns.util.TypedArrayList. TypedArrayList is a subclass of
                        ArrayList that takes in a java.lang.Class object in its constructor. All
                        elements of this list must be of that type, and when the get(int) method is
                        called, if necessary, this list will automatically construct items of the
                        type to avoid an IndexOutOfBoundsException. Take the example below, the
                        SummaryAccount BO contains an updatable reference to a list of
                        PurApSummaryItem objects.</para>
                    <programlisting>public class SummaryAccount {
    private List&lt;PurApSummaryItem> items;


    public SummaryAccount() {
        super();
        items = new TypedArrayList(PurApSummaryItem.class);
    }
}</programlisting>
                    <para>When a collection is non-updatable (i.e. read only from the database), it
                        is not necessary to initialize the collection. OJB will take care of list
                        construction and population.</para>
                </sect4>
            </sect3>    
            <sect3>
                <title>Inactivateable Business Objects</title>
                <para>Business objects that have active/inactive states should implement the
                    Inactivateable interface:</para>
                <programlisting>public interface Inactivateable {

    public boolean isActive();

                /* Indicates whether the record is active or inactive.
 */
    public void setActive(boolean active);
    /* Sets the record to active or inactive.
 */
}
</programlisting>
                <para>By implementing this interface, functionality such as default active checks
                    and inactivation blocking in the maintenance framework can be taken advantage
                    of.</para>
            </sect3>
            <sect3>
                <title>InactivateableFromTo Business Objects</title>
                <para>Business objects that have active from and to dates (effective dating) should
                    implement the InactivateableFromTo interface:</para>
                <programlisting>public interface InactivateableFromTo extends Inactivateable {


    /* Sets the date for which record will be active
     * 
@param from
* - Date value to set
 
    */
    public void setActiveFromDate(Date from);

    
    /* Gets the date for which the record become active
     *
 @return Date
     */
    public Date getActiveFromDate();


    /* Sets the date for which record will be active to
     * @param from
* - Date value to set
     */
    
public void setActiveToDate(Date to);


    /* Gets the date for which the record become inactive
     *
 @return Date
     */
    
public Date getActiveToDate();

    

/* Gets the date for which the record is being compared to in determining active/inactive
     *
 @return Date
     */
    
public Date getActiveAsOfDate();


    /* Sets the date for which the record should be compared to in determining active/inactive, if
     * not set then the current date will be used
     *
 @param activeAsOfDate
     * - Date value to set
     
*/
    
public void setActiveAsOfDate(Date activeAsOfDate);


}
</programlisting>
                <sect4>
                    <title>Explanation of InactivateableFromTo fields</title>
                    <para><emphasis role="italic">activeFromDate</emphasis> - The date for which the
                        record becomes active (inclusive when checking active status).</para>
                    <para><emphasis role="italic">activeToDate</emphasis> - The date to which the
                        record is active (exclusive when checking active status).</para>
                    <para><emphasis role="italic">active</emphasis> - The active field is calculated
                        from the active from and to dates. If the active from date is less than or
                        equal to current date (or from date is null) and the current date is less
                        than the active to date (or to date is null) the active getter will return
                        true, otherwise it will return false.</para>
                    <para><emphasis role="italic">current</emphasis> - The current field is set to
                        true for records with the greatest active from date less than or equal to
                        the current date.</para>
                    <para>For example say we have two employee records:<itemizedlist>
                            <listitem>
                                <para>rec 1, empl A, active from 01/01/2010, active to 01/01/2011
                                </para>
                            </listitem>
                            <listitem>
                                <para>rec 2, empl A, active from 03/01/2010, active to 01/01/2011
                                </para>
                            </listitem>
                        </itemizedlist></para>
                    <para>With 03/01/2010 &lt;= current date &lt; 01/01/2011 both of these records
                        will be active, however only rec 2 would be current since it has a later
                        active begin date.</para>
                    <para>To determine the maximum active begin date, records are grouped by the
                        fields declared in the data dictionary for the business object.</para>
                    <para><emphasis role="italic">activeAsOfDate</emphasis> - By default when
                        checking the active or current status the current date is used, however this
                        field can be set to check the status as of another date.</para>
                    <para>For example say we have a record with active from date 01/01/2010 and
                        active to date 06/01/2010, with the current date equal to 08/01/2010. With
                        the active as of date empty, the current date will be used and this record
                        will be determined inactive. However if we set the active as of date equal
                        to 05/01/2010 (which falls between the active date range) and query, this
                        record will be determined active.</para>
                </sect4>
                <sect4>
                    <title>Framework Support</title>
                    <para>Business objects that implement InactivateableFromTo can participate in
                        default existence checks and inactivation blocking functionality. In
                        addition, the lookup framework contains special logic for searching on
                        InactivateableFromTo instances. This includes:<orderedlist>
                            <listitem>
                                <para>Translating criteria on the active field (active true or
                                    false) to criteria on the active to and from date fields </para>
                            </listitem>
                            <listitem>
                                <para>Translating criteria on the current field (current true of
                                    false) to criteria selecting the active record with the greatest
                                    active from date less than or equal to the active date</para>
                            </listitem>
                            <listitem>
                                <para> Handles the active as of date when doing active or current
                                    queries </para>
                            </listitem>
                        </orderedlist></para>
                </sect4>
                <sect4>
                    <title>InactivateableFromToService</title>
                    <para>For finding active and current InactivateableFromTo records
                        InactivateableFromToService can be used. This service provides many methods
                        for dealing with InactivateableFromTo objects in code.</para>
                </sect4>
                <sect4>
                    <title>Group by Attributes</title>
                    <para>In order to determine whether or not an InactivateableFromTo record is
                        current, the framework must know what fields of the business object to group
                        by (see ‘current’ in ‘Explanation of InactivateableFromTo fields’). This is
                        configured by setting the groupByAttributesForEffectiveDating property on
                        the data dictionary BusinessObjectEntry.</para>
                    <para><emphasis role="italic">Example:</emphasis></para>
                    <programlisting>&lt;bean id="TravelAccountUseRate-parentBean" abstract="true" parent="BusinessObjectEntry">
    &lt;property name="businessObjectClass" value="edu.sampleu.travel.bo.TravelAccountUseRate"/>
    &lt;property name="inquiryDefinition">
        &lt;ref bean="TravelAccountUseRate-inquiryDefinition"/>
    &lt;/property>
    &lt;property name="lookupDefinition">
        &lt;ref bean="TravelAccountUseRate-lookupDefinition"/>
    &lt;/property>
    &lt;property name="titleAttribute" value="Travel Account Use Rate"/>
    &lt;property name="objectLabel" value="Travel Account Use Rate"/>
    &lt;property name="attributes">
        &lt;list>
            &lt;ref bean="TravelAccountUseRate-id"/>
            &lt;ref bean="TravelAccountUseRate-number"/>
            &lt;ref bean="TravelAccountUseRate-rate"/>
            &lt;ref bean="TravelAccountUseRate-activeFromDate"/>
            &lt;ref bean="TravelAccountUseRate-activeToDate"/>
            &lt;ref bean="TravelAccountUseRate-activeAsOfDate"/>
            &lt;ref bean="TravelAccountUseRate-active"/>
            &lt;ref bean="TravelAccountUseRate-current"/>
        &lt;/list>
    &lt;/property>
    &lt;property name="groupByAttributesForEffectiveDating">
        &lt;list>
            &lt;value>number&lt;/value>
        &lt;/list>
    &lt;/property>
&lt;/bean></programlisting>
                </sect4>
            </sect3>
        </sect2>
    </sect1>
    <sect1>
        <title>KNS Data Dictionary Overview</title>
        <para>The data dictionary is the main repository for metadata storage and provides the glue
            to combining classes related to a single piece of functionality. The data dictionary is
            specified in XML and allows for quick changes to be made to functionality. The Data
            Dictionary files use the Spring Framework for configuration so the notation and parsing
            operation will match that of the files that define the module configurers.</para>
        <para>The contents of the data dictionary are defined by two sets of vocabularies; the
            ‘business object’ and the ‘document’ data. </para>
        <sect2>
            <title>Business Object Data Dictionary</title>
            <para>Business Object Data Dictionary entries provide the KNS framework extra metadata
                about a business object which is not provided by the persistence mapping or the
                class itself.</para>
            <para>The business object data dictionary contains information about:<itemizedlist>
                    <listitem>
                        <para>Descriptive labels for each attribute in the business object (data
                            dictionary terminology uses the term “attribute” to refer to fields with
                            getter/setter methods). </para>
                    </listitem>
                    <listitem>
                        <para>Metadata about each attribute </para>
                    </listitem>
                    <listitem>
                        <para>How input fields on HTML pages should be rendered for an attribute
                            (e.g. textbox, drop down, etc.) </para>
                    </listitem>
                    <listitem>
                        <para>The data elements from the business object that are shown to users on
                            the KNS Inquiry page </para>
                    </listitem>
                    <listitem>
                        <para>The data elements of the business object that can be used as criteria
                            or shown as result data in the KNS Lookup for the business object
                        </para>
                    </listitem>
                </itemizedlist></para>
            <para>The business object data dictionary does not contain information about:<itemizedlist>
                    <listitem>
                        <para>Which BO does a table correspond to (responsibility of persistence
                            layer, e.g. OJB) </para>
                    </listitem>
                    <listitem>
                        <para>How fields in the BO correspond to database columns (responsibility of
                            persistence layer, e.g. OJB) </para>
                    </listitem>
                    <listitem>
                        <para>The orientation of various fields on user interface screens </para>
                    </listitem>
                </itemizedlist></para>
            <sect3>
                <title>Note About Following Documentation</title>
                <para>One thing to note is the use of ‘abstract’ parent beans within the Rice files.
                    These are used to facilitate easy overriding of beans from Rice in a client
                    application or a customized Rice standalone server installation. Take the
                    following example where the “RealBean” may be defined within Rice:</para>
                <programlisting>&lt;bean id=”RealBean” parent=”RealBean-parent” />

&lt;bean id=”RealBean-parent” abstract=”true” /></programlisting>
                <para>Client applications overriding this bean definition should always retain the
                    id “RealBean”. This allows for any developer working with overriding data
                    dictionary files to easily define an override using the following parent bean
                    structure:</para>
                <programlisting>&lt;bean id=”RealBean” parent=”RealBean-client-parent” />


&lt;bean id=”RealBean-client-parent” abstract=”true” parent=”RealBean-parent” >
    
&lt;!—- any client overrides go here -->
&lt;/bean></programlisting>
                <para>The setup above will take any configuration from the Rice defined
                    “RealBean-parent” and allow the client developer to override individual
                    properties inside the bean. Then when anything inside Rice or the client
                    application references the data dictionary bean “RealBean” they will get the
                    Rice defined values unless they were overridden by client application
                    developers. See the Spring Framework documentation for more examples of
                    this.</para>
                <para>For the sake of this documentation, the abstract parent bean structure will be
                    mostly ignored but its operation is consistent throughout all data dictionary
                    files.</para>
            </sect3>
            <sect3>
                <title>Data Dictionary File Layout</title>
                <para>A sample Data Dictionary file to show typical organization of various beans
                    that may be defined:</para>
                <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;beans>
    &lt;bean id="Account" parent="Account-parentBean"/>
    &lt;bean id="Account-parentBean" abstract="true" parent="BusinessObjectEntry">
        &lt;property name="businessObjectClass" value="org.kuali.kfs.coa.businessobject.Account"/>
        &lt;property name="inquiryDefinition" ref="Account-inquiryDefinition"/>
        &lt;property name="lookupDefinition" ref="Account-lookupDefinition"/>
        &lt;property name="titleAttribute" value="accountNumber"/>
        &lt;property name="objectLabel" value="Account"/>
        &lt;!-- Attribute definition -->
        &lt;property name="attributes">
            &lt;list>
                &lt;!-- list goes here -->
            &lt;/list>
        &lt;/property>
        &lt;!-- Collections -->
        &lt;property name="collections">
            &lt;list>
                &lt;!-- list goes here -->
            &lt;/list>
        &lt;/property>
        &lt;!-- Relationships -->
        &lt;property name="relationships">
            &lt;list>
                &lt;!-- list goes here -->
            &lt;/list>
        &lt;/property>
        &lt;!-- Inactivation blocking definitions -->
        &lt;property name="inactivationBlockingDefinitions">
            &lt;list>
                &lt;!-- list goes here -->
            &lt;/list>
        &lt;/property>
    &lt;/bean>
    &lt;bean id="Account-inquiryDefinition" parent="Account-inquiryDefinition-parentBean"/>
    &lt;!-- Definition of ‘Account-inquiryDefinition-parentBean’ bean goes here -->
    &lt;bean id="Account-lookupDefinition" parent="Account-lookupDefinition-parentBean"/>
    &lt;!—Definition of ‘Account-lookupDefinition-parentBean’ bean goes here -->

&lt;/beans></programlisting>
                <para>A more specific Rice example might be the CampusImpl object (whose business
                    object data dictionary file is Campus.xml). Here is the main bean definition
                    from that file:</para>
                <programlisting>&lt;bean id="Campus-parentBean" abstract="true" parent="BusinessObjectEntry">
    &lt;property name="businessObjectClass" value="org.kuali.rice.kns.bo.CampusImpl"/>
    &lt;property name="inquiryDefinition">
        &lt;ref bean="Campus-inquiryDefinition"/>
    &lt;/property>
    &lt;property name="lookupDefinition">
        &lt;ref bean="Campus-lookupDefinition"/>
    &lt;/property>
    &lt;property name="titleAttribute" value="campusCode"/>
    &lt;property name="objectLabel" value="Campus"/>
    &lt;property name="attributes">
        &lt;list>
            &lt;ref bean="Campus-campusCode"/>
            &lt;ref bean="Campus-campusName"/>
            &lt;ref bean="Campus-campusShortName"/>
            &lt;ref bean="Campus-campusTypeCode"/>
            &lt;ref bean="Campus-versionNumber"/>
        &lt;/list>
    &lt;/property>
&lt;/bean></programlisting>
                <para>One of the main properties required is the <emphasis role="bold"
                        >businessObjectClass</emphasis> which defines the java implementation class
                    that this business object data dictionary file will be used for.</para>
                <para>The <emphasis role="bold">inquiryDefinition</emphasis> and the <emphasis
                        role="bold">lookupDefinition</emphasis> will be covered later in this
                    document but for now simply note that the property is using a &lt;ref> tag to
                    point to a bean id that exists elsewhere in this file.</para>
                <para>The <emphasis role="bold">titleAttribute</emphasis> property defines the
                    attribute of the business object that is the primary key. This is typically used
                    to define which attribute can be used to display the inquiry page.</para>
                <para>The <emphasis role="bold">objectLabel</emphasis> property is the label that
                    will be used for all general business object references including where the
                    system has collections of the business object.</para>
            </sect3>
            <sect3>
                <title>Attribute Definition</title>
                <para>Attribute definitions are used to provide metadata about the attributes (i.e.
                    fields) of a business object. The following is a sampling of attribute
                    definitions from the CampusImpl business object data dictionary file:</para>
                <programlisting>&lt;bean id="Campus-campusCode-parentBean" abstract="true" parent="AttributeDefinition">
    &lt;property name="forceUppercase" value="true"/>
    &lt;property name="shortLabel" value="Campus Code"/>
    &lt;property name="maxLength" value="2"/>
    &lt;property name="validationPattern">
        &lt;bean parent="AlphaNumericValidationPattern"/>
    &lt;/property>
    &lt;property name="required" value="true"/>
    &lt;property name="control">
        &lt;bean parent="TextControlDefinition" p:size="2"/>
    &lt;/property>
    &lt;property name="summary" value="Campus Code"/>
    &lt;property name="name" value="campusCode"/>
    &lt;property name="label" value="Campus Code"/>
    &lt;property name="description" value="The code uniquely identifying a particular campus."/>
&lt;/bean>

&lt;bean id="Campus-campusTypeCode-parentBean" abstract="true" parent="AttributeDefinition">
    &lt;property name="forceUppercase" value="true"/>
    &lt;property name="shortLabel" value="Type"/>
    &lt;property name="maxLength" value="2"/>
    &lt;property name="validationPattern">
        &lt;bean parent="AlphaNumericValidationPattern"/>
    &lt;/property>
    &lt;property name="required" value="true"/>
    &lt;property name="control">
        &lt;bean parent="SelectControlDefinition" p:valuesFinderClass="org.kuali.rice.kns.lookup.keyvalues.CampusTypeValuesFinder" p:includeKeyInLabel="false"/>
    &lt;/property>
    &lt;property name="summary" value="Campus Type Code"/>
    &lt;property name="name" value="campusTypeCode"/>
    &lt;property name="label" value="Campus Type Code"/>
    &lt;property name="description" value="The code identifying type of campus."/>
&lt;/bean></programlisting>
                <para>In client applications, it is common that several business objects share a
                    field representing the same type of data. For example, a country’s postal code
                    may occur in many different tables. In these circumstances, the use of a parent
                    bean reference (parent="Country-postalCountryCode”) definition allows the reuse
                    of parts of a standard definition from the "master" business object. For
                    instance, the StateImpl business object (business object data dictionary file
                    State.xml) references the postalCountryCode property of the CountryImpl
                    (business object data dictionary file Country.xml). Because the <emphasis
                        role="bold">postalCountryCode</emphasis> fields in StateImpl and CountryImpl
                    are identical, a simple attribute definition bean in the Business Object data
                    dictionary file (State.xml) can be used:</para>
                <programlisting>&lt;bean id="State-postalCountryCode" parent="Country-postalCountryCode-parentBean"/></programlisting>
                <para>The definition of the <emphasis role="bold"
                        >Country-postalCountryCode-parentBean</emphasis> bean is seen inside the
                    Country.xml file (for the CountryImpl business object):</para>
                <programlisting>&lt;bean id="Country-postalCountryCode-parentBean" abstract="true" parent="AttributeDefinition">
    &lt;property name="name" value="postalCountryCode"/>
    &lt;property name="forceUppercase" value="true"/>
    &lt;property name="label" value="Country Code"/>
    &lt;property name="shortLabel" value="Country Code"/>
    &lt;property name="maxLength" value="2"/>
    &lt;property name="validationPattern">
        &lt;bean parent="AlphaNumericValidationPattern"/>
    &lt;/property>
    &lt;property name="required" value="true"/>
    &lt;property name="control">
        &lt;bean parent="TextControlDefinition" p:size="2"/>
    &lt;/property>
    &lt;property name="summary" value="Postal Country Code"/>
    &lt;property name="description" value="The code uniquely identify a country."/>
&lt;/bean>
</programlisting>
                <para>This type of definition (defining the attribute definition once and reusing
                    the bean as a parent bean) can be used inside common files as well. Rice has an
                    AttributeReferenceDummy.xml business object data dictionary file as well as a
                    java object AttributeReferenceDummy.java file. This file’s sole purpose is to
                    place commonly defined attributes such as <emphasis role="bold"
                        >versionNumber</emphasis> (which is common across all business objects) in a
                    central location so that other business object attribute definitions can use
                    them as parent beans. Here is how the Campus business object uses the version
                    number attribute:</para>
                <programlisting>&lt;bean id="Campus-versionNumber-parentBean" abstract="true" parent="AttributeReferenceDummy-versionNumber"></programlisting>
                <para>All business object data dictionary files need to have the version number
                    field bean defined. This will verify that the UI will have the version number as
                    a hidden field.</para>
            </sect3>
            <sect3>
                <title>Business Object Data Dictionary Lookup Definition</title>
                <sect4>
                    <title>Lookup Fields</title>
                    <para>A lookup definition contains a property called lookupFields which is made
                        up of a list of FieldDefinitions. These specify the fields that will be
                        displayed on a lookup form for that business object. A typical lookupField
                        (shown here with the parent property for context) in the Spring
                        configuration for a Business Object will look like this: </para>
                    <programlisting>&lt;property name="lookupFields">
    &lt;list>
        ...
        &lt;bean parent="FieldDefinition" p:attributeName="campusCode"/>
        ...
    &lt;/list>
&lt;/property>
</programlisting>
                </sect4>
                <sect4>
                    <title>Lookup default values</title>
                    <para>You can set a global default for that lookup field using the defaultValue
                    property: </para>
                    <programlisting>&lt;bean parent="FieldDefinition" p:attributeName="campusCode" p:defaultValue="BL"/></programlisting>
                    <para>The effect of this is that every time the lookup for this Business Object
                        is rendered, the campusCode text input will have "BL" in it. </para>
                </sect4>
                <sect4>
                    <title>Quickfinders</title>
                    <para>A quickfinder is a button that is rendered next to a lookup field which
                        takes you to a lookup for a related Business Object which that field
                        references, which in the case of this example would be to a Campus Business
                        Object.</para>
                </sect4>
                <sect4>
                    <title>Quickfinder parameters</title>
                    <para>If a lookup field will have a quickfinder button on it due to a BO
                        relationship, you may wish to set default values for certain fields on that
                        related Business Object's lookup form, but only when the quickfinder from
                        this Business Object is used. </para>
                    <programlisting>&lt;bean parent="FieldDefinition" p:attributeName="campusCode" p:quickfinderParameterString="campusTypeCode=P,active=Y" /> 
</programlisting>
                    <para>The effect of this is different than the defaultValue in that the defaults
                        apply not to the lookup form Business Object that we are currently defining
                        lookupFields for, rather for specific fields in the related Business Object
                        that this lookupField (campusCode) references – but only when accessed
                        through this quickfinder on our parent BO's lookup form. </para>
                </sect4>
                <sect4>
                    <title>Example LookupDefinition with defaultValue and
                        quickfinderParameterString</title>
                    <para>This is perhaps better explained through a simple example with two BOs
                        that have a relationship, Building and Campus. Here is the LookupDefinition
                        for Building: </para>
                    <programlisting>&lt;bean id="Building-lookupDefinition-parentBean" abstract="true" parent="LookupDefinition" p:title="Building Lookup">
    ...
    &lt;property name="lookupFields">
        &lt;list>
            ...
            &lt;bean parent="FieldDefinition" p:attributeName="campusCode" p:quickfinderParameterString="campusTypeCode=P,active=Y" defaultValue="BL"/>
            ...
        &lt;/list>
    &lt;/property>
    ...
&lt;/bean></programlisting>
                    <para>The defaultValue is a global default, so every time you view the Building
                        BO's lookup it will have "BL" in the campusCode input. </para>
                    <para>The quickfinderParameterString is much more localized, so if you go
                        directly to the Campus BO's lookup it will have no effect. However, if you
                        go to the Building BO's lookup and click the quickfinder button next to its
                        campusCode input, the Campus BO's lookup it will have a default of "P" in
                        the campusTypeCode input, and a default of "Y" in the active input. </para>
                    <para>There is a related property for FieldDefinition that also applies to
                        lookups, the quickfinderParameterStringBuilderClass. This lets you specify a
                        class (which must implement the
                        org.kuali.rice.kns.lookup.valueFinder.ValueFinder interface) which will
                        dynamically construct a quickfinderParameterString each time a lookup is
                        rendered. This might be useful if e.g. you wanted to populate a field in the
                        related BO's lookup with the current date and time when it is accessed
                        through the quickfinder. </para>
                    <para>It is not valid to have both the quickfinderParameterString and the
                        quickfinderParameterStringBuilderClass defined on a single FieldDefinition,
                        and you will get an exception during Data Dictionary validation if you do
                        so. </para>
                </sect4>
                <sect4>
                    <title>Totals</title>
                    <para>Support exists in the lookup framework for totaling the lookup results. If
                        the ‘total’ property is set to true on one or more FieldDefinition within
                        the resultFields, the total line will be rendered and totals displayed for
                        each field indicated.</para>
                    <para><emphasis role="italic">Example:</emphasis></para>
                    <programlisting>&lt;property name="resultFields" >
    &lt;list>
        &lt;bean parent="FieldDefinition" p:attributeName="kemid" />
        &lt;bean parent="FieldDefinition"
 p:attributeName="kemidObj.shortTitle" />
        &lt;bean parent="FieldDefinition"
 p:attributeName="kemidObj.purposeCode" />
        &lt;bean parent="FieldDefinition"
 p:attributeName="availableIncomeCash" p:total="true" />
        &lt;bean parent="FieldDefinition"
 p:attributeName="availablePrincipalCash" p:total="true" />
        &lt;bean parent="FieldDefinition"
 p:attributeName="availableTotalCash" p:total="true" />
        &lt;bean parent="FieldDefinition"
 p:attributeName="kemidObj.close" />
    &lt;/list>
&lt;/property> 
</programlisting>
                    <para>An additional row will be added to the lookup result table with the totals
                        for each of these columns indicated. The label for the total row will
                        display in the first lookup column. By default this label is set to 'TOTALS'
                        and can be changed in KR-ApplicationResources.properties.</para>
                    <para><inlinemediaobject>
                            <imageobject>
                                <imagedata fileref="../images/totals.png"/>
                            </imageobject>
                        </inlinemediaobject></para>
                    <para>The total line will not be displayed for the column if the column values
                        are masked.</para>
                    <para>One limitation of the totaling functionality is it will not work with a
                        column that has inquiry URLs. This is because of the need to have a numeric
                        value to sum on and for fields with an inquiry the URL is put into the tag
                        value along with the actual cell value.</para>
                </sect4>
                <sect4>
                    <title>Disabling Search Buttons</title>
                    <para>In certain cases the search and clear buttons for a lookup are not needed.
                        Therefore these buttons can be disabled in one of two ways.</para>
                    <para>The first way is to disable the buttons through the data dictionary. This
                        is done by setting the property disableSearchButtons to true in the data
                        dictionary lookup definition:</para>
                    <programlisting>&lt;bean id="CustomerProfile-lookupDefinition" parent="CustomerProfile-lookupDefinition-parentBean"/>
&lt;bean id="CustomerProfile-lookupDefinition-parentBean" abstract="true" parent="LookupDefinition">
&lt;property name="title" value="Customer Profile Lookup"/>
&lt;property name="disableSearchButtons" value="true"/>
</programlisting>
                    <para>The second way is to disable the buttons for a particular instance of a
                        lookup by passing disableSearchButtons=true as a request URL
                        parameter:</para>
                    <programlisting>http://localhost:8080/kr-dev/lookup.do?disableSearchButtons=true&amp;more parms ... </programlisting>
                    <para>Note in this scenario other calls to the lookup without this parameter
                        will have the search buttons rendered.</para>
                </sect4>
            </sect3>
            <sect3>
                <title>Merging Custom Attributes into Lookup Definitions</title>
                <para>There are instances when an institution would choose to add custom attributes
                    to existing data dictionary definitions in a client application (such as KFS or
                    KC). The lookup and result fields representing these custom attributes can be
                    arranged as desired using the <emphasis role="bold"
                        >DataDictionaryBeanOverride</emphasis>. In the example below, we wish to add
                    a custom attribute named <emphasis role="bold">Campus Code</emphasis> to KFS’s
                    existing Account bean. </para>
                <programlisting>&lt;beans>
    ...
    &lt;bean id=”Account” parent=”Account-parentBean">
    &lt;property name="attributes">
        &lt;list merge=”true”>
            &lt;!-- list goes here -->
            &lt;bean id=”Account.campusCode” parent=”Account-CampusCode” p:name=”Account.campusCode” />
            ...
        &lt;/list>
    &lt;/property>
    &lt;/bean>
    ...
&lt;/beans></programlisting>
                <para>Once the custom attribute is defined, we create a bean that takes KFS’s
                        <emphasis role="bold">Account-lookupDefinition</emphasis> bean and modifies
                    it such that <emphasis role="bold">Campus Code</emphasis> is displayed right
                    after the <emphasis role="bold">Sub-Fund Group Code</emphasis> attribute in the
                    Account lookup screen and search results.</para>
                <programlisting>&lt;beans>
    ...
    &lt;bean id=”Account-lookupDefinition-override” parent=”DataDictionaryBeanOverride">
        &lt;property name="beanName" value=”Account-lookupDefinition” />
        &lt;property name=”fieldOverrides”>
            &lt;list>
                &lt;!—- Place Campus Code after Account Sub-Fund Group Code in the lookup -->
                &lt;bean parent=”FieldOverrideForListElementInsert”>
                    &lt;property name=”propertyName” value=”lookupFields” />
                    &lt;property name=”propertyNameForElementCompare” value=”attributeName” />
                    &lt;property name=”element”>
                        &lt;bean parent=”FieldDefinition” p:attributeName=”subFundGroupCode” />
                    &lt;/property>
                    &lt;property name=”insertAfter”>
                        &lt;list>
                            &lt;bean parent=”FieldDefinition” p:attributeName=”Account.campusCode” />
                        &lt;/list>
                    &lt;/property>
                &lt;/bean>
                &lt;!—- Place Campus Code after Account Sub-Fund Group Code in the search results -->
                &lt;bean parent=”FieldOverrideForListElementInsert”>
                    &lt;property name=”propertyName” value=”resultFields” />
                    &lt;property name=”propertyNameForElementCompare” value=”attributeName” />
                    &lt;property name=”element”>
                        &lt;bean parent=”FieldDefinition” p:attributeName=”subFundGroupCode” />
                    &lt;/property>
                    &lt;property name=”insertAfter”>
                        &lt;list>
                            &lt;bean parent=”FieldDefinition” p:attributeName=”Account.campusCode” />
                        &lt;/list>
                    &lt;/property>
                &lt;/bean>
            &lt;/list>
        &lt;/property>
    &lt;/bean>
    ...
&lt;/beans></programlisting>
            </sect3>
<!-- TO DO             
            <sect3>
                <title>Business Object Data Dictionary Inquiry Definition</title>
            </sect3>
-->
            <sect3>
                <title>Merging Custom Attributes into Inquiry Definitions</title>
                <para>There are instances when an institution would choose to add custom attributes
                    to existing data dictionary definitions in a client application (such as KFS or
                    KC). The fields representing these custom attributes can be arranged on the
                    inquiry screen as desired using the <emphasis role="bold"
                        >DataDictionaryBeanOverride</emphasis>. In the example below, we wish to add
                    a custom attribute named <emphasis role="bold">Campus Code</emphasis> to KFS’s
                    existing Account bean. </para>
                <programlisting>&lt;beans>
    ...
    &lt;bean id=”Account” parent=”Account-parentBean">
        &lt;property name="attributes">
            &lt;list merge=”true”>
                &lt;!-- list goes here -->
                &lt;bean id=”Account.campusCode” parent=”Account-CampusCode” p:name=”Account.campusCode” />
                    ...
            &lt;/list>
        &lt;/property>
    &lt;/bean>
    ...
&lt;/beans>
</programlisting>
                <para>Once the custom attribute is defined, we create a bean that takes KFS’s
                        <emphasis role="bold">Account-inquiryDefinition</emphasis> bean and modifies
                    it such that <emphasis role="bold">Campus Code</emphasis> is displayed right
                    after the <emphasis role="bold">Sub-Fund Group Code</emphasis> attribute in the
                    Account inquiry screen.</para>
                <programlisting>&lt;beans>
    ...
    &lt;bean id=”Account-inquiryDefinition-override” parent=”DataDictionaryBeanOverride">
        &lt;property name="beanName" value=”Account-inquiryDefinition” />
        &lt;property name=”fieldOverrides”>
            &lt;list>
                &lt;!—- Place Campus Code after Account Sub-Fund Group Code in the Account Details section (inquirySections[0]) -->
                &lt;bean parent=”FieldOverrideForListElementInsert”>
                    &lt;property name=”propertyName” value=”inquirySections[0].inquiryFields” />
                    &lt;property name=”propertyNameForElementCompare” value=”attributeName” />
                    &lt;property name=”element”>
                        &lt;bean parent=”FieldDefinition” p:attributeName=”subFundGroupCode” />
                    &lt;/property>
                    &lt;property name=”insertAfter”>
                        &lt;list>
                            &lt;bean parent=”FieldDefinition” p:attributeName=”Account.campusCode” />
                        &lt;/list>
                    &lt;/property>
                &lt;/bean>
            &lt;/list>
        &lt;/property>
    &lt;/bean>
    ...

&lt;/beans>
</programlisting>
            </sect3>
        </sect2>
        <sect2>
            <title>Document Data Dictionary Overview</title>
            <para>There are two different document types in KNS: <orderedlist>
                    <listitem>
                        <para><emphasis role="bold">Maintenance Documents</emphasis></para>
                        <para>Maintenance Documents create, update, copy, or inactivate either a
                            single business object or a collection of business objects. They are
                            used to perform standard maintenance on data. </para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">Transactional Documents</emphasis></para>
                        <para>Transactional Documents represent an action that will occur in the
                            system. They are treated as one-shot documents and need not be edited
                            and modified several times because of their approach in performing an
                            action. </para>
                    </listitem>
                </orderedlist></para>
            <sect3>
                <para>
                    <table frame="none">
                        <title>Comparison of Maintenance and Transactional Documents</title>
                        <tgroup cols="3">
                            <colspec colname="c1" colnum="1" colwidth="1.0*"/>
                            <colspec colname="c2" colnum="2" colwidth="1.0*"/>
                            <colspec colname="c3" colnum="3" colwidth="1.0*"/>
                            <thead>
                                <row>
                                    <entry/>
                                    <entry>Transactional Documents </entry>
                                    <entry>Maintenance Documents </entry>
                                </row>
                            </thead>
                            <tbody>
                                <row>
                                    <entry>SQL Table(s) </entry>
                                    <entry>yes</entry>
                                    <entry>yes</entry>
                                </row>
                                <row>
                                    <entry>OJB Mapping(s) - repository.xml </entry>
                                    <entry>yes</entry>
                                    <entry>yes</entry>
                                </row>
                                <row>
                                    <entry>Business Object(s) </entry>
                                    <entry>yes</entry>
                                    <entry>yes</entry>
                                </row>
                                <row>
                                    <entry>Data Dictionary File(s)(XML) </entry>
                                    <entry>Transactional Document DD File </entry>
                                    <entry>
                                        <para>Maintenance Document DD File</para>
                                        <para>Business Object DD File (discussed earlier)</para>
                                   </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </table>
                </para>
                <para>Each type of dictionary defines properties such as authorizations, rules and
                    workflow document types. </para>
                <para>The following examples all follow the same structure with respect to the use
                    of ‘abstract’ parent beans for Data Dictionary beans. A detailed description of
                    their use and why Kuali uses this type of implementation can be found in the
                    beginning of the ‘Business Object Data Dictionary’ section.</para>
            </sect3>
        </sect2>
        <sect2>
            <title>Maintenance Document Data Dictionary Overview</title>
            <para>In general, documents have metadata associated with them, and the metadata for
                maintenance documents exists in the document's data dictionary configuration. The
                data dictionary can do practically everything for a maintenance document: it
                declares the user interface for the form, ties rules and document authorizers to the
                document as well as the document's workflow document type.</para>
            <para>Below is an example of a Maintenance Document Data Dictionary file from the KNS
                module itself. It is for the Parameter object used within the KNS. The path (or
                package) <emphasis role="bold"
                    >org/kuali/rice/kns/document/datadictionary/</emphasis> is where the <emphasis
                    role="bold">ParameterMaintenanceDocument</emphasis> can be found in Rice if
                    below is difficult to view.</para>
            <programlisting>&lt;bean id="ParameterMaintenanceDocument" parent="ParameterMaintenanceDocument-parentBean"/>

&lt;bean id="ParameterMaintenanceDocument-parentBean" abstract="true" parent="MaintenanceDocumentEntry">
    &lt;property name="businessObjectClass" value="org.kuali.rice.kns.bo.Parameter"/>
    &lt;property name="maintainableClass" value="org.kuali.rice.kns.document.ParameterMaintainable"/>
    &lt;property name="maintainableSections">
        &lt;list>
            &lt;ref bean="ParameterMaintenanceDocument-EditParameter"/>
        &lt;/list>
    &lt;/property>
    &lt;property name="defaultExistenceChecks">
        &lt;list>
            &lt;bean parent="ReferenceDefinition" p:attributeName="parameterNamespace" p:attributeToHighlightOnFail="parameterNamespaceCode"/>
            &lt;bean parent="ReferenceDefinition" p:attributeName="parameterType" p:attributeToHighlightOnFail="parameterTypeCode"/>
        &lt;/list>
    &lt;/property>
    &lt;property name="lockingKeys">
        &lt;list>
            &lt;value>parameterNamespaceCode&lt;/value>
            &lt;value>parameterDetailTypeCode&lt;/value>
            &lt;value>parameterApplicationNamespaceCode&lt;/value>
            &lt;value>parameterName&lt;/value>
        &lt;/list>
    &lt;/property>

    &lt;property name="documentTypeName" value="ParameterMaintenanceDocument"/>
    &lt;property name="businessRulesClass" value="org.kuali.rice.kns.rules.ParameterRule"/>
    &lt;property name="documentAuthorizerClass" value="org.kuali.rice.kns.document.authorization.MaintenanceDocumentAuthorizerBase"/>
    &lt;property name="workflowProperties">
        &lt;ref bean="ParameterMaintenanceDocument-workflowProperties"/>
    &lt;/property>
&lt;/bean>



&lt;!-- Maintenance Section Definitions -->
&lt;bean id="ParameterMaintenanceDocument-EditParameter" parent="ParameterMaintenanceDocument-EditParameter-parentBean"/>

&lt;bean id="ParameterMaintenanceDocument-EditParameter-parentBean" abstract="true" parent="MaintainableSectionDefinition">
    &lt;property name="maintainableItems">
        &lt;list>
            &lt;bean parent="MaintainableFieldDefinition" p:required="true" p:name="parameterNamespaceCode"/>
            &lt;bean parent="MaintainableFieldDefinition" p:required="true" p:name="parameterDetailTypeCode"/>
            &lt;bean parent="MaintainableFieldDefinition" p:required="true" p:name="parameterApplicationNamespaceCode" p:defaultValue="KUALI"/>
            &lt;bean parent="MaintainableFieldDefinition" p:required="true" p:name="parameterName"/>
            &lt;bean parent="MaintainableFieldDefinition" p:required="false" p:name="parameterValue"/>
            &lt;bean parent="MaintainableFieldDefinition" p:required="true" p:name="parameterDescription"/>
            &lt;bean parent="MaintainableFieldDefinition" p:required="true" p:name="parameterTypeCode"/>
            &lt;bean parent="MaintainableFieldDefinition" p:required="true" p:name="parameterConstraintCode"/>
        &lt;/list>
    &lt;/property>
    &lt;property name="id" value="Edit Parameter"/>
    &lt;property name="title" value="Edit Parameter"/>
&lt;/bean>



&lt;!-- Exported Workflow Properties -->

&lt;bean id="ParameterMaintenanceDocument-workflowProperties" parent="ParameterMaintenanceDocument-workflowProperties-parentBean"/>

&lt;bean id="ParameterMaintenanceDocument-workflowProperties-parentBean" abstract="true" parent="WorkflowProperties">
    &lt;property name="workflowPropertyGroups">
        &lt;list>
            &lt;bean parent="WorkflowPropertyGroup">
                &lt;property name="workflowProperties">
                    &lt;list>
                        &lt;bean parent="WorkflowProperty" p:path="oldMaintainableObject.businessObject"/>
                        &lt;bean parent="WorkflowProperty" p:path="newMaintainableObject.businessObject"/>
                    &lt;/list>
                &lt;/property>
            &lt;/bean>
        &lt;/list>
    &lt;/property>
&lt;/bean></programlisting>
            <sect3>
                <title>Basic Setup</title>
                <para>The first bean defined for the ParameterMaintenanceDocument data dictionary
                    file is the main definition bean “ParameterMaintenanceDocument-parentBean”. This
                    bean uses the parent bean “MaintenanceDocumentEntry”. This is how this
                    particular business object is defined specifically as a Maintenance Document.
                    Inside the “ParameterMaintenanceDocument-parentBean” bean we see several
                    properties being set:</para>
                <programlisting>&lt;property name="businessObjectClass" value="org.kuali.rice.kns.bo.Parameter"/>
&lt;property name="maintainableClass" value="org.kuali.rice.kns.document.ParameterMaintainable"/></programlisting>
                <para>First and foremost the Maintenance Document Data Dictionary file should define
                    the business object that will be maintained by this particular document using
                    the <emphasis role="bold">businessObjectClass</emphasis> property. In this
                    example the fully qualified business object class is <emphasis role="bold"
                        >kuali.rice.kns.bo.Parameter</emphasis>. </para>
                <para>The Maintenance Documents also need a maintainable class. This is defined
                    using the <emphasis role="bold">maintainableClass</emphasis> property and in our
                        <emphasis role="bold">Parameter</emphasis> business object example the
                    custom class being used is <emphasis role="bold"
                        >org.kuali.rice.kns.document.ParameterMaintainable</emphasis>. If there are
                    no customizations needed for the business object then the default class
                        <emphasis role="bold"
                        >org.kuali.rice.kns.maintenance.KualiMaintainableImpl</emphasis> should be
                    used. More will be discussed about custom maintainable classes later in this
                    document.</para>
            </sect3>
            <sect3>
                <title>Existence Checking</title>
                <para>The next maintenance document specific tag is <emphasis role="bold"
                        >defaultExistenceChecks</emphasis>. Certain document validations are so
                    omnipresent that they can simply be declared - typically validations that
                    certain fields of a document are required. Here are the default existence checks
                    for the <emphasis role="bold">ParameterMaintenanceDocument</emphasis>:</para>
                <programlisting>&lt;property name="defaultExistenceChecks">
    &lt;list>
        &lt;bean parent="ReferenceDefinition" p:attributeName="parameterNamespace" p:attributeToHighlightOnFail="parameterNamespaceCode"/>
    &lt;/list>
&lt;/property></programlisting>
                <para>Here we have just one default existence check. Default existence checks verify
                    that the associated business object for the document actually exist. For
                    instance, in the Parameter maintenance document, if a user enters a parameter
                    namespace value that does not exist, the default existence check will display an
                    error message next to the <emphasis role="bold"
                        >parameterNamespaceCode</emphasis> attribute field after the user attempts
                    to save or submit.</para>
                <para>The <emphasis role="bold">defaultExistenceCheck</emphasis> tag has a few
                    different ways it can operate. All involve setting a list of beans that use the
                    “ReferenceDefinition” parent bean. This bean is defined in Rice and can be used
                    by any Maintenance Document Data Dictionary file. The properties that may be set
                    for the “ReferenceDefinition” beans vary but the example shows the most common.
                    The <emphasis role="bold">attributeName</emphasis> property is set to the KNS
                    attribute name of the business object which must exist for the check to pass. In
                    this case the <emphasis role="bold">Namespace</emphasis> object in KNS has a
                        <emphasis role="bold">namespaceCode</emphasis> attribute. Likewise the
                        <emphasis role="bold">attributeToHighlightOnFail</emphasis> refers to the
                    attribute in the <emphasis role="bold">Parameter</emphasis> business object that
                    is used to link to the reference business object. This is the field which will
                    be highlighted on the user interface for the error to display. Of course, for
                    this to work correctly, the foreign keys to the fields must be specified as
                    required. That will come into play in section below about specifying the
                    UI.</para>
            </sect3>
            <sect3>
                <title>Locking keys</title>
                <para>Since maintenance documents edit one or more business objects, there is the
                    potential for race conditions. For example, if two business objects were created
                    with the same primary key field and they were both sent into routing at the same
                    time, the first document that is approved to ‘Final’ status in Workflow could
                    potentially be overwritten in the database by the second document when it goes
                    to ‘Final’ status. The KNS attempts to prevent these situations from arising by
                    creating a pessimistic lock on each business object going through workflow as
                    part of a maintenance document. In most cases, it uses the <emphasis role="bold"
                        >lockingKeys</emphasis> tag of the data dictionary for the maintenance
                    document to create that locking representation. Here's the locking
                    representation configuration for the <emphasis role="bold"
                        >ParameterMaintenanceDocument</emphasis>:</para>
                <programlisting>&lt;property name="lockingKeys">
    &lt;list>
        &lt;value>parameterNamespaceCode&lt;/value>
        &lt;value>parameterDetailTypeCode&lt;/value>
        &lt;value>parameterApplicationNamespaceCode&lt;/value>
        &lt;value>parameterName&lt;/value>
    &lt;/list>
&lt;/property></programlisting>
                <para>Not surprisingly, the attributes listed in the example are also the primary
                    keys for the <emphasis role="bold">Parameter</emphasis> business object. The
                    locking keys above simply mean that once a certain Parameter is put into
                    Workflow routing with a certain set of the fields above, another document with
                    the same exact values for all the attributes above will be prevented from being
                    put into Workflow. The fields used in a locking key can be anything, as long as
                    it marks the business object uniquely. It makes sense, then, that most locking
                    keys are simply the primary keys for the business object.</para>
            </sect3>
            <sect3>
                <title>Defining the UI</title>
                <para>Finally, the largest part of the maintenance document data dictionary: the
                    definition of the UI through the <emphasis role="bold"
                        >maintenanceSections</emphasis> property. The UI of a maintenance document
                    is made up of one or more maintainable sections. Each section is named, and each
                    section creates a new tab as its visual representation on the web form. Here is
                    the section list property being set on the
                    “ParameterMaintenanceDocument-parentBean” bean (only one section in this
                    document):</para>
                <programlisting>&lt;property name="maintainableSections">
    &lt;list>
        &lt;ref bean="ParameterMaintenanceDocument-EditParameter"/>
    &lt;/list>
&lt;/property></programlisting>
                <para>The list of beans is defined in the main Maintenance Document Entry bean while
                    each ‘Section Definition’ bean is defined below in the file. Here is the
                        <emphasis role="bold">ParameterMaintenanceDocument</emphasis> example of the
                    “ParameterMaintenanceDocument-EditParameter” bean definition:</para>
                <programlisting>&lt;bean id="ParameterMaintenanceDocument-EditParameter-parentBean" abstract="true" parent="MaintainableSectionDefinition">
    &lt;property name="maintainableItems">
        &lt;list>
            &lt;bean parent="MaintainableFieldDefinition" p:required="true" p:name="parameterNamespaceCode"/>
            &lt;bean parent="MaintainableFieldDefinition" p:required="true" p:name="parameterDetailTypeCode"/>
            &lt;bean parent="MaintainableFieldDefinition" p:required="true" p:name="parameterApplicationNamespaceCode" p:defaultValue="KUALI"/>
            &lt;bean parent="MaintainableFieldDefinition" p:required="true" p:name="parameterName"/>
            &lt;bean parent="MaintainableFieldDefinition" p:required="false" p:name="parameterValue"/>
            &lt;bean parent="MaintainableFieldDefinition" p:required="true" p:name="parameterDescription"/>
            &lt;bean parent="MaintainableFieldDefinition" p:required="true" p:name="parameterTypeCode"/>
            &lt;bean parent="MaintainableFieldDefinition" p:required="true" p:name="parameterConstraintCode"/>
        &lt;/list>
    &lt;/property>
    &lt;property name="id" value="Edit Parameter"/>
    &lt;property name="title" value="Edit Parameter"/>
&lt;/bean></programlisting>
                <para>Each maintainable section is defined by using the parent bean
                    “MaintainableSectionDefinition”. These beans, in turn, are made up of several
                    different properties including an <emphasis role="bold">id</emphasis>, <emphasis
                        role="bold">title</emphasis>, and <emphasis role="bold"
                        >maintainableItems</emphasis>. The <emphasis role="bold"
                        >maintainableItems</emphasis> property is a list of maintainable fields.
                    Each maintainable field bean uses the “MaintainableFieldDefinition” bean as its
                    parent bean and lists the attribute that should be shown. That attribute itself
                    has typically been defined in the data dictionary configuration for the business
                    object (see Business Object Data Dictionary Definition below). There is also a
                        <emphasis role="bold">required</emphasis> property which can be set to force
                    extra validation, though all validations described in the attributes of the
                    business object will also be checked.</para>
                <para>While attributes default to using the definition set up in the data dictionary
                    for a given field, there are a couple of behavior modifications that can be
                    made. One of which appears above in the <emphasis role="bold"
                        >required</emphasis> property. This can override the default required
                    behavior as defined for the business object on the Business Object Data
                    Dictionary file. Below are demonstrations of how some of the various changes
                    that can be made could potentially be done for the <emphasis role="bold"
                        >ParameterMaintenanceDocument</emphasis> data dictionary file. For instance,
                    default values for any field can be set by using the <emphasis role="bold"
                        >defaultValue</emphasis> property, like so:</para>
                <programlisting>&lt;bean parent="MaintainableFieldDefinition">
    &lt;property name=”name” value="parameterApplicationNamespaceCode"/>
    &lt;property name=”required” value="true"/>
    &lt;property name=”defaultValue” value="KUALI"/>
&lt;/bean>
</programlisting>
                <para>The example above example sets the default value of the <emphasis role="bold"
                        >parameterApplicationNamespaceCode</emphasis> attribute to “KUALI”. </para>
                <para>Another property that can be used to set a field with a default value in the
                    maintenance document data dictionary maintainableField beans is the <emphasis
                        role="bold">defaultValueFinderClass</emphasis> property. This property
                    should be set to a class that implements the interface class <emphasis
                        role="bold">org.kuali.rice.kns.lookup.valueFinder.ValueFinder</emphasis>.
                    The interface has one method only: <emphasis role="bold">getValue()</emphasis>,
                    which returns a String which will be set into the form in the User Interface.
                    Here is an example (not from the <emphasis role="bold"
                        >ParameterMaintenanceDocument</emphasis> but from the <emphasis role="bold"
                        >IdentityManagementGenericPermissionMaintenanceDocument</emphasis>) on how
                    to use the <emphasis role="bold">defaultValueFinderClass</emphasis>
                    property:</para>
                <programlisting>&lt;bean parent="MaintainableFieldDefinition">
    &lt;property name=”name” value="permissionId"/>
    &lt;property name=”unconditionallyReadOnly” value="true"/>
    &lt;property name=”required” value="true"/>
    &lt;property name=”defaultValueFinderClass” value="org.kuali.rice.kim.lookup.valuefinder.NextPermissionIdValuesFinder"/>
&lt;/bean>
</programlisting>
                <para>The above example pulls the next available id from a class for one of the
                    Kuali Identity Management documents. This is a very custom behavior for KIM but
                    does highlight just one way the <emphasis role="bold"
                        >defaultValueFinderClass</emphasis> can be used.</para>
                <para>One other large customization that can be made is to modify the way the lookup
                    on a particular field operates. Lookups will be described in detail later in
                    this documentation. Below is a simulated example that does not exist in the Rice
                    code:</para>
                <programlisting>&lt;bean parent="MaintainableFieldDefinition">
    &lt;property name=”name” value="reconcilerGroup.groupName"/>
    &lt;property name=”required” value="true"/>
    &lt;property name=”overrideFieldConversions” value="groupId:cardGroupId,groupName:reconcilerGroup.groupName"/>
    &lt;property name=”overrideLookupClass” value="org.kuali.rice.kim.bo.impl.GroupImpl"/>
&lt;/bean></programlisting>
                <para>The <emphasis role="bold">overrideLookupClass</emphasis> property will set the
                    business object class of the lookup that should be used. This means in our
                    example above that the lookup for the field “reconcilerGroup.groupName” will use
                    the <emphasis role="bold">org.kuali.rice.kim.bo.impl.GroupImpl</emphasis> class
                    lookup. The <emphasis role="bold">overrideFieldConversions</emphasis> property
                    is used to translate data attributes from the <emphasis role="bold"
                        >overrideLookupClass</emphasis> to fields that match the current Business
                    Object class for which the maintenance document data dictionary file is for.
                    These are separated with the colon character and a comma is used to delineate
                    each field translation if more than one is to be listed. In the example above
                    the ‘groupId’ field (which exists on the <emphasis role="bold"
                        >org.kuali.rice.kim.bo.impl.GroupImpl</emphasis> class) will be set into the
                    ‘cardGroupId’ field (which should exist on the business object class of the
                    current maintainable data dictionary file). In some instances the <emphasis
                        role="bold">overrideFieldConversions</emphasis> may not be necessary if the
                    field names are the same on the lookup’s business object class and the data
                    dictionary’s business object class.</para>
            </sect3>
            <sect3>
                <title>Additional MaintainableFieldDefinition Properties</title>
                <para>For each MaintainableFieldDefinition bean defined in a maintenance document,
                    there are a few fields that can help adjust the User Interface for a KNS client.
                    Here is a sample example:</para>
                <programlisting>     ...
1    &lt;property name="maintainableItems">
2        &lt;list>
3            &lt;bean parent="MaintainableFieldDefinition" p:name="Code" p:required="true" />
4            &lt;bean parent="MaintainableFieldDefinition" p:name="ID" p:unconditionallyReadOnly="true" />
5            &lt;bean parent="MaintainableFieldDefinition" p:name="Name" p:readOnlyAfterAdd="true" />
6            &lt;bean parent="MaintainableFieldDefinition" p:name="Type" p:lookupReadOnly="true" />
7            &lt;bean parent="MaintainableFieldDefinition" p:name="linkedJob" p:noLookup="true" />
      ...</programlisting>
                <para>In the example above on line 4 the field with <emphasis role="bold"
                        >name</emphasis> value “ID” has a property named <emphasis role="bold"
                        >unconditionallyReadOnly</emphasis> that is set to “true”. This means the
                    field will be read only and uneditable in the User Interface at all times
                    regardless of document state. This could be helpful when setting a default value
                    that the user entering the document is not allowed to change.</para>
                <para>The property <emphasis role="bold">readOnlyAfterAdd</emphasis> set to “true”
                    on line 5 for the “Name” field means that once the maintenance document for this
                    business object has been successfully saved and routed through all appropriate
                    approvals, the “Name” field will be read only. This is useful in certain
                    instances when creating a new business object.</para>
                <para>The property <emphasis role="bold">lookupReadOnly</emphasis> in line 6 is used
                    to change the UI so that a lookup link will be presented for the field but the
                    value that is displayed when returning an object from the lookup is read only.
                    In the example above the “Type” variable will have a lookup (as defined by the
                    Business Object Data Dictionary file… see the Business Object Data Dictionary
                    section for more information) but the displayed value in the UI for “Type” will
                    be uneditable by user entry. It may still be changed by going to the lookup link
                    again.</para>
                <para>The noLookup property shown in line 7 for the “linkedJob” field is a way to
                    override the default functionality coming from the Business Object Data
                    Dictionary file. If that DD file has a Lookup control element but the lookup
                    need to be hidden on the Maintenance Document then this attribute allows for
                    that functionality.</para>
            </sect3>
            <sect3>
                <title>Collections</title>
                <para>Some maintenance documents include collections of business objects. Below is
                    an example from the RoutingRuleMaintenanceDocument data dictionary file from
                    Rice:</para>
                <programlisting>&lt;bean id="RoutingRuleMaintenanceDocument-PersonResponsibilities-parentBean" abstract="true" parent="MaintainableSectionDefinition">
    &lt;property name="id" value="PersonsMaintenance"/>
    &lt;property name="title" value="Persons"/>
    &lt;property name="maintainableItems">
        &lt;list>
            &lt;bean parent="MaintainableCollectionDefinition">
                &lt;property name="name" value="personResponsibilities"/>
                &lt;property name="businessObjectClass" value="org.kuali.rice.kew.rule.PersonRuleResponsibility"/>
                &lt;property name="summaryTitle" value="Person"/>
                &lt;property name="summaryFields">
                    &lt;list>
                        &lt;bean parent="MaintainableFieldDefinition" p:name="principalName"/>
                        &lt;bean parent="MaintainableFieldDefinition" p:name="actionRequestedCd"/>
                    &lt;/list>
                &lt;/property>
                &lt;property name="maintainableFields">
                    &lt;list>
                        &lt;bean parent="MaintainableFieldDefinition" p:name="principalName" p:required="true"/>
                        &lt;bean parent="MaintainableFieldDefinition" p:name="actionRequestedCd" p:required="true"/>
                        &lt;bean parent="MaintainableFieldDefinition" p:name="priority" p:required="true”/>
                    &lt;/list>
                &lt;/property>
                &lt;property name="duplicateIdentificationFields">
                    &lt;list>
                        &lt;bean parent="MaintainableFieldDefinition" p:name="principalName"/>
                        &lt;bean parent="MaintainableFieldDefinition" p:name="actionRequestedCd"/>
                    &lt;/list>
                &lt;/property>
            &lt;/bean>
        &lt;/list>
    &lt;/property>
&lt;/bean>
</programlisting>
                <para>To put a collection into a maintenance section, simply put an instance of a
                        <emphasis role="bold">MaintainableCollectionDefinition</emphasis> bean in
                    the list that is set into the <emphasis role="bold">maintainableItems</emphasis>
                    property of the maintenance section. </para>
                <para>The <emphasis role="bold">MaintainableCollectionDefinition</emphasis> bean
                    must have a <emphasis role="bold">name</emphasis> property. The <emphasis
                        role="bold">name</emphasis> property should match the attribute name of the
                    collection being maintained on the original business object. The <emphasis
                        role="bold">businessObjectClass</emphasis> property value specifies the
                    class of the items in the collection. </para>
                <para>The <emphasis role="bold">maintainableFields</emphasis> property inside the
                        <emphasis role="bold">MaintainableCollectionDefinition</emphasis> bean works
                    exactly like the previously described structure of the <emphasis role="bold"
                        >maintainableFields</emphasis> property inside the <emphasis role="bold"
                        >MaintainableSectionDefinition</emphasis> bean. The only difference is that
                    the name property of each <emphasis role="bold"
                        >MaintainableFieldDefinition</emphasis> refers to an attribute of the
                        <emphasis role="bold">businessObjectClass</emphasis> that is set on the
                        <emphasis role="bold">MaintainableCollectionDefinition</emphasis>
                    bean.</para>
                <para>The <emphasis role="bold">summaryTitle</emphasis> and <emphasis role="bold"
                        >summaryFields</emphasis> properties are used for display purposes once a
                    list element is added to the list on the UI screen. The specified data elements
                    will show when the full detail of the collection item is hidden using the
                    ‘hide/show’ button functionality of the KNS. Usually these fields are specific
                    to what uniquely defines the business objects contained within the
                    collection.</para>
                <para>The <emphasis role="bold">duplicateIdentificationFields</emphasis> property is
                    used to identify specifically the set of fields inside the collection element
                    business object that cannot be duplicated in the list. In this way they act as
                    mini-locks. They will prevent more than one list element with the same set of
                    fields. For instance, in the example above, if a list element already exists
                    with the <emphasis role="bold">actionRequestedCd</emphasis> ‘A’ and the
                        <emphasis role="bold">principalName</emphasis> ‘john’ then another list
                    element with those same values cannot be added.</para>
                <para>There are also a few more advanced type attributes that can be used. Take the
                    above example and the abbreviated alteration below.</para>
                <programlisting>     ...
1    &lt;property name="maintainableItems">
2        &lt;list>
3            &lt;bean parent="MaintainableCollectionDefinition" >
4                &lt;property name="name" value="personResponsibilities"/>
5                &lt;property name="includeAddLine" value="false"/>
6                &lt;property name="businessObjectClass" value="org.kuali.rice.kew.rule.PersonRuleResponsibility"/>
7                &lt;property name="maintainableFields">
8                    &lt;list>
9                        &lt;bean parent="MaintainableFieldDefinition" p:name="newCollectionRecord"/>
     ...</programlisting>
                <para>The property <emphasis role="bold">includeAddLine</emphasis> on line 5 above
                    is used to remove the UI element that allows the users to add their own elements
                    to the list. This is helpful in cases where the list of items may be statically
                    generated by code internal to the business object containing the
                    collection.</para>
                <para>On line 9 in the example above, the addition of the <emphasis role="bold"
                        >MaintainableFieldDefinition</emphasis> with the <emphasis role="bold"
                        >name</emphasis> property value of “newCollectionRecord” is used to tell the
                    maintenance framework that any records currently existing in the collection are
                    permanent - that is, there should not be delete buttons associated with them.
                    However, if the property <emphasis role="bold">includeAddLine</emphasis> is set
                    to “false” (or omitted) in the <emphasis role="bold"
                        >MaintainableCollectionDefinition</emphasis> bean above, new lines could be
                    added to the collection and each of the new lines could be deleted (though lines
                    that had been previously saved and routed appropriately into the collection
                    could not be deleted).</para>
            </sect3>
        </sect2>
        <sect2>
            <title>Alternate/Additional Display Properties</title>
            <para>Within the business object frameworks (lookup, inquiry, and maintenance document)
                an alternate or additional property can be specified to display when a field is
                read-only. These properties are configured through the data dictionary as
                follows:</para>
            <sect3>
                <title>alternateDisplayAttributeName</title>
                <para>This property specifies an attribute on the business object that should be
                    displayed instead of the field attribute when the view is read-only. The
                    property is available on the FieldDefinition for lookup result fields and
                    inquiries, and on the MaintainbleFieldDefinition for maintenance documents. In
                    the case of lookup result fields and inquiries this attribute will always be
                    displayed since the view is always read-only. For maintenance documents, the
                    field attribute will display when the document is editable, and the alternate
                    attribute will display when the document is read-only.</para>
                <programlisting>&lt;bean id="CustomerProfile-lookupDefinition" parent="CustomerProfile-lookupDefinition-parentBean"/>
&lt;bean id="CustomerProfile-lookupDefinition-parentBean" abstract="true" parent="LookupDefinition">
    &lt;property name="title" value="Customer Profile Lookup"/>

    &lt;property name="defaultSort">
        &lt;bean parent="SortDefinition">
            &lt;property name="attributeNames">
                &lt;list>
                    &lt;value>id&lt;/value>
                &lt;/list>
            &lt;/property>
        &lt;/bean>
    &lt;/property>
    &lt;property name="lookupFields">
        &lt;list>
            &lt;bean parent="FieldDefinition" p:attributeName="id"/>
            &lt;bean parent="FieldDefinition" p:attributeName="chartCode"/>
            &lt;bean parent="FieldDefinition" p:attributeName="unitCode"/>
            &lt;bean parent="FieldDefinition" p:attributeName="subUnitCode"/>
            &lt;bean parent="FieldDefinition" p:attributeName="active"/>
        &lt;/list>
    &lt;/property>
    &lt;property name="resultFields">
        &lt;list>
            &lt;bean parent="FieldDefinition" p:attributeName="id" p:alternateDisplayAttributeName="customerName"/>
            &lt;bean parent="FieldDefinition" p:attributeName="customerShortName"/>
            &lt;bean parent="FieldDefinition" p:attributeName="customerDescription"/>
            &lt;bean parent="FieldDefinition" p:attributeName="contactFullName"/>
            &lt;bean parent="FieldDefinition" p:attributeNa ="processingEmailAddr"/>
            &lt;bean parent="FieldDefinition" p:attributeName="defaultPhysicalCampusProcessingCode"/>
            &lt;bean parent="FieldDefinition" p:attributeName="active"/>
            &lt;bean parent="FieldDefinition" p:attributeName="defaultChartCode"/>
        &lt;/list>
    &lt;/property>
&lt;/bean>
</programlisting>
                <para>In the example above, for the result field 'id' we have specified an
                    alternateDisplayAttibuteName equal to "customerName". When the results are
                    rendered the value of customerName property will be displayed and not the value
                    of the id property. This behavior is the same within an
                    InquiryDefinition.</para>
                <para>If specified on a MaintainableFieldDefinition, again the value for the
                    alternateDisplayAttibuteName attribute will be displayed; however any
                    quickfinder or lookup URL will be built using the field property as usual. If
                    the field is editable or hidden, the value of the field property will be
                    used.</para>
            </sect3>
            <sect3>
                <title>additionalDisplayAttributeName</title>
                <para>This property behaves much like the alternateDisplayAttibuteName, the only
                    difference being the value of the additionalDisplayAttributeName attribute will
                    be appended to the value of the field attribute, using '*-*' as a
                    delimiter.</para>
                <para>Neither the alternateDisplayAttibuteName nor additionalDisplayAttributeName
                    need to have an AttributeDefinition defined, however they must have an
                    accessible getter in the business object.</para>
            </sect3>
            <sect3>
                <title>Automatic Translation of KualiCode fields</title>
                <para>If enabled, fields that have references to a KualiCode class will be found and
                    the corresponding KualiCode name field will be set as the
                    additionalDisplayAttributeName. The object property holding the reference must
                    also prefix the field name. For example, a field name of 'defaultChartCode' and
                    reference name of 'defaultChart' would match, again assuming the type of
                    'defaultChart' implements KualiCode.</para>
                <para>This automatic translation of code fields is turned on by default in the
                    Inquiry framework, but turned off by default in lookups and maintenance
                    documents. It can be configured for each MaintenanceDocumentEntry,
                    LookupDefinition, or InquiryDefinition with the property
                    'translateCodes'.</para>
                <para>For example, in the MaintenanceDocumentEntry:</para>
                <programlisting>&lt;bean id="CustomerProfileMaintenanceDocument-parentBean" abstract="true" parent="MaintenanceDocumentEntry">
    &lt;property name="businessObjectClass" value="org.kuali.kfs.pdp.businessobject.CustomerProfile"/>
    &lt;property name="maintainableClass" value="org.kuali.kfs.pdp.document.datadictionary.CustomerProfileMaintenanceDocumentMaintainableImpl"/>
    &lt;property name="maintainableSections">
        &lt;list>
            &lt;ref bean="CustomerProfileMaintenanceDocument-EditCustomerProfileSection1"/>
            &lt;ref bean="CustomerProfileMaintenanceDocument-EditCustomerProfileSection2"/>
            &lt;ref bean="CustomerProfileMaintenanceDocument-EditCustomerProfileSection3"/>
            &lt;ref bean="CustomerProfileMaintenanceDocument-EditCustomerBank"/>
        &lt;/list>
    &lt;/property>
    &lt;property name="defaultExistenceChecks">
        &lt;list>
            &lt;bean parent="ReferenceDefinition" p:attributeName="defaultChart" p:attributeToHighlightOnFail="defaultChartCode"/>
            &lt;bean parent="ReferenceDefinition" p:attributeName="defaultAccount" p:attributeToHighlightOnFail="defaultAccountNumber"/>
            &lt;bean parent="ReferenceDefinition" p:attributeName="defaultObject" p:attributeToHighlightOnFail="defaultObjectCode"/>
            &lt;bean parent="ReferenceDefinition" p:attributeName="defaultProcessingCampus" p:attributeToHighlightOnFail="defaultPhysicalCampusProcessingCode"/>
            &lt;bean parent="ReferenceDefinition" p:attributeName="state" p:attributeToHighlightOnFail="stateCode"/>
            &lt;bean parent="ReferenceDefinition" p:attributeName="postalCode" p:attributeToHighlightOnFail="zipCode"/>
            &lt;bean parent="ReferenceDefinition" p:attributeName="country" p:attributeToHighlightOnFail="countryCode"/>
            &lt;bean parent="ReferenceDefinition" p:attributeName="transactionType" p:attributeToHighlightOnFail="achTransactionType"/>
            &lt;bean parent="ReferenceDefinition" p:collection="customerBanks" p:attributeName="disbursementType" p:attributeToHighlightOnFail="disbursementTypeCode"/>
            &lt;bean parent="ReferenceDefinition" p:collection="customerBanks" p:attributeName="bank" p:attributeToHighlightOnFail="bankCode"/>
        &lt;/list>
    &lt;/property>
    &lt;property name="lockingKeys">
        &lt;list>
            &lt;value>chartCode&lt;/value>
            &lt;value>unitCode&lt;/value>
            &lt;value>subUnitCode&lt;/value>
        &lt;/list>
    &lt;/property>
    <emphasis role="bold">&lt;property name="translateCodes" value="true"/></emphasis>
</programlisting>
                <para>If alternateDisplayAttributeName is specified for a field then it will
                    override the code translation (if applicable).</para>
                <para>Note the Summarizable interface and SummarizableFormatter class were removed
                    as part of this work. If an application class implemented Summarizable it should
                    be changed to implement the KualiCode interface.</para>
            </sect3>
        </sect2>
        <sect2>
            <title>Dynamic read-only, hidden, and required Field states</title>
            <para>Within the KNS lookup and maintenance frameworks there is support for dynamically
                altering the read-only, hidden, or required states of a field. This functionality is
                configured through the data dictionary and java code as follows:</para>
            <sect3>
                <title>Conditional Logic</title>
                <para>Any conditional logic that is necessary to determine whether a field should be
                    read-only, hidden, or required (and editable) is implemented with java code. For
                    maintenance documents this code is placed in the presentation controller. The
                    following methods are available for this purpose:</para>
                <programlisting>public Set&lt;String> getConditionallyReadOnlyPropertyNames(MaintenanceDocument document)


public Set&lt;String> getConditionallyRequiredPropertyNames(MaintenanceDocument document)

public Set&lt;String>
getConditionallyHiddenPropertyNames(BusinessObject businessObject)
</programlisting>
                <para>Each of these methods returns a Set of field names (prefixing for the
                    maintainable is not necessary). These fields will then take on the state
                    determined by the method. The first two methods take as a parameter the
                    MaintenanceDocument instance which can be used to get the current values for one
                    or more fields. The third method is more general (because it is used for
                    inquires as well) and takes a BusinessObject instance as a parameter. Within the
                    maintenance context this will again be the MaintenanceDocument and can be cast
                    after doing an instanceof check.</para>
                <para><emphasis role="italic">Example:</emphasis></para>
                <programlisting>@Override
public Set&lt;String> getConditionallyRequiredPropertyNames(MaintenanceDocument document) {
    Set&lt;String> required = new HashSet&lt;String>();
    SubAccount subAccount = (SubAccount) document.getNewMaintainableObject().getBusinessObject();
    if (StringUtils.isNotBlank(subAccount.getFinancialReportChartCode()) &amp;&amp; subAccount.getFinancialReportChartCode().equals("BL")) {
        required.add("a21SubAccount.costShareChartOfAccountCode");
        required.add("a21SubAccount.costShareSourceAccountNumber");
    }
    return required;
}
                </programlisting>
                <para>Only fields that have conditional states need to be considered here. For
                    fields that are always read-only, hidden, or required the corresponding
                    properties on the MaintainableFieldDefinition can be set to true through the
                    data dictionary.</para>
                <para>Sections of the maintenance document can also be conditionally set to
                    read-only or hidden by implementing the following methods within the
                    presentation controller:</para>
                <programlisting>public Set&lt;String> getConditionallyReadOnlySectionIds(
MaintenanceDocument document);
public Set&lt;String> getConditionallyHiddenSectionIds(BusinessObject businessObject);</programlisting>
                <para>Any authorization restrictions will be applied after this logic by the
                    document authorizer class.</para>
                <para>For lookups conditional logic is implemented in the LookupableHelperService.
                    Similar methods exist for determining the read-only, hidden, or required
                    states:</para>
                <programlisting>public Set&lt;String> getConditionallyReadOnlyPropertyNames();
public Set&lt;String> getConditionallyRequiredPropertyNames();

public Set&lt;String> getConditionallyHiddenPropertyNames();</programlisting>
                <para>Each of these methods returns a Set of field names. Code implemented within
                    these methods has access to the lookupable helper properties. In particular the
                    request parameters can be retrieved using getParameters(), and the current rows
                    using getRows(). The following convenience method is also available for getting
                    a property value from the field:</para>
                <programlisting>protected String getCurrentSearchFieldValue(String propertyName)</programlisting>
                <para>It is recommended to use this method to get a value for a property as opposed
                    to the request parameters, since the values could be different. This is because
                    the conditional logic is applied at the end of the lookup lifecycle and field
                    values could have been cleared or set to other values by processing code.
                    Therefore basing conditional logic off these values will correctly reflect the
                    values being returned to the search fields.</para>
                <para><emphasis role="italic">Example:</emphasis></para>
                <programlisting>@Override
public Set&lt;String> getConditionallyHiddenPropertyNames() {
    Set&lt;String> hiddenPropertyNames = new HashSet&lt;String>();

    String employeeId = getCurrentSearchFieldValue(KIMPropertyConstants.Person.EMPLOYEE_ID);
    if (StringUtils.isNotBlank(employeeId)) {
        hiddenPropertyNames.add(KFSPropertyConstants.VENDOR_NUMBER);
        hiddenPropertyNames.add(KFSPropertyConstants.VENDOR_NAME);
    }
    return hiddenPropertyNames;
}</programlisting>
            </sect3>
            <sect3>
                <title>Trigger Fields</title>
                <para>The second part to implementing conditional logic is indicating which fields
                    should trigger a refresh (page post) when its value changes. The page post will
                    call each of the conditional methods so when the page renders the read-only,
                    required, and hidden attributes are set according to the new field value (Note
                    all field values are available to the conditional methods regardless of which
                    one triggered the refresh). To indicate a field should trigger a refresh, set
                    the triggerOnChange attribute to true on the MaintainableFieldDefinition:</para>
                <programlisting>&lt;bean parent="MaintainableFieldDefinition" p:name="financialReportChartCode" p:triggerOnChange="true"/></programlisting>
                <para>For lookups, set the triggerOnChange attribute to true on the lookup
                    FieldDefinition within the lookupFields property:</para>
                <programlisting>&lt;property name="lookupFields" >
    &lt;list>
        &lt;bean parent="FieldDefinition" p:attributeName="payeeTypeCode"/>
        &lt;bean parent="FieldDefinition" p:attributeName="taxNumber" />
        &lt;bean parent="FieldDefinition" p:attributeName="firstName" />
        &lt;bean parent="FieldDefinition" p:attributeName="lastName" />
        &lt;bean parent="FieldDefinition" p:attributeName="vendorNumber" p:triggerOnChange="true" />
        &lt;bean parent="FieldDefinition" p:attributeName="vendorName" />
        &lt;bean parent="FieldDefinition" p:attributeName="employeeId" p:triggerOnChange="true" />
        &lt;bean parent="FieldDefinition" p:attributeName="entityId" p:triggerOnChange="true" />
        &lt;bean parent="FieldDefinition" p:attributeName="active"/>
    &lt;/list>
&lt;/property></programlisting>
                <para>There is no limit to the number of trigger fields specified for a maintenance
                document or lookup.</para>
                <note><para>JavaScript was implemented to set the focus back to the next field in the tab
                    order (from the field that triggered the refresh) when the page refreshes. This
                    will not work correctly if fields are inserted between the field that triggered
                    a refresh and the next tab field (for instance if a field between these two was
                    hidden or read-only, and becomes editable on refresh).</para></note>
            </sect3>
        </sect2>
    </sect1>
    <sect1>
        <title>Configuring a KNS Client in Spring</title>
        <para>The Kuali Nervous System (KNS) is installed as a Rice Module using Spring. The primary
            source for configuring Spring in KNS is the KnsTestSpringBeans.xml file located in the
                <emphasis role="bold">/kns/src/test/resources/</emphasis> directory. This file uses
            the <emphasis role="bold">PropertyPlaceholderConfigurer</emphasis> bean to load tokens
            for runtime configuration using the source file <emphasis role="italic"
                >kns-test-config.xml</emphasis> located in the <emphasis role="bold"
                >/kns/src/test/resources/META-INF</emphasis> directory. </para>
        <para>The <emphasis role="italic">kns-test-config.xml file</emphasis> contains this code
        snippet:</para>
        <programlisting>&lt;param name="module.name">sample-app&lt;/param>
&lt;param name="service.namespace">RICE&lt;/param>
&lt;param name="filter.login.class">org.kuali.rice.kew.web.DummyLoginFilter&lt;/param>
&lt;param name="filtermapping.login.1">/*&lt;/param>
&lt;param name="config.location">classpath:META-INF/test-config-defaults.xml&lt;/param>
&lt;param name="serviceServletUrl">http://localhost:9916/${app.context.name}/remoting/&lt;/param>
&lt;param name="transaction.timeout">3600&lt;/param>

&lt;param name="config.location">classpath:META-INF/common-config-test-locations.xml&lt;/param>

&lt;param name="config.location">${alt.config.location}&lt;/param>
&lt;param name="kns.test.port">9916&lt;/param></programlisting>
        <para>This is a combination of key value pairs. When used in conjunction with Spring
            tokenization and the <emphasis role="bold">PropertyPlaceholderConfigurer</emphasis>
            bean, the parameter name must be equal to the key value in the Spring file so that the
            properties propagate successfully.</para>
        <sect2>
            <title>Spring JTA Configuration</title>
            <para>When doing persistent messaging, it is best to use JTA as your transaction
                manager. This ensure the messages you are sending are synchronized with the current
                executed transaction in your application and also allows message persistence to be
                put in a different database than the application’s logic, if needed. Currently,
                KNSTestSpringBeans.xml uses JOTM to configure JTA without an application server.
                Below is the bean definition for JOTM that can be found in Spring.</para>
            <programlisting>&lt;bean id="jotm" class="org.springframework.transaction.jta.JotmFactoryBean">
    &lt;property name="defaultTimeout" value="${transaction.timeout}"/>

&lt;/bean>
&lt;bean id="dataSource" class="org.kuali.rice.database.XAPoolDataSource">
    &lt;property name="transactionManager" ref="jotm" />
    &lt;property name="driverClassName" value="${datasource.driver.name}" />
    &lt;property name="url" value="${datasource.url}" />
    &lt;property name="maxSize" value="${datasource.pool.maxSize}" />
    &lt;property name="minSize" value="${datasource.pool.minSize}" />
    &lt;property name="maxWait" value="${datasource.pool.maxWait}" />
    &lt;property name="validationQuery" value="${datasource.pool.validationQuery}" />
    &lt;property name="username" value="${datasource.username}" />
    &lt;property name="password" value="${datasource.password}" />
&lt;/bean></programlisting>
            <para>Configure the <emphasis role="bold">TransactionManager</emphasis>, <emphasis
                    role="bold">UserTransaction</emphasis> and a <emphasis role="bold"
                    >DataSource</emphasis>. Use the Rice <emphasis role="bold"
                    >XAPoolDataSource</emphasis> class as your data source because it addresses some
                bugs in the <emphasis role="bold">StandardXAPoolDataSource</emphasis>, which extends
                from this class. </para>
        </sect2>
    </sect1>
    <sect1>
        <title>KNS Validation and Business Rules Framework</title>
        <para>When actions are performed on documents, there is typically some validation to
            accomplish on the document; indeed, a great deal of the business logic for client
            application is stored in document validations. The KNS supports a standard framework for
            validations as well as a way to display errors to application end users.</para>
        <sect2>
            <title>Rules and Events</title>
            <para>KNS validations are performed by rules classes, which respond to a specific
                application event. An event is an object which encapsulates contextual information
                about something which has been requested of a document. For instance, when a user on
                a maintenance document clicks a “Route” button to route the document into workflow,
                the web-layer controller creates an instance of <emphasis role="bold"
                    >org.kuali.rice.kns.rule.event.RouteDocumentEvent</emphasis> which holds the
                document which has just been routed. It then passes this event instance to <emphasis
                    role="bold">org.kuali.rice.kns.service.KualiRuleService</emphasis>.</para>
            <para>The KualiRuleService interrogates the data dictionary entry for the document to
                find a rules class. The event then invokes the rules class against itself. This is
                accomplished through a rule interface. Every event has an associated rule interface;
                the class of this interface is returned by the Event’s <emphasis role="bold"
                    >getRuleInterfaceClass()</emphasis> method. The event will cast the business
                rule from the data dictionary to the interface which it expects, and then call a
                standard method against that interface.</para>
            <para>An example will clarify this. RouteDocumentEvent expects rules implementing the
                rule interface <emphasis role="bold"
                    >org.kuali.rice.kns.rule.RouteDocumentRule</emphasis>, which extends the
                BusinessRule interface given above. RouteDocumentRule has a single method to
                implement:</para>
            <programlisting>public boolean processRouteDocument(Document document);</programlisting>
            <para>When the KualiRuleService gets the event, it finds the data dictionary entry for
                the given document and generates an instance of the business rules class associated
                with the document. It then hands that to the event, which attempts to perform the
                cast to RouteDocumentRule and call the processRouteDocument method:</para>
            <programlisting>public boolean invokeRuleMethod(BusinessRule rule) {
    return ((RouteDocumentRule) rule).processRouteDocument(document);
}
</programlisting>
            <para>It then returns whatever was returned by the rule.</para>
            <para>This brings up the question of what the processRouteDocument method should
                actually do. Rule methods need to accomplish two things:<orderedlist>
                    <listitem>
                        <para>Run the business logic associated with that event against the
                            document. If the business logic decides the document is valid, then a
                            true should be returned. If the business logic, contrarily, decides the
                            document is not valid, a false is typically returned. The result of the
                            method invocation then typically determines whether the given event will
                            be completed. For instance, if <emphasis role="bold"
                                >processRouteDocument</emphasis> returns a false, then the document
                            – which has only had a workflow route requested of it – will fail to
                            route. It will instead return to the document screen. </para>
                    </listitem>
                    <listitem>
                        <para>Some kind of user message should be recorded in the <emphasis
                                role="bold">GlobalVariables.getMessages()</emphasis> thread-local
                            singleton. This singleton has three maps, accessible through the
                                <emphasis role="bold">getErrorMap()</emphasis>, <emphasis
                                role="bold">getWarningMap()</emphasis>, and <emphasis role="bold"
                                >getInfoMap()</emphasis> methods. These maps associate an attribute
                            on the page which caused a failure with a user message explaining the
                            problem. If a false is returned from the method, then it is generally
                            expected that the failure will be recorded in the Error map. </para>
                    </listitem>
                </orderedlist></para>
            <para>An excellent example of this can be found in the sample “Recipe application” which
                ships with Rice, in edu.sampleu.recipe.document.rule.RecipeRules:</para>
            <programlisting>@Override
protected boolean processCustomSaveDocumentBusinessRules(MaintenanceDocument document) {
    boolean valid = super.processCustomSaveDocumentBusinessRules(document);
    if (valid) {
        valid &amp;= validateIngredients(document);
    }
    return valid;
}

private boolean validateIngredients(MaintenanceDocument recipeDocument) {
    Recipe recipe = (Recipe) recipeDocument.getDocumentBusinessObject();
    String ingredients = recipe.getIngredients();
    RecipeCategory category = recipe.getCategory();
    if (category != null) {
        String categoryName = recipe.getCategory().getName();
        if(StringUtils.containsIgnoreCase(ingredients, "beef") &amp;&amp; !StringUtils.equalsIgnoreCase(categoryName, "beef")) {
            putFieldError("categoryId", "error.document.maintenance.recipe.ingredients.beef");
            return false;
        }
    }
    return true;
}</programlisting>
            <para>In this example, the processCustomSaveDocumentBusinessRules is called when the
                document is saved. In turn, the validateIngredients method is called. It checks that
                if the category is not null, then if “beef” is among the ingredients, then the
                categoryName of the recipe must include the word “beef” in it. If that is the case,
                we see that the putFieldError – a convenience method – adds the user message to the
                “categoryId” attribute (meaning the error message will be displayed close to that
                attribute) and that false is returned, meaning that the save is not carried
                out.</para>
        </sect2>
        <sect2>
            <title>Standard KNS Events</title>
            <para>There are eight common KNS events which apply to every document – maintenance and
                transactional – built within client applications. For each, the KNS does an amount
                of standard validation, while leaving customization points so client applications
                can add more validation business logic. They are:</para>
            <para>
                <table frame="none">
                    <title>KNS Events</title>
                    <tgroup cols="4">
                        <colspec colname="c1" colnum="1" colwidth="1.0*"/>
                        <colspec colname="c2" colnum="2" colwidth="1.0*"/>
                        <colspec colname="c3" colnum="3" colwidth="1.0*"/>
                        <colspec colname="c4" colnum="4" colwidth="1.0*"/>
                        <thead>
                            <row>
                                <entry>Event</entry>
                                <entry>Calling circumstances</entry>
                                <entry>Rule interface and method called</entry>
                                <entry>Validation performed in DocumentRuleBase</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>org.kuali.rice.kns.rule.event.RouteDocumentEvent</entry>
                                <entry>Called when a document is routed to workflow.</entry>
                                <entry>org.kuali.rice.kns.rule.RouteDocumentRule#processRouteDocument</entry>
                                <entry>Performs standard data dictionary validation</entry>
                            </row>
                            <row>
                                <entry>org.kuali.rice.kns.rule.event.SaveDocumentEvent</entry>
                                <entry>Called when a document is saved.</entry>
                                <entry>org.kuali.rice.kns.rule.SaveDocumentRule#processSaveDocument</entry>
                                <entry>Performs standard data dictionary validation</entry>
                            </row>
                            <row>
                                <entry>org.kuali.rice.kns.rule.event.ApproveDocumentEvent</entry>
                                <entry>Called when a workflow action is taken against a
                                    document.</entry>
                                <entry>org.kuali.rice.kns.rule.ApproveDocumentRule#processApproveDocument</entry>
                                <entry/>
                            </row>
                            <row>
                                <entry>org.kuali.rice.kns.rule.event.BlanketApproveDocumentEvent</entry>
                                <entry>Called when a document is blanket approved through
                                    workflow.</entry>
                                <entry>org.kuali.rice.kns.rule.ApproveDocumentRule#processApproveDocument</entry>
                                <entry/>
                            </row>
                            <row>
                                <entry>org.kuali.rice.kns.rule.event.AddNoteEvent</entry>
                                <entry>Called when a note is added to a document.</entry>
                                <entry>org.kuali.rice.kns.rule.AddNoteRule#processAddNote</entry>
                                <entry>Validates the note (via the data dictionary)</entry>
                            </row>
                            <row>
                                <entry>org.kuali.rice.kns.rule.event.AddAdHocRoutePersonEvent</entry>
                                <entry>Called when an ad hoc Person to route to is added to a
                                    document.</entry>
                                <entry>org.kuali.rice.kns.rule.AddAdHocRoutePersonRule#processAdHocRoutePerson</entry>
                                <entry>Validates that the ad hoc route Person is valid – that the
                                    Person’s record exists and that the Person has the permission to
                                    approve the document</entry>
                            </row>
                            <row>
                                <entry>org.kuali.rice.kns.rule.event.AddAdHocRouteWorkgroupEvent</entry>
                                <entry>Called when an Ad Hoc workgroup to route to is added to a
                                    document.</entry>
                                <entry>org.kuali.rice.kns.rule.AddAdHocRouteWorkgroupRoute#processAddAdHocRouteWorkgroup</entry>
                                <entry>Validates the ad hoc route workgroup – that the workgroup
                                    exists and that the workgroup has permission to receive an ad
                                    hoc request and approve the document.</entry>
                            </row>
                            <row>
                                <entry>org.kuali.rice.kns.rule.event.SendAdHocRequestsEvent</entry>
                                <entry>Called when the end user requests that ad hoc events be
                                    sent.</entry>
                                <entry/>
                                <entry/>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>
            <para>Since the standard events have to perform standard validation, they have custom
                methods to override. For instance, org.kuali.rice.kns.rules.DocumentRuleBase has a
                method “processCustomRouteDocumentBusinessRules” and it is expected that client
                applications will override this method rather than processRouteDocumentBusinessRules
                directly.</para>
            <para>Maintenance documents add another event to this:
                org.kuali.rice.kns.rule.event.KualiAddLineEvent. This is invoked when a new item is
                added to a collection on a maintenance document. The
                org.kuali.rice.kns.maintenance.rules.MaintenanceDocumentRuleBase also contains a
                number of useful utility methods which makes writing business rules for maintenance
                documents easier.</para>
        </sect2>
        <sect2>
            <title>Notifying Users of Errors</title>
            <para>When a validation results in some kind of text being displayed to the user,
                    <emphasis role="bold">GlobalVariables.getMessageMap()</emphasis> is used to
                store that text and is inquired during rendering to make sure messages are correctly
                displayed. As mentioned previously, the MessageMap is made up of three different
                maps: one for errors, one for warnings, and one for information messages. Each map
                has a “put” command – for instance, putError; each has a “has” predicate, such as
                “hasErrors”; and each have the ability to get the properties with form the keys of
                the map as well as any messages associated with that property. Adding, an error
                message to the map is easy, as seen in this example from the
                IdentityManagementGroupDocument:</para>
            <programlisting>GlobalVariables.getMessageMap().putError("document.member.memberId", RiceKeyConstants.ERROR_EMPTY_ENTRY, new String[] {"Member Type Code and Member ID"});</programlisting>
            <para>The method takes the property that the error is most associated with, which
                determines where the text will be displayed (ie, at the top of the section which
                contains the given property); a key to the User Message containing the error; and an
                array of Strings which will be interpolated into the message using the standard Java
                    <emphasis role="bold">java.text.MessageFormat</emphasis>.</para>
            <para>Further details about the use of User Messages can be found in the KNS User
                Messages section.</para>
        </sect2>
        <sect2>
            <title>Creating New Events</title>
            <para>While the vast majority of maintenance documents in client applications will not
                have custom actions, it is common in transactional documents to have new events
                beyond the standard ones provided by the KNS framework. Basically, any button
                created on a transactional document – one which results in a call to a method in the
                transactional document’s action class – may well have an event associated with it.
                In that case, there are three pieces to create for the rule: the new event, the rule
                instance which is called from that event, and the default implementation for that
                rule.</para>
            <para>An example from Kuali Financial Systems 3.0 will illustrate how these are used.
                The Cash Control transactional document in the Accounts Receivable module has a
                collection of details, added via an “add” button. To validate that action, an event
                was created (this code has slightly been altered for the sake of
                illustration):</para>
            <programlisting>package org.kuali.kfs.module.ar.document.validation.event;

public final class AddCashControlDetailEvent extends KualiDocumentEventBase {
    private final CashControlDetail cashControlDetail;

    public AddCashControlDetailEvent(String errorPathPrefix, Document document, CashControlDetail cashControlDetail) {
        super("Adding cash control detail to document " + getDocumentId(document), errorPathPrefix, document);
        this.cashControlDetail = cashControlDetail;
    }

    public Class getRuleInterfaceClass() {
        return AddCashControlDetailRule.class;
    }

    public boolean invokeRuleMethod(BusinessRule rule) {
        return ((AddCashControlDetailRule) rule).processAddCashControlDetailBusinessRules((TransactionalDocument) getDocument(), this.cashControlDetail);
    }

}</programlisting>
            <para>The AddCashControlDetailEvent extends the KualiDocumentEventBase class, defined in
                the KNS. Note that it encapsulates the state to check – both the document at hand
                and the cash control detail which is being validated. Finally, it implements the two
                methods which make the rule work: the <emphasis role="bold"
                    >getRuleInterfaceClass()</emphasis> and the <emphasis role="bold"
                    >invokeRuleMethod()</emphasis>. This works precisely as it does in the KNS
                RouteDocumentEvent.</para>
            <para>The AddCashControlDetailRule looks like this:</para>
            <programlisting>public interface AddCashControlDetailRule&lt;F extends TransactionalDocument > {
    public boolean processAddCashControlDetailBusinessRules(F transactionalDocument, CashControlDetail cashControlDetail);
}</programlisting>
            <para>This is very straightforward. There is a rules class, in turn, which implements
                this interface. Finally, the rules have to be called; that occurs when an event is
                created and sent to the KualiRuleService, which is typically done in the web layer’s
                controller. In our example, this occurs in the CashControlDocumentAction:</para>
            <programlisting>// apply rules for the new cash control detail
rulePassed &amp;= ruleService.applyRules(new AddCashControlDetailEvent(ArConstants.NEW_CASH_CONTROL_DETAIL_ERROR_PATH_PREFIX, cashControlDocument, newCashControlDetail));</programlisting>
            <para>Now the new action will be validated properly.</para>
        </sect2>
    </sect1>
    <sect1>
        <title>KNS User Messages</title>
        <para>Functional users need a simple way to change wording of messages used throughout a KNS
            client application. Those messages may even be in a language foreign to that of the
            Foundation shipped messages (which are shipped in English). To facilitate ease of
            message changing, the KNS builds functionality on top of the standard Java message
            properties mechanism.</para>
        <para>Once the Rice application has been generated, in src/main/resources, there will be a
            file named configurationServiceData.xml. That file lists a number of properties files
            which will be loaded:</para>
        <programlisting>&lt;configuration>
    &lt;properties fileName="KR-ApplicationResources.properties" />
    &lt;properties fileName="KIM-ApplicationResources.properties" />
&lt;/configuration></programlisting>
        <para>Each of these files are listed relative to the src/main/resources directly. A property
            file simply relates messages to keys, like so (from the
            src/main/resources/KR-ApplicationResources.properties file):</para>
        <programlisting>document.question.cancel.text=Are you sure you want to cancel?

document.question.delete.text=Are you sure you want to delete?


document.question.deleteContext.text=Are you sure you want to delete [b]{0}[/b]?

document.question.disapprove.text=Are you sure you want to [b]disapprove[/b] this document?

document.question.saveBeforeClose.text=Would you like to save this document before you close it?</programlisting>
        <para>This is the standard Java property file format, with keys (for instance,
            “document.question.cancel.text”) related to messages.</para>
        <para>A message may also have escaped HTML tags and templated positions in the text for
            other Strings to be interpolated in. An example of this is found in the
            “document.question.deleteContext.text” message. The [b] and [/b] will be translated
            automatically to bold markup. The {0} will be replaced, if possible, by another String.
            An example of this will be covered below.</para>
        <para>Rice Best Practices suggest that each module in the client application have a
            KeyConstants class which relates the names of user message keys to the String constants.
                <emphasis role="bold">org.kuali.rice.kns.util.RiceKeyConstants</emphasis> is the key
            constants class for the KNS.</para>
        <para>Developers of client applications can also override pre-existing messages. Messages
            are loaded in the order listed in the configurationServiceData.xml file above, so client
            application specific files should be listed later in the file. Then, if the client
            application user message file redefines a user message using the same key, as so:</para>
        <programlisting>document.question.cancel.text=Canceling will lead to permanent disuse of this document.  Are you completely certain this is the action you want to take?</programlisting>
        <para>users will be treated to the longer, more worried user message.</para>
        <sect2>
            <title>Retrieving User Messages</title>
            <para>Retrieving the text for user messages can be done in a number of ways, based on
                the context the user message occurs in. The easiest use case is to get the text of
                the message directly through the default implementation of <emphasis role="bold"
                    >org.kuali.rice.kns.service.KualiConfigurationService</emphasis>. It has a
                method, <emphasis role="bold">getPropertyString</emphasis>, which, when handed the
                key to the message, returns the message text.</para>
            <programlisting>final String message = KNSServiceLocator.getKualiConfigurationService().getPropertyString(RiceKeyConstants.ERROR_DATE_TIME);</programlisting>
            <para>This will return the String “{0} is not a valid date/time.” Note that in this
                case, the String will not be interpolated; <emphasis role="bold"
                    >java.text.MessageFormat</emphasis> should be used to switch the {0} with an
                actual, useful String.</para>
            <para>KualiConfigurationService also has a method, <emphasis role="bold"
                    >getPropertyAsBoolean</emphasis>, which translates the messages (regardless of
                case) of “true”, “yes”, “on”, or “1” as a boolean true and everything else as a
                false.</para>
        </sect2>
        <sect2>
            <title>Error Messages</title>
            <para>The vast majority of user messages are warnings when an error occurs. Thankfully,
                as was seen in the section on validations, the KNS handles error messages through
                the user messages system. For instance, in this code:</para>
            <programlisting>GlobalVariables.getErrorMap().putError("someProperty", ClientApplicationConstants.ERROR_MESSAGE, new String[] { businessObject.getSomeProperty().toString() });</programlisting>
            <para>The error message displayed will be the one with the key held by <emphasis
                    role="bold">ClientApplicationConstants.ERROR_MESSAGE</emphasis>, and the value
                of <emphasis role="bold">businessObject.getSomeProperty().toString()</emphasis> will
                be interpolated into the message.</para>
            <para>The message must be in the user messages file loaded by
                KualiConfigurationService.</para>
        </sect2>
        <sect2>
            <title>Struts Messages</title>
            <para>User messages are also available to the web layer of transactional documents and
                user screens through the standard Struts <emphasis role="bold"
                    >bean:message</emphasis> tag.</para>
            <para>Messages to be loaded to struts are configured via the client application’s
                project configuration file, in the <emphasis role="bold"
                    >rice.struts.message.resources</emphasis> property, like so:</para>
            <programlisting>&lt;param name="rice.struts.message.resources">KR-ApplicationResources,org.kuali.rice.kew.ApplicationResources,org.kuali.rice.ksb.messaging.ApplicationResources,KIM-ApplicationResources&lt;/param></programlisting>
            <para>Again, the files are listed relative to the src/main/resources directory. There is
                nothing to prevent programmers from using one user message file for both the
                KualiConfigurationService messages and the Struts messages.</para>
            <para>Once Struts has these messages loaded, it is easy to access them in a JSP page or
                jsp TAG file. Indeed, a great many of the delivered Rice tags make use of these
                message resources in order to display information, as seen from this sample from the
                standard <emphasis role="bold">kul:page</emphasis> tag:</para>
            <programlisting>&lt;title>&lt;bean:message key="app.title" /> :: ${headerTitle}&lt;/title></programlisting>
            <para>In this case, the user message – set in KR-ApplicationResources.properties – with
                the property key of “app.title” will be displayed (which, by default as
                “Kuali”).</para>
            <para>Developers curious about further information about the bean:message tag would be
                advised to read Struts’ documentation of the feature: <link
                    xlink:href="http://struts.apache.org/1.2.x/userGuide/struts-bean.html"
                    >http://struts.apache.org/1.2.x/userGuide/struts-bean.html</link>.</para>
        </sect2>
    </sect1>
<!-- TODO: Section in original Word document
    <sect1>
        <title>KNS Document Locking</title>
    </sect1>
-->    
    <sect1>
        <title>KNS Questions and Dialogs</title>
        <para>Several use cases exist where extra document processing needs to occur between the
            submitting of a document for routing or approval and the validation on that document.
            For instance, a document may be created to purchase an airplane ticket. The initial
            submitter is not required to enter the airline that will be traveled on. However, if the
            initial submitter attempts to route the document without an airline being entered, a
            prompt can come up to ask if the submitter really meant to not enter the airline. If the
            answer is yes, the document will go on to validation; if the answer is no, then the
            document will return to allow the user to edit.</para>
        <sect2>
            <title>Prompting Before Validation</title>
            <para>This kind of prompt is easily accomplished by giving the document an <emphasis
                    role="bold">org.kuali.rice.kns.rule.PromptBeforeValidation</emphasis>
                implementation. This is done via the data dictionary:</para>
            <programlisting>&lt;bean id="BudgetAdjustmentDocument" parent="AccountingDocumentEntry">
    &lt;property name="documentTypeName" value="BA"/>
    &lt;property name="documentClass" value="org.kuali.kfs.fp.document.BudgetAdjustmentDocument"/>
    &lt;property name="promptBeforeValidationClass" value="org.kuali.kfs.fp.document.validation.impl.BudgetAdjustmentDocumentPreRules"/>
        ...
&lt;/bean></programlisting>
            <para>The <emphasis role="bold">PromptBeforeValidation</emphasis> interface only has one
                method, <emphasis role="bold">processPrompts</emphasis>. It is responsible for
                holding the current form at a current point, rendering a question, getting the
                answer to that question, and applying that answer to the next forward. It provides a
                lot of flexibility.</para>
            <para>If, however, all of the questions to ask the user can be formulated as yes/no
                questions, it is more advisable to simply extend <emphasis role="bold"
                    >org.kuali.rice.kns.rules.PromptBeforeValidationBase</emphasis> and override the
                    <emphasis role="bold">doPrompts</emphasis> method. <emphasis role="bold"
                    >PromptBeforeValidationBase</emphasis> provides all the functionality
                necessarily to easily ask a yes/no question or even a series of yes/no
                questions.</para>
            <para>Analysis of an example from KFS should help clarify how this works. <emphasis
                    role="bold"
                    >org.kuali.kfs.module.ar.document.validation.impl.CustomerPreRules</emphasis>
                will be examined. Here is how it overrides the <emphasis role="bold"
                    >doPrompts</emphasis> method:</para>
            <programlisting>@Override
public boolean doPrompts(Document document) {
    boolean preRulesOK = true;
    preRulesOK &amp;= conditionallyAskQuestion(document);
    return preRulesOK;
}
</programlisting>
            <para><emphasis role="bold">doPrompts</emphasis> takes the document to act upon as a
                parameter and it returns a boolean variable. If true is returned, the document will
                plow forward into validation. If false is returned, then the view should return to
                another forward. Which forward used will be soon revealed.</para>
            <para>Given this information, it’s obvious that the real work is occurring in <emphasis
                    role="bold">conditionallyAskQuestion</emphasis>. And indeed it is:</para>
            <programlisting>protected boolean conditionallyAskQuestion(Document document) {
    MaintenanceDocument maintenanceDocument = (MaintenanceDocument) document;
    Customer newCostomer = (Customer) maintenanceDocument.getNewMaintainableObject().getBusinessObject();
    boolean shouldAskQuestion = maintenanceDocument.isNew() &amp;&amp; checkIfOtherCustomerSameName(newCostomer);

    if (shouldAskQuestion) {
        String questionText = SpringContext.getBean(KualiConfigurationService.class).getPropertyString(ArKeyConstants.CustomerConstants.MESSAGE_CUSTOMER_WITH_SAME_NAME_EXISTS);
        boolean confirm = super.askOrAnalyzeYesNoQuestion(ArKeyConstants.CustomerConstants.GENERATE_CUSTOMER_QUESTION_ID, questionText);
        if (!confirm) {
            super.abortRulesCheck();
        }
    }
    return true;
}</programlisting>
            <para>The document in this example is a maintenance document, but the method works
                precisely the same given a transactional document.</para>
            <para>Logic determines, in this case, if the customer is new and if it shares the name
                of an existing customer. If that is the case, then it asks a yes/no question about
                if the user meant to enter a second customer with the same name. Note that question
                text is specified via a User Message; this is a best practice.</para>
            <para>The question is asked and the yes/no answer returned through the <emphasis
                    role="bold">super.askOrAnalyzeYesNoQuestion</emphasis>. That needs to be handed
                an ID which uniquely represents every asking of this question – that, in conjunction
                with information from the document itself, is used to identify the user response,
                which ends up in the session. The other method argument is the question text
                itself.</para>
            <para>It returns true or false. Note though, that if the response was false, that false
                is not returned, but instead a method <emphasis role="bold"
                    >super.abortRulesCheck();</emphasis> is called.</para>
            <para><emphasis role="bold">abortRulesCheck()</emphasis> is simply a convenience method
                that sets the forward to return to as the <emphasis role="bold"
                    >BASIC_MAPPING</emphasis>:</para>
            <programlisting>public void abortRulesCheck() {
    event.setActionForwardName(RiceConstants.MAPPING_BASIC);
    isAborting = true;
}</programlisting>
            <para>If application requirements determine that a “no” answer should navigate the user
                to a different mapping than “basic”, then <emphasis role="bold"
                    >abortRulesCheck</emphasis> should not be used, but instead, a false should be
                returned from the method, and the correct action forward name should be set on the
                event property inherited from <emphasis role="bold"
                    >PromptBeforeValidationBase</emphasis>.</para>
            <para>There is no limit to the number of times <emphasis role="bold"
                    >super.askOrAnalyzeYesNoQuestion</emphasis> can be called in a single pre-rules
                check; several questions can be chained together.</para>
        </sect2>
        <sect2>
            <title>HTML Markup</title>
            <para>In the question framework some markup support is present for formatting the
                question text. This markup follows a custom syntax as opposed to HTML. Standard HTML
                characters will be escaped in the question text. This is to prevent cross-site
                scripting attacks. The custom syntax for the supported tags is then translated to
                the corresponding HTML when rendering the question page.</para>
            <para>The custom syntax uses brackets to indicate tags as opposed to the standard HTML
                left and right angle quote characters. Like HTML, an opening and closing tag must be
                present: e.g. [tag] ... [/tag]. The custom syntax does not support empty body tags:
                e.g. [tag/].</para>
            <para>The following is a list of the tags supported along with the corresponding HTML
                translation.</para>
            <programlisting>* All 1 character HTML tags
Examples:
[p] ... [/p] translates to &lt;p> .... &lt;/p>
[b] ... [/b] translates to &lt;b> .... &lt;/b>


* All 2 character HTML tags
Examples:

[br] ... [/br] translates to &lt;br> .... &lt;/br>
[tr] ... [/tr] translates to &lt;tr> .... &lt;/tr>

[td] ... [/td] translates to &lt;td> .... &lt;/td>

* The font tag with color specified as hex or by name
Examples:
[font #000000] ... [/font] translates to &lt;font color="#000000"> .... &lt;/font>
[font red] ... [/font] translates to &lt;font color="red"> .... &lt;/font>

* The table tag

Example:

[table] ... [/table] translates to &lt;table> .... &lt;/table>

* The table tag with style class
Example:
[table questionTable] ... [/table] translates to &lt;table class="questionTable"> .... &lt;/table>


* The td tag with style class

Example:
[td leftTd] ... [/td] translates to &lt;td class="leftTd"> .... &lt;/td></programlisting>
            <para>Note since the style tag is not allowed any CSS classes used must be declared in
                the Kuali style sheet (by default kuali.css). In addition be aware that the one and
                two character tags are not verified as valid HTML tags. In essence, the brackets are
                simply replaced by the angle quotes and outputted for these tags.</para>
            <para>When forming the question text, consideration should be given to the text length.
                The question text is sent as one of the request parameters on the URL which is
                limited by the browser supported max length. Keeping the text under 1000 characters
                will be safe across all supported browsers.</para>
        </sect2>
    </sect1>
    <sect1>
        <title>Derived Values Setters</title>
        <para>What about those instances when a client application has a document that needs to set
            values based on user input but which do not require any further user prompts before the
            document is validated? This is where <emphasis role="bold"
                >org.kuali.rice.kns.web.derviedvaluesetter.DerivedValuesSetter</emphasis> steps
            in.</para>
        <para><emphasis role="bold">DerivedValuesSetter</emphasis> has one method: </para>
        <programlisting>public void setDerivedValues(KualiForm form, HttpServletRequest request);</programlisting>
        <para>Nothing is returned, and the arguments are basically the web form and the servlet
            request itself. Values can be gathered from either of those sources, and then values can
            be set anywhere on the form – though it would typically be expected that the document in
            the <emphasis role="bold">KualiForm</emphasis> would be where everything is set.</para>
        <para>Actual examples of <emphasis role="bold">DerivedValuesSetter</emphasis>
            implementations is fairly rare. There is one example from KFS 3.0 which will be used as
            an example, associated with the Organization Maintenance Document. First, the <emphasis
                role="bold">DerivedValuesSetter</emphasis> is set in the data dictionary for the
            document:</para>
        <programlisting>&lt;bean id="OrganizationMaintenanceDocument" parent="MaintenanceDocumentEntry">
    &lt;property name="businessObjectClass" value="org.kuali.kfs.coa.businessobject.Organization"/>
    &lt;property name="documentTypeName" value="ORGN"/>
    &lt;property name="promptBeforeValidationClass" value="org.kuali.kfs.coa.document.validation.impl.OrgPreRules"/>
    &lt;property name="derivedValuesSetterClass" value="org.kuali.kfs.coa.document.web.OrgDerivedValuesSetter"/>
        ...
&lt;/bean>
</programlisting>
        <para>The actual <emphasis role="bold">DerivedValuesSetter</emphasis> itself attempts to use
            the <emphasis role="bold">PostalCodeService</emphasis> to set the city and state of the
            organization. Here’s a simplified version:</para>
        <programlisting>public class OrgDerivedValuesSetter implements DerivedValuesSetter {
    public void setDerivedValues(KualiForm form, HttpServletRequest request) {
        final Organization newOrg = (Organization) ((MaintenanceDocumentBase)((KualiMaintenanceForm) form).getDocument()).getNewMaintainableObject().getBusinessObject();
        final String organizationZipCode = newOrg.getOrganizationZipCode();
        final String organizationCountryCode = newOrg.getOrganizationCountryCode();
        if (StringUtils.isNotBlank(organizationZipCode) &amp;&amp; StringUtils.isNotBlank(organizationCountryCode)) {
            final PostalCode postalZipCode = SpringContext.getBean(PostalCodeService.class).getByPrimaryId(organizationCountryCode, organizationZipCode);
            if (ObjectUtils.isNotNull(postalZipCode)) {
                newOrg.setOrganizationCityName(postalZipCode.getPostalCityName());
                newOrg.setOrganizationStateCode(postalZipCode.getPostalStateCode());
            }
        }
    }

}</programlisting>
        <para>Here, the new Organization business object is pulled from the maintenance document,
            and from that, the zip code and country code are pulled. The code attempts to use the
            country and zip codes to find a postal code, and if one is found, it sets the city and
            state of the document.</para>
        <para>Both <emphasis role="bold">PromptBeforeValidation</emphasis> and <emphasis role="bold"
                >DerivedValuesSetter</emphasis> classes offer KNS client application developers the
            flexibility to prompt the user or set values on a document before that document goes
            into validation.</para>
    </sect1>
    <sect1>
        <title>KNS Notes and Attachments</title>
        <para>On most documents written for Rice client applications, there exists a tab at the
            bottom of the page, the Notes tab. This allows document editors to attach files to the
            page or write explanatory notes.</para>
        <para>How are these notes supported? </para>
        <para><emphasis role="bold">org.kuali.rice.kns.bo.PersistableBusinessObject</emphasis>
            requires methods to add and programmatically manipulate notes on the object. Therefore,
            all persisting business objects in client applications support the addition of notes to
            them. This allows for a great amount of flexibility. A note, represented by objects of
            class <emphasis role="bold">org.kuali.rice.kns.bo.Note</emphasis>, hold both text and
            links to attachments—as well as the note’s creator and the time it was created.
            Therefore, such text and attachments can be associated with any persisting business
            object.</para>
        <para>However, most Rice applications use Notes mostly on documents. In this case, the Note
            is associated with <emphasis role="bold">org.kuali.rice.kns.bo.DocumentHeader</emphasis>
            objects – the header of the document. The <emphasis role="bold">kul:notes</emphasis> tag
            and <emphasis role="bold"
                >org.kuali.rice.kns.web.struts.action.KualiDocumentActionBase</emphasis> jointly
            provide support for adding these kinds of notes.</para>
        <para>The use of these notes are also authorized by a number of KIM permissions. Before
            notes are added, the user is checked for having the <emphasis role="bold">KR-NS Add Note
                / Attachment</emphasis> permission. These permissions should always have a
            permission attribute associated with document name; optionally, a permission attribute
            for <emphasis role="bold">attachmentTypeCode</emphasis> can be used.</para>
        <para>There is also the <emphasis role="bold">KR-NS Delete Note / Attachment</emphasis>
            permission. Two permission attributes are required for this: both the document name, and
            a record for the <emphasis role="bold">createdBySelfOnly</emphasis> attribute (a boolean
            attribute that may prevent end users from deleting notes created by other end
            users).</para>
        <para>Finally, there is the <emphasis role="bold">KR-NS View Note / Attachment</emphasis>
            permission. Just as with <emphasis role="bold">Add Note / Attachment</emphasis>
            permissions, it requires a document type name and can have an optional <emphasis
                role="bold">attachmentTypeCode</emphasis>.</para>
        <para>Note’s attachments are handled by <emphasis role="bold"
                >org.kuali.rice.kns.service.AttachmentService</emphasis>. By default, they attempt
            to move attachments into a directory specified by the <emphasis role="bold"
                >attachments.directory</emphasis> configuration property; under that, each object
            gets its own subdirectory, with the name of the subdirectory based on the objectId of
            the business object.</para>
    </sect1>
    <sect1>
        <title>KNS Javascript Guide</title>
        <para>The KNS provides a number of ways to integrate Javascript into maintenance and
            transactional documents. A configuration parameter allows a core set of Javascript files
            to be imported on all pages. External Javascript files specific to a limited set of
            documents can easily be imported into pages using the data dictionary. Several KNS tags
            also support response to Javascript events.</para>
        <para>Setting the configuration parameter is easiest of all. In the <emphasis role="bold"
                >{project name}-config.xml</emphasis> file for most client applications, there
            already exists a generated line which looks like this:</para>
        <programlisting>&lt;param name="javascript.files">kr/scripts/core.js,kr/scripts/dhtml.js,kr/scripts/documents.js,kr/scripts/my_common.js,kr/scripts/objectInfo.js&lt;/param></programlisting>
        <para>These scripts will be pulled in on every page which uses the <emphasis role="bold"
                >kul:page</emphasis> tag. Note that the file path is relative to the root path of
            the project. It bears mentioning, too, that the css.files property works the same way
            for CSS files:</para>
        <programlisting>&lt;param name="css.files">kr/css/kuali.css&lt;/param></programlisting>
        <para>It’s not always the best idea to include Javascript pages, which the browser must
            parse, onto every single page. If only certain documents or even a single document needs
            a given Javascript file, it is easiest to simply tell the data dictionary entry to
            import the file. Here is an example from KFS’s Account Maintenance Document (<emphasis
                role="bold">AccountMaintenanceDocument.xml</emphasis>):</para>
        <programlisting>&lt;bean id="AccountMaintenanceDocument" parent="AccountMaintenanceDocument-parentBean"/>

&lt;bean id="AccountMaintenanceDocument-parentBean" abstract="true" parent="MaintenanceDocumentEntry" p:businessObjectClass="org.kuali.kfs.coa.businessobject.Account" p:maintainableClass="org.kuali.kfs.coa.document.KualiAccountMaintainableImpl">

    ...
    &lt;property name="webScriptFiles">
        &lt;list>
            &lt;value>../dwr/interface/SubFundGroupService.js&lt;/value>
            &lt;value>../scripts/coa/accountDocument.js&lt;/value>
        &lt;/list>
    &lt;/property>
    ...
&lt;/bean></programlisting>
        <para>Values are expected to be relative to the base application URL of the document. In
            this case of a maintenance document, the URL is /application-name/kr/maintenance.do and
            the javascript files are located under /application-name/scripts, hence the “..” in the
            directories.</para>
        <sect2>
            <title>Integrating Javascript with KNS tags</title>
            <para>As will be covered in the KNS tags section, most controls in KFS documents are
                rendered using the <emphasis role="bold">kul:htmlControlAttribute</emphasis> tag.
                That tag has three attributes which will be passed on to the rendered HTML control:
                    <emphasis role="bold">onblur</emphasis>, <emphasis role="bold"
                    >onclick</emphasis>, and <emphasis role="bold">onchange</emphasis>, which will
                be passed on to the rendered control. (Though there is an exception to keep in mind:
                radio buttons will render what was passed in the onchange attribute as <emphasis
                    role="bold">onclick</emphasis>, to enhance support for a highly popular legacy
                browser.)</para>
            <para>Extra buttons also support Javascript, specifically the “<emphasis role="bold"
                    >onclick</emphasis>” event handler. By setting the <emphasis role="bold"
                    >extraButtonOnclick</emphasis> property of an <emphasis role="bold"
                    >org.kuali.rice.kns.web.ui.ExtraButton</emphasis> object to the text that should
                appear in the button’s <emphasis role="bold">onclick</emphasis> call, the developer
                gains the ability to react, with Javascript, to the button’s click.</para>
        </sect2>
        <sect2>
            <title>Incorporating AJAX</title>
            <para>Finally, we want to make our maintenance documents as interactive as possible to
                facilitate efficient user experience. In this example, KFS’s <emphasis role="bold"
                    >AccountMaintenanceDocument</emphasis> wants to instantly give an error to users
                if the sub fund group assigned to the account is restricted, based on other values
                of the account.</para>
            <para>To accomplish this, in the data dictionary file for the <emphasis role="bold"
                    >AccountMaintenanceDocument</emphasis>, extra JavaScript files are
                imported.</para>
            <programlisting>&lt;property name="webScriptFiles">
    &lt;list>
        &lt;value>../dwr/interface/SubFundGroupService.js&lt;/value>
        &lt;value>../scripts/coa/accountDocument.js&lt;/value>
    &lt;/list>

&lt;/property></programlisting>
            <para>The <emphasis role="bold">../scripts/chart/accountDocument.js</emphasis> is a
                JavaScript file that defines the functions <emphasis role="bold"
                    >onblur_subFundGroup</emphasis> and <emphasis role="bold"
                    >checkRestrictedStatusCode_Callback</emphasis>. <emphasis role="bold"
                    >onblur_subFundGroup</emphasis> uses the <emphasis role="bold"
                    >SubFundGroupService</emphasis>, and to that successfully, DWR needs to create a
                JavaScript/Java bridge for that access. That's the purpose of the inclusion of the
                    <emphasis role="bold">../dwr/interface/SubFundGroupService.js</emphasis> file:
                it's not a real JavaScript file at all, but instead a bridge created on the fly by
                DWR.</para>
            <para>Maintainable fields can then trip off the AJAX call when certain events
                happen:</para>
            <programlisting>&lt;bean parent="MaintainableFieldDefinition" p:name="subFundGroupCode" p:required="true" p:webUILeaveFieldFunction="onblur_subFundGroup" p:webUILeaveFieldCallbackFunction="checkRestrictedStatusCode_Callback"/></programlisting>
            <para>In the above example, when the user leaves the UI field for the sub-fund group
                code, the <emphasis role="bold">onblur_subFundGroup</emphasis> JavaScript function
                will be called, and that should populate the name of the sub-fund group in the page
                under the UI field.</para>
        </sect2>
    </sect1>
    <sect1>
        <title>KNS Data Masking</title>
        <para>It is very common for business objects to have fields which are not viewable to all
            users. The KNS provides very easy ways to mask fields throughout client
            applications.</para>
        <para>Naturally, since certain end users can see the field unmasked, certain other users can
            see the field partially masked, and a final group of users views a fully masked field,
            KNS data masking it integrated with KIM permissions. Specifically, there are two KIM
            permissions which are consulted by KNS data masking: <emphasis role="bold">KR-NS Full
                Unmask Field</emphasis> and <emphasis role="bold">KR-NS Partial Unmask
                Field</emphasis>. Both of these permissions have two related permission attribute
            records: one for the field name, and one for the business object component name. That
            masking will automatically be applied to every use of the business object’s field: on
            inquiries, lookups, maintenance documents, transactional documents, and screens.</para>
        <programlisting>&lt;bean id="IdentityManagementPersonDocument-taxId-parentBean" parent="AttributeDefinition" abstract="true" p:name="taxId" p:forceUppercase="true" p:label="Tax Identification Number" p:shortLabel="Tax Id" p:maxLength="100" p:required="false">
    &lt;property name="control">
        &lt;bean parent="TextControlDefinition" p:size="20"/>
    &lt;/property>
    &lt;property name="attributeSecurity">
        &lt;bean parent="AttributeSecurity">
            &lt;property name="mask" value="true"/>
            &lt;property name="maskFormatter">
                &lt;bean parent="MaskFormatterLiteral" p:literal="*********"/>
            &lt;/property>
        &lt;/bean>
    &lt;/property>
&lt;/bean></programlisting>
        <para>Having a KIM permission set up is not enough, however. Client application developers
            also have to associate masking with the field of the business object in the business
            object’s data dictionary. That is accomplished by specifying the an attribute security
            object with the attribute. <emphasis role="bold"
                >IdentityManagementPersonDocument</emphasis>’s taxId attribute has an example of an
            attribute security declaration:</para>
        <para>The taxId field has a <emphasis role="bold">TextControlDefinition</emphasis> for the
            control, and that is followed by the attribute security declaration.</para>
        <para>The attribute security declaration has a parent of the “<emphasis role="bold"
                >AttributeSecurity</emphasis>” bean. There are several boolean properties available
            within the AttributeSecurity bean, but the mask and partialMask properties are the most
            interesting. This declaration quite simply turns masking on – if the <emphasis
                role="bold">AttributeSecurity</emphasis> is left null or if masking or partialMask
            are false, then no masking will be applied to the attribute.</para>
        <para>Also specified in the example is the <emphasis role="bold">maskFormatter</emphasis>.
            There is also a partialMaskFormatter which can be set. A bean of any class which
            implements <emphasis role="bold"
                >org.kuali.rice.kns.datadictionary.mask.MaskFormatter</emphasis> can be used for
            this declaration. The KNS also provides two default implementations: <emphasis
                role="bold">org.kuali.rice.kns.datadictionary.mask.MaskFormatterLiteral</emphasis>,
            which simply replaces a value which should be masked by a literal String (in the example
            above, “*********”), and <emphasis role="bold"
                >org.kuali.rice.kns.datadictionary.mask.MaskFormatterSubString</emphasis>, which
            replaces all but a substring of the masked value as a String (this would be useful in
            partial mask situations).</para>
        <para>The final piece of the puzzle is to get the KNS to consult the KIM permission and the
            business object’s data dictionary when deciding whether or not to mask the field. Of
            course, the KNS renders maintenance documents, inquiry pages, and lookups automatically
            – it is expected that masking will be consulted in those situations.</para>
        <para>This leaves only the issue of transactional documents and screens, where a client
            application developer has to build JSP manually. The KNS provides a number of helper
            functions to do permission checks.</para>
        <para>
            <table frame="none">
                <title>KNS Helper Functions for Permission Checks</title>
                <tgroup cols="3">
                    <colspec colname="c1" colnum="1" colwidth="1.0*"/>
                    <colspec colname="c2" colnum="2" colwidth="1.0*"/>
                    <colspec colname="c3" colnum="3" colwidth="1.0*"/>
                    <thead>
                        <row>
                            <entry>JSP Function</entry>
                            <entry>Call Example</entry>
                            <entry>Description</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>canFullyUnmaskField</entry>
                            <entry><emphasis role="bold">${kfunc:canFullyUnmaskField (
                                    businessObjectClassName, fieldName,
                                kualiForm)}</emphasis></entry>
                            <entry>Checks KIM permissions to determine if the field can be fully
                                unmasked by the current end user.</entry>
                        </row>
                        <row>
                            <entry>canPartiallyUnmaskField</entry>
                            <emphasis role="bold">
                                <entry>${kfunc:canPartiallyUnmaskField (businessObjectClassName,
                                    fieldName, kualiForm)}</entry>
                            </emphasis>
                            <entry>Checks KIM permissions to determine if the field can be partially
                                unmasked by the current end user.</entry>
                        </row>
                        <row>
                            <entry>getFullyMaskedValue</entry>
                            <emphasis role="bold">
                                <entry>${kfunc:getFullyMaskedValue (className, fieldName, kualiForm,
                                    propertyName)}</entry>
                            </emphasis>
                            <entry>Uses the AttributeSecurity declaration to determine the fully
                                masked value.</entry>
                        </row>
                        <row>
                            <entry>getPartiallyMaskedValue</entry>
                            <entry><emphasis role="bold">${kfunc:getPartiallyMaskedValue (className,
                                    fieldName, kualiForm, propertyName)}</emphasis></entry>
                            <entry>Uses the AttributeSecurity declaration to determine the partially
                                masked value.</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </para>
        <para>Of course, calling these functions – especially those which do KIM permission checks –
            can be computationally expensive. It is always better to check if masking has been
            turned on by checking the data dictionary attribute for the field first, like so:</para>
        <programlisting>&lt;c:if test="${!empty attributeEntry.attributeSecurityMask &amp;&amp; attributeEntry.attributeSecurityMask == true  }">
    &lt;c:set var="displayMask" value="${kfunc:canFullyUnmaskField(className, fieldName,KualiForm)? 'false' : 'true'}" />
&lt;/c:if></programlisting>
        <para>Alternatively, application developers can simply use the <emphasis role="bold"
                >kul:htmlControlAttribute</emphasis> tag – as is the recommended practice under any
            circumstance – to draw the field. <emphasis role="bold"
                >kul:htmlControlAttribute</emphasis> already utilizes the functions described above
            to make sure the field is properly masked, and as such represents the easiest way to
            apply masking to fields in transactional documents and screens.</para>
        <para>Further information about KIM permissions will be covered in KNS Authorizations. The
                <emphasis role="bold">kul:htmlControlAttribute</emphasis> tag will be covered in the
            section on Tag Libraries.</para>
    </sect1>
    <sect1>
        <title>KNS Authorization</title>
        <para>In most client applications, there’s going to be a need to guard certain end users
            from certain functionality. Certain documents may be locked down and only accessible to
            a small group of users. A tab on a certain document may only be visible based on if a
            System Parameter is turned on. KNS provides a standard way to turn on and off
            functionality based on conditions like these.</para>
        <para>There are two sides to this functionality. One side is that these authorizations are
            integrated with KIM. KNS provides a number of contexts where KIM permissions are called
            and checked, to see if the current user is permitted to perform the action. Examples of
            such actions are looking up business objects, initiating documents, adding notes to a
            document, using a screen, or viewing a field on an inquiry or a maintenance
            document.</para>
        <para>The other side is business logic associated with such authorizations. For instance,
            KIM permissions may be set up to allow any user of the client application to initiate a
            given document. However, there may be a business requirement that the document can only
            be initiated in the month of June. Since KIM permissions cannot capture that kind of
            logic, KNS provides point where programmers can create such logic.</para>
        <para>When building KNS documents, there are two classes associated with the document which
            make these authorizations: the Document Presentation Controller and the Document
            Authorizer.</para>
        <para>The Document Presentation Controller is where business logic authorizations are
            handled. These classes must implement the <emphasis role="bold"
                >org.kuali.rice.kns.document.authorization.DocumentPresentationController</emphasis>.
            There are also interfaces for MaintenanceDocumentPresentationController and
            TransactionalDocumentPresentationController, each tailored to their respective document
            families.</para>
        <para>The Document Authorizer is the class that does the KIM permission checks. Once again,
            there is an interface, <emphasis role="bold"
                >org.kuali.rice.kns.document.authorization.DocumentAuthorizer</emphasis>, which all
            document authorizers must implement, and it also has two sub-interfaces,
            MaintenanceDocumentAuthorizer and TransactionalDocumentAuthorizer.</para>
        <para>In cases where an authorization is checked by both presentation controller and
            authorizer, the presentation controller is called first, and then it’s result is somehow
            sent to the authorizer. For instance, DocumentPresentationController has a method,
                <emphasis role="bold">getActions()</emphasis>, which returns a Set of Strings, each
            representing a standard document action (for instance, the Route document action). That
            Set is then sent as an argument to the DocumentAuthorizer; the DocumentAuthorizer only
            performs KIM checks for the actions that have been handed to it.</para>
        <para>The classes for both the document authorizer and presentation controller are set in
            the document in the data dictionary. Here’s an example, from the sample travel
            application:</para>
        <programlisting>&lt;bean id="TravelRequest" parent="TravelRequest-parentBean"/>

&lt;bean id="TravelRequest-parentBean" abstract="true" parent="TransactionalDocumentEntry">
    &lt;property name="documentTypeName" value="TravelRequest"/>
    &lt;property name="documentClass" value="edu.sampleu.travel.document.TravelDocument2"/>
    &lt;property name="documentAuthorizerClass" value="edu.sampleu.travel.document.authorizer.TravelDocumentAuthorizer"/>
    &lt;property name="documentPresentationControllerClass" value="edu.sampleu.travel.document.authorizer.TravelDocumentPresentationController"/>
        ...
&lt;/bean></programlisting>
        <para>The classes for the authorizer is given to the documentAuthorizerClass property of the
            main document bean, and the presentation controller class is specified in the
            documentPresentationControllerClass property. This is the same for maintenance documents
            as well. Once these are specified, the proper classes will be constructed at
            authorization invocation contexts automatically.</para>
        <sect2>
            <title>Common Document Authorizations</title>
            <para>There are two authorizations which are common to all documents. In both cases, the
                document presentation controller is called and then the authorizer if needed.</para>
            <para>The first common authorization is the document initialization authorization.
                DocumentPresentationController has this method to be overridden for business logic
                about when a document can be initialized:</para>
            <programlisting>public boolean canInitiate(String documentTypeName);</programlisting>
            <para>The DocumentAuthorizer also has a:</para>
            <programlisting>public boolean canInitiate(String documentTypeName, Person user);</programlisting>
            <para>The DocumentAuthorizer checks the KR-SYS Initiate Document permission.</para>
            <para>The second common authorization is handled by
                DocumentPresentationController#getDocumentActions:</para>
            <programlisting>public Set&lt;String> getDocumentActions(Document document, Person user, Set&lt;String> documentActions);</programlisting>
            <para>It passes its result to DocumentAuthorizer#getDocumentActions:</para>
            <para>This authorization actually handles many common authorizations which need to be
                passed to the document presentation layer. The Set returned by the
                DocumentAuthorizer is converted into a Map, where each element in the Set becomes a
                key of the Map. That Map can then be accessed in any web page or tag through the
                    <emphasis role="bold">KualiForm.documentActions</emphasis> variable.</para>
            <para><emphasis role="bold"
                    >org.kuali.rice.kns.document.authorization.DocumentPresentationControllerBase</emphasis>
                defines a number of protected methods which are inquired when the Set returned by
                    <emphasis role="bold">getDocumentActions</emphasis> is built. Builders of client
                applications are far more likely to override one of those helper methods than
                override <emphasis role="bold">getDocumentActions</emphasis> from scratch.</para>
            <para>
                <table frame="none">
                    <title/>
                    <tgroup cols="3">
                        <colspec colname="c1" colnum="1" colwidth="1.0*"/>
                        <colspec colname="c2" colnum="2" colwidth="1.0*"/>
                        <colspec colname="c3" colnum="3" colwidth="1.0*"/>
                        <thead>
                            <row>
                                <entry>DocumentPresentationControllerBase method</entry>
                                <entry>Purpose</entry>
                                <entry>Related Authorizer Permission</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><emphasis role="bold">protected boolean canEdit(Document
                                        document)</emphasis></entry>
                                <entry>Determines if the document can be edited; if false is
                                    returned, then all fields are in a read only state</entry>
                                <entry>KR-NS Edit Document</entry>
                            </row>
                            <row>
                                <entry><emphasis role="bold">protected boolean canAnnotate(Document
                                        document)</emphasis></entry>
                                <entry>Determines if any ad hoc requests can be added to the
                                    document.</entry>
                                <entry/>
                            </row>
                            <row>
                                <entry><emphasis role="bold">protected boolean canReload(Document
                                        document)</emphasis></entry>
                                <entry>Determines if the document can be reloaded from the
                                    database.</entry>
                                <entry/>
                            </row>
                            <row>
                                <entry><emphasis role="bold">protected boolean canClose(Document
                                        document)</emphasis></entry>
                                <entry>Determines if the document can be closed, returning the end
                                    user to the portal.</entry>
                                <entry/>
                            </row>
                            <row>
                                <entry><emphasis role="bold">protected boolean canSave(Document
                                        document)</emphasis></entry>
                                <entry>Determines if the document can be saved.</entry>
                                <entry>KR-WKFLW Save Document</entry>
                            </row>
                            <row>
                                <entry><emphasis role="bold">protected boolean canRoute(Document
                                        document)</emphasis></entry>
                                <entry>Determines if the document can be routed to workflow.</entry>
                                <entry>KR-WKFLW Route Document</entry>
                            </row>
                            <row>
                                <entry><emphasis role="bold">protected boolean canCancel(Document
                                        document)</emphasis></entry>
                                <entry>Determines if the document can be canceled.</entry>
                                <entry>KR-WKFLW Cancel Document</entry>
                            </row>
                            <row>
                                <entry><emphasis role="bold">protected boolean canCopy(Document
                                        document)</emphasis></entry>
                                <entry>Determines if the document can be used as the template for a
                                    new document.</entry>
                                <entry>KR-NS Copy Document</entry>
                            </row>
                            <row>
                                <entry><emphasis role="bold">protected boolean
                                        canPerformRouteReport(Document document)</emphasis></entry>
                                <entry>Determines if the future requests workflow report can be
                                    viewed.</entry>
                                <entry/>
                            </row>
                            <row>
                                <entry><emphasis role="bold">protected boolean
                                        canAddAdhocRequests(Document document)</emphasis></entry>
                                <entry>Determines if the document can have ad hoc routing requests
                                    added to it.</entry>
                                <entry>KR-NS Send Ad Hoc Request</entry>
                            </row>
                            <row>
                                <entry><emphasis role="bold">protected boolean
                                        canBlanketApprove(Document document)</emphasis></entry>
                                <entry>Determines if the document can be blanket approved.</entry>
                                <entry>KR-WKFLW Blanket Approve Document</entry>
                            </row>
                            <row>
                                <entry><emphasis role="bold">protected boolean canApprove(Document
                                        document)</emphasis></entry>
                                <entry>Determines if the document can be approved.</entry>
                                <entry>KR-NS Take Requested Action</entry>
                            </row>
                            <row>
                                <entry><emphasis role="bold">protected boolean
                                        canDisapprove(Document document)</emphasis></entry>
                                <entry>Determines if the document can be disapproved.</entry>
                                <entry>KR-NS Take Requested Action</entry>
                            </row>
                            <row>
                                <entry><emphasis role="bold">protected boolean
                                        canSendAdhocRequests(Document document)</emphasis></entry>
                                <entry>Determines whether the document will be allowed to send
                                    itself to KEW to fulfill ad hoc requests.</entry>
                                <entry>KR-NS Send Ad Hoc Request</entry>
                            </row>
                            <row>
                                <entry><emphasis role="bold">protected boolean
                                        canSendNoteFyi(Document document)</emphasis></entry>
                                <entry>Sends an FYI to previous approvers if a note is
                                    added.</entry>
                                <entry>KR-NS Send Ad Hoc Request</entry>
                            </row>
                            <row>
                                <entry><emphasis role="bold">protected boolean
                                        canEditDocumentOverview(Document
                                    document)</emphasis></entry>
                                <entry>Determines if the fields in the document overview (title,
                                    etc) can be edited.</entry>
                                <entry>KR-NS Edit Document</entry>
                            </row>
                            <row>
                                <entry><emphasis role="bold">protected boolean canFyi(Document
                                        document)</emphasis></entry>
                                <entry>Determines if the document can be FYI’d.</entry>
                                <entry>KR-NS Take Requested Action</entry>
                            </row>
                            <row>
                                <entry><emphasis role="bold">protected boolean
                                        canAcknowledge(Document document)</emphasis></entry>
                                <entry>Determines if the document can be acknowledged.</entry>
                                <entry>KR-NS Take Requested Action</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>
            <para>DocumentAuthorizer also contains a number of methods which are not subject to
                document presentation controller input. These are:</para>
            <para>
                <table frame="none">
                    <title/>
                    <tgroup cols="3">
                        <colspec colname="c1" colnum="1" colwidth="1.0*"/>
                        <colspec colname="c2" colnum="2" colwidth="1.0*"/>
                        <colspec colname="c3" colnum="3" colwidth="1.0*"/>
                        <thead>
                            <row>
                                <entry>Document Authorizer method</entry>
                                <entry>Description</entry>
                                <entry>KIM Permission Checked</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><emphasis role="bold">public boolean canOpen(Document
                                        document, Person user);</emphasis></entry>
                                <entry>Determines if the current user can open the document</entry>
                                <entry>KR-NS Open Document</entry>
                            </row>
                            <row>
                                <entry><emphasis role="bold">public boolean canReceiveAdHoc(Document
                                        document, Person user, String
                                    actionRequestCode);</emphasis></entry>
                                <entry>Determines if the person, for whom there is a proposal to add
                                    an ad hoc routing request, can receive that ad hoc routing
                                    request</entry>
                                <entry>KR-WKFLW Ad Hoc Review Document</entry>
                            </row>
                            <row>
                                <entry><emphasis role="bold">public boolean
                                        canAddNoteAttachment(Document document, String
                                        attachmentTypeCode, Person user);</emphasis></entry>
                                <entry>Determines if the current user can add a note to the
                                    document.</entry>
                                <entry>KR-NS Add Note / Attachment</entry>
                            </row>
                            <row>
                                <entry><emphasis role="bold">public boolean
                                        canDeleteNoteAttachment(Document document, String
                                        attachmentTypeCode, String createdBySelfOnly, Person
                                        user);</emphasis></entry>
                                <entry>Determines if the current user can delete a note on a
                                    document.</entry>
                                <entry>KR-NS Delete Note / Attachment</entry>
                            </row>
                            <row>
                                <entry><emphasis role="bold">public boolean
                                        canViewNoteAttachment(Document document, String
                                        attachmentTypeCode, Person user);</emphasis></entry>
                                <entry>Determines if the current user can view a note on the
                                    document.</entry>
                                <entry>KR-NS View Note / Attachment</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>
        </sect2>
        <sect2>
            <title>Maintenance Document Authorizations</title>
            <para>A couple of authorizations are specific to maintenance documents. The document
                presentation controller and document authorizer diverge somewhat on which methods
                they support to control authorizations in documents, so each will be treated
                separately, save for the one method they do share.</para>
            <para>That one method is <emphasis role="bold">canCreate</emphasis>. Here is
                MaintenanceDocumentPresentationController’s declaration of the method:</para>
            <programlisting>public boolean canCreate(Class boClass);</programlisting>
            <para>It takes the class of the business object, of which the end user is attempting to
                create a new record of through a maintenance document. Business logic can be written
                to determine if new records of the given class can be created through a maintenance
                document.</para>
            <para>MaintenanceDocumentAuthorizerBase checks the KR-NS Create / Maintain Record(s) to
                see if a new business object of the type can be created for its corresponding
                check.</para>
            <para>MaintenanceDocumentPresentationController has two methods which do not have
            parallels in the MaintenanceDocumentAuthorizer. They are:</para>
            <programlisting>public Set&lt;String> getConditionallyReadOnlyPropertyNames(MaintenanceDocument document);

public Set&lt;String> getConditionallyReadOnlySectionIds(MaintenanceDocument document);</programlisting>
            <para>To understand this, recall that if there is a field on a maintenance document
                which is unconditionally read only, that is set within the data dictionary file for
                that maintenance document. Of course, it brings up the question of what to do if a
                field or a section is read only some times based on certain business logic and
                editable at others.</para>
            <para>The answer to this has been provided by the
                MaintenanceDocumentPresentationController. A Set of the property names of the fields
                or names of the sections which are, given the current condition of the
                MaintenanceDocument argument, currently read only is returned from the
                method.</para>
            <para>MaintenanceDocumentAuthorizer’s separate methods are similar to <emphasis
                    role="bold">canCreate</emphasis>. The first is <emphasis role="bold"
                    >canMaintain</emphasis>, which determines if the current user can edit an
                already existing business object. There is also <emphasis role="bold"
                    >canCreateOrMaintain</emphasis>, which combines the KIM permission checks when
                the document is routed to make sure the routing is valid.</para>
            <para>Finally, MaintenanceDocumentAuthorizer has a method:</para>
            <programlisting>public Set&lt;String> getSecurePotentiallyReadOnlySectionIds();</programlisting>
            <para>Unlike most methods in MaintenanceDocumentAuthorizer, this method was actually
                specified to be overridden. It returns a Set of the names of sections on a
                maintenance document which may be read only based on the user.</para>
            <sect3>
                <title>Maintenance Document/Inquiry Authorizations</title>
                <para>Because maintenance documents and inquiries are rendered using the same code,
                    authorizations which control that rendering are shared between the two. There
                    are two such permissions: KR-NS View Inquiry or Maintenance Document Field and
                    KR-NS View Inquiry or Maintenance Document Section. Since maintenance documents
                    allow editing in addition to viewing, there are two other permissions which
                    control the ability of end users to edit: KR-NS Modify Maintenance Document
                    Field and KR-NS Modify Maintenance Document Section.</para>
                <para>These are used only as KIM permissions, and they are invoked directly within
                    the rendering framework. Their purpose is as follows:<itemizedlist>
                        <listitem>
                            <para>KR-NS View Inquiry or Maintenance Document Section will only
                                render a whole tab section to those with the permission. </para>
                            <para>KR-NS Modify Maintenance Document Section will only allow edits
                                for a whole tab section to those with the permission; otherwise, the
                                fields within the section will be rendered as read only. </para>
                        </listitem>
                        <listitem>
                            <para>KR-NS View Inquiry or Maintenance Document Field will only render
                                a field to entities granted this permission. </para>
                        </listitem>
                        <listitem>
                            <para>KR-NS Modify Maintenance Document Field will only allow edits of a
                                field to entities granted this permission; the field will otherwise
                                be rendered as read only. </para>
                        </listitem>
                    </itemizedlist></para>
                <para>If no KIM permission is specified for a given section or field, it is assumed
                    that it is viewable on both the Inquiry and Maintenance Document and the field
                    will be editable on the Maintenance Document.</para>
                <para>There are no document presentation controller methods to override if the
                    ability to view or edit parts of an inquiry or maintenance document based on
                    business logic. If a client application has such a requirement, adventurous
                    technical personnel are invited to look at <emphasis role="bold"
                        >Maintainable#getRows</emphasis> and <emphasis role="bold"
                        >Inquirable#getRows</emphasis>. The subject is otherwise outside the scope
                    of this document.</para>
            </sect3>
        </sect2>
        <sect2>
            <title>Transactional Document Authorizations</title>
            <para>There is only one major authorization which is added to
                TransactionalDocumentPresentationController and TransactionalDocumentAuthorizer:
                    <emphasis role="bold">getEditModes</emphasis>. Much like <emphasis role="bold"
                    >DocumentPresentationController#getDocumentActions()</emphasis>, <emphasis
                    role="bold"
                    >TransactionalDocumentPresentationController#getEditModes()</emphasis> takes as
                an argument the document the authorization is being asked of and returns a Set of
                Strings.</para>
            <para>Unlike <emphasis role="bold"
                    >DocumentPresentationController#getDocumentActions()</emphasis>, though,
                    <emphasis role="bold"
                    >TransactionalDocumentPresentationController#getEditModes()</emphasis> does not
                have a set of standard actions it returns. Instead, it is designed specifically to
                allow any kind of action through the web presentation layer. There, the edit modes
                can be checked and acted upon in document specific ways.</para>
            <para>How is this helpful? In maintenance documents, since the KNS handles the rendering
                in a standard way, it is easy to turn sections on and off; KIM permissions or work
                through the maintainable can accomplish. In transactional documents in the other
                hand, rendering is more manual. However, <emphasis role="bold"
                    >getEditModes</emphasis> provides a way for the business logic layer to
                communicate information to the presentation layer.</para>
            <para>To get the presentation layer to not display a section, then, a presentation
            controller might be written as so:</para>
            <programlisting>public ExampleDocumentPresentationController extends TransactionalDocumentPresentationController {
    public Set&lt;String> getEditModes(Document document) {
        final ExampleDocument exampleDocument = (ExampleDocument)document;
        Set&lt;String> editModes = new HashSet&lt;String>();
        if (exampleDocument.dontShowExtraSection()) {
            editModes.add("NO_EXTRA_SECTION");
        }
		return editModes;
    }

}</programlisting>
            <para>Then, in Example.jsp, we may have code that looks like this:</para>
            <programlisting>&lt;c:if test="${!KualiForm.editingMode['NO_EXTRA_SECTION']}">
    &lt;kul:tab tabTitle="Extra Section" defaultOpen="true" tabErrorKey="${Constants.EXTRA_SECTION_ERRORS}">
        ...
    &lt;/kul:tab>

&lt;/c:if>
</programlisting>
            <para>Edit Modes also go through the document authorizer, meaning that there is a
                permission associated with them: KR-NS Use Transactional Document. Expected
                permission details are the document type and the name of edit mode (in this example,
                “NO_EXTRA_SECTION”).</para>
        </sect2>
        <sect2>
            <title>Other Authorizations</title>
            <para>Finally, there are two permissions which do not affect documents but only business
                objects. They are:<itemizedlist>
                    <listitem>
                        <para>KR-NS Look Up Records, which determines if records of the given type
                            can be looked up by the current user. Client applications seeking to
                            change this based on business logic would likely override the business
                            object’s implementation of <emphasis role="bold"
                                >org.kuali.rice.kns.lookup.LookupableHelperService#getRows()</emphasis>.
                        </para>
                    </listitem>
                    <listitem>
                        <para>KR-NS Inquire Into Records, which determines if the current user can
                            inquire into records of the given business object. Client applications
                            seeking to change this based on business logic would likely override the
                            business object’s implementation of <emphasis role="bold"
                                >org.kuali.rice.kns.lookup.LookupableHelperService#getInquiryUrl()</emphasis>
                            or its implementation of <emphasis role="bold"
                                >org.kuali.rice.kns.inquiry.Inquirable#getInquiryUrl(BusinessObject
                                businessObject, String attributeName, boolean
                                forceInquiry)</emphasis>, depending on the use case. </para>
                    </listitem>
                </itemizedlist></para>
        </sect2>
        <sect2>
            <title>Overriding Document Authorizers</title>
            <para>Document authorizers handle their calls to Kuali Identity Management in standard
                ways already. Because this side of authorizations mostly relies on KIM
                configuration, there is very little reason to override Document Authorizers. In
                fact, such overrides only occur to accommodate one of the two following
                situations.</para>
            <para>The first situation is when a client application-specific KIM permission which
                affects documents is invoked. In this case, it is a best practice to give developers
                the ability to change this logic through the document presentation controller, and
                then do the actual KIM permission call in the document authorizer. Document
                authorizers were designed to be standard permission invocation contexts, and using
                them as such makes development much easier.</para>
            <para>The second situation is to add extra attributes to permission detail attribute
                sets, role qualifier attribute sets, or to both. These extra attributes are sent on
                every KIM permission call performed by the authorizer. The reason for doing this is
                to make sure that permissions and roles can qualify properly when the document
                authorizer performs its call.</para>
            <para>For example, imagine a role where the users are qualified by a client application
                specific field. The document authorizer does not know where or how to gather the
                data for that field, and yet it must be sent to KIM for the role members to be
                resolved correctly. Therefore, the </para>
            <programlisting>protected void addRoleQualification(BusinessObject businessObject, Map&lt;String, String> attributes) </programlisting>
            <para>method should be overridden, and the attributes argument should be filled with
                values from the businessObject (which may well be a document) to make sure the role
                is resolved correctly.</para>
            <para>The same can be done for permission details:</para>
            <programlisting>protected void addPermissionDetails(BusinessObject businessObject, Map&lt;String, String> attributes)</programlisting>
            <para>Finally, if a certain attribute is used both in finding the permission via the
                permission details and resolving the role, then the following method should be
                overridden; it will add the attribute to both:</para>
            <programlisting>protected void addStandardAttributes(Document document, Map&lt;String, String> attributes)</programlisting>
        </sect2>
    </sect1>
    <sect1>
        <title>KNS Exception Handling and Incident Reporting</title>
        <para>Any complex Java system are subject to the occurrences of exceptions. From missed
            assignments which cause NullPointerExceptions to network issues which cause
            SQLExceptions be thrown, the unexpected happens—even in Rice applications.</para>
        <para>Because of this, Rice builds on top of Struts’ exception mechanism to provide an easy
            way for exceptions to be handled and for incidents to be reported to the proper
            maintenance group.</para>
        <para>When a developer creates a Rice application, there should be several struts-config.xml
            files created. The developer’s own struts-config.xml, of course, exists in
            {project_root}/src/main/webapp/WEB-INF. It will automatically be created with the
            following entry:</para>
        <programlisting>&lt;global-exceptions>
    &lt;exception type="java.lang.Throwable"
 handler="org.kuali.rice.kns.web.struts.pojo.StrutsExceptionIncidentHandler"
 key="meaningless" />
&lt;/global-exceptions></programlisting>
        <para>This tells Struts that if any exceptions—or even Errors for that matter!—reach the
            Struts request processor, then it is to redirect the application to the <emphasis
                role="bold"
                >org.kuali.rice.kns.web.struts.pojo.StrutsExceptionIncidentHandler</emphasis>. This
            handler, in turn, redirects to the following forward:</para>
        <programlisting>&lt;action path="/kualiExceptionIncidentReport"
 type="org.kuali.rice.kns.web.struts.action.KualiExceptionHandlerAction">
    &lt;forward name="basic" path="/kr/kualiExceptionIncidentReport.do" />
&lt;/action></programlisting>
        <para>This forward does a number of things. First, it sends the exception to <emphasis
                role="bold"
                >org.kuali.rice.kns.service.KualiExceptionIncidentService#getExceptionIncident</emphasis>
            to wrap the exception, and then reports the wrapped exception to <emphasis role="bold"
                >org.kuali.rice.kns.service.KualiExceptionIncidentService#report</emphasis>.</para>
        <para>In the default implementation, <emphasis role="bold"
                >org.kuali.rice.kns.service.KualiExceptionIncidentService#report</emphasis> emails
            the mailing list specified in the <emphasis role="bold"
                >KualiExceptionIncidentServiceImpl.REPORT_MAIL_LIST</emphasis> configuration
            parameter. The rest of the mail can be configured by overriding the service bean’s
            message template:</para>
        <programlisting>&lt;bean id="knsExceptionIncidentService" class="org.kuali.rice.kns.service.impl.KualiExceptionIncidentServiceImpl">
    &lt;property name="mailService">&lt;ref bean="mailService"/>&lt;/property>
    &lt;property name="messageTemplate">
        &lt;bean class="org.kuali.rice.kns.mail.MailMessage">
            &lt;!-- The property place holder below must be specified in common-config-default.xml or any other KNS configuration file -->
            &lt;property name="fromAddress">
                &lt;value>${kr.incident.mailing.list}&lt;/value>
            &lt;/property>
        &lt;/bean>
    &lt;/property>
&lt;/bean></programlisting>
        <para>Then the action redirects the user to the error page. In production environments, this
            page simply notes that an error occurred and that it had been reported to the system’s
            administrators. Helpfully, it also provides a text box so the user can describe the
            steps leading up to the incident. In development environments, this page also displays
            the top stack trace of the exception which occurred.</para>
        <para>With this reporting mechanism, incidents are properly reported and can be responded to
            and fixed.</para>
    </sect1>
    <sect1>
        <title>KNS System Parameters</title>
        <para>Often times, there are changes in functionality in a client application which
            functional users want to have control over without an undue technical burden. For
            instance, a certain set of documents may be associated with a bank; information about a
            bank is shown on the screen of each of the documents. If more documents are among those
            to show bank information, functional users would love it if they could just create one
            maintenance document and that change took effect. By coding with system parameters, such
            functionality is achievable within the KNS.</para>
        <para>A System Parameter is simply a business object which holds text. That text will be
            used in one of three standard ways: simply as text itself, as an indicator of whether
            certain logic should be performed or not; or to see if a value from logic falls within a
            certain set of values. The advantage of using System Parameters is that they are easily
            changed since a maintenance document already exists as part of the KNS for them.</para>
        <para>Parameters are used either for configuration, as described above, or for validation –
            for instance, if a field on a document can only have one of a certain number of values,
            and those values need to be changed by a functional user, then a System Parameter would
            be helpful.</para>
        <para>It should be noted that the maintenance of System Parameters is only authorized to
            those granted the KR-NS Maintain System Parameter KIM permission.</para>
        <sect2>
            <title>Getting text from a system parameter</title>
            <para>The data from a system parameter can be retrieved through the <emphasis
                    role="bold">ParameterService#getParameterValue</emphasis> method, using the
                parameter’s name to identify the parameter. The parameter’s name has three
                components: a namespace, a parameter detail type code, and a name field.</para>
            <para>The namespace matches a KNS module’s namespace code, typically the namespace code
                of the module which invokes the parameter. For instance, parameters called within
                the KNS itself use the base namespace code of “KR-NS”</para>
            <para>The name of the parameter should be unique within certain constraints: it must be
                unique with the namespace, the parameter detail type code, and, as will be covered
                below, the application namespace. This means that, for instance, if a client
                application is written with two modules, both modules could create a system
                parameter with the same name because they would have different namespace codes.
                Indeed, system parameters within the same module can be named the same thing if they
                have differing parameter detail type codes.</para>
            <para>The parameter detail type code is the most difficult to understand. To understand
                why, the method signature of <emphasis role="bold"
                    >ParameterService#getParameterValue</emphasis> must be investigated.</para>
            <programlisting>public String getParameterValue(Class&lt;? extends Object> componentClass, String parameterName);</programlisting>
            <para>Instead of a String namespaceCode and a String parameterDetailTypeCode, a Class is
                sent in. That class typically represents the class which will make use of this
                specific system parameter. From that class is determined both the namespace code and
                the parameter detail type code.</para>
            <para>Finding the namespace code is typically done by looking at the package prefixes in
                the module configuration. If a class needs to be in a different namespace, it can
                have the <emphasis role="bold"
                    >@org.kuali.rice.kns.service.ParameterConstants.NAMESPACE</emphasis> annotation
                can be used to specify something different.</para>
            <para>There is also an <emphasis role="bold"
                    >@org.kuali.rice.kns.service.ParameterConstants.COMPONENT</emphasis> annotation
                which can be used to specify a specific parameter detail type code. If that is
                missing, though, then an algorithm inspects the class to see what parameter detail
                type code is most appropriate:<itemizedlist>
                    <listitem>
                        <para>If the class represents a transactional class, then the parameter
                            detail type code will the sample name of the class with the trailing
                            expected “Document” removed. For instance, <emphasis role="bold"
                                >org.kuali.kfs.fp.document.DisbursementVoucherDocument</emphasis>
                            has a parameter detail type code of “DisbursementVoucher” </para>
                    </listitem>
                    <listitem>
                        <para>If the class represents a business object, then the parameter detail
                            type code will be the simple class name. Business object class
                            “org.kuali.kfs.fp.businessobject.PayeeDetail” will have a parameter
                            detail type code of “PayeeDetail” </para>
                    </listitem>
                    <listitem>
                        <para>Any other class will use the simple class name. This particular
                            behavior will eventually be deprecated. </para>
                    </listitem>
                </itemizedlist></para>
            <para>Based on these standards, it should be easy to tell what the parameter detail type
                code for a given parameter should be.</para>
            <para>The parameter’s value is then a simple lookup using the class making the call to
                ParameterService and the name of the parameter:</para>
            <programlisting>final String parameterValue = KNSLocator.getParameterService().getParameterValue(this.getClass(), "SIMPLE_VALUE");</programlisting>
            <para>The parameterValue can then be used for whatever purpose the business logic
                requires.</para>
        </sect2>
        <sect2>
            <title>Using an indicator parameter</title>
            <para>An indicator parameter’s text is either “Y” or “N”; invoking that parameter as an
                indicator parameter simply means that the text will be translated to its
                corresponding boolean value. It is accessed through <emphasis role="bold"
                    >ParameterService#getIndicatorParameter</emphasis>, which works much as
                    <emphasis role="bold">ParameterService#getParameterValue</emphasis> does:</para>
            <programlisting>if (KNSLocator.getParameterService().getParameterIndicator(this.getClass(), "EXECUTE_LOGIC_IND")) {
    // do something...
}
</programlisting>
        </sect2>
        <sect2>
            <title>Parameter Evaluators</title>
            <para>Using parameter text is fine if there is only one value in the text. However, very
                often a parameter may need to be associated with several pieces of text.</para>
            <para>For instance, the first example of the System Parameters section talked about
                having bank information applied to a collection of documents. It seems inefficient
                to create a bunch of indicator parameters for this. It would be better to create one
                parameter with a number of document types in the txt.</para>
            <para>This is easily done. The standard way is to list the document types in the text,
                separated by semi-colons as so: <emphasis role="bold"
                    >FirstDocumentType;SecondDocumentType;ThirdDocumentType</emphasis></para>
            <para>While that could be retrieved via the ParameterService#getParameterValue method
                and then split, there’s a much better way to examine the value: through the use of a
                parameter evaluator.</para>
            <para>ParameterEvaluators are simply objects which take values from the environment and
                see if they made the constraints of the parameter. It will do the parsing of the
                parameter itself and then attempt to match that against an input value:</para>
            <programlisting>KNSServiceLocator.getParameterService().getParameterEvaluator(ParameterConstants.NERVOUS_SYSTEM_DOCUMENT, “BANK_DOCUMENT_TYPES”, document.getDocumentType()).evaluationSucceeds();</programlisting>
            <para>This looks at the KR-NS / Document / BANK_DOCUMENT_TYPES parameter, splits its
                semi-colon valued, and then matches <emphasis role="bold"
                    >document.getDocumentType()</emphasis> against each of the values returned from
                the split.</para>
            <para>The constraint code of the system parameter, mentioned earlier, is invoked at this
                point. <emphasis role="bold">evaluationSucceeds()</emphasis> will return true if
                document.getDocumentType() is within the values in the parameter and the parameter
                constraint code is “A” (“allow”). If, on the other hand, the constraint code is “D”
                (“deny”) and the document type is matched in the parameter’s values, a false will be
                returned – the document type sent in is denied by the parameter.</para>
            <para>(Parameter accessed through <emphasis role="bold">getParameterValue()</emphasis>
                and <emphasis role="bold">getIndicatorParameter()</emphasis> should simply set their
                constraint code to “A”).</para>
            <para>System parameters used for validation can add errors if the evaluation fails
            through the parameter value:</para>
            <programlisting>KNSServiceLocator.getParameterService().getParameterEvaluator(ParameterConstants.NERVOUS_SYSTEM_DOCUMENT, “VALID_DOCUMENT_TYPES”, document.getDocumentType()).evaluateAndAddError(document.getClass(), “errorPropertyName”, “error.invalid.document.type.message”);</programlisting>
            <para>In this example, if the value of <emphasis role="bold"
                    >document.getDocumentType()</emphasis> does not match the values in the
                parameter, an error will automatically be added to <emphasis role="bold"
                    >errorPropertyName</emphasis> on the document, and the user message with the key
                of <emphasis role="bold">error.invalid.document.type.message</emphasis> will be
                shown. Once against, the system parameter’s constraint code is used to determine if
                the value succeeds or not.</para>
            <para>The parameter evaluator can handle more complex situations as well. Take an
                example where a validation needs to check that, if a business object has a certain
                “dispersementCode”, then a child business object has a specific “reimbursementCode”.
                In this case, the system parameter’s value might look like this: <emphasis
                    role="bold">A=Z</emphasis></para>
            <para>This means that if the dispursementCode of the parent is A, then the
                reimbursementCode of the parent must be Z. This parameter can be used with the
                semi-colon to form a list: <emphasis role="bold">A=Z;B=X;C=K</emphasis></para>
            <para>The ParameterEvaluator call is again straightforward:</para>
            <programlisting>if (KNSServiceLocator.getParameterService().getParameterEvaluator(this.getClass(), "PARENT_CHILD_MATCH", parent.getDisbursementCode(), child.getReimbursementCode().evaluationSuceeds()) {
    // do something...
}
</programlisting>
            <para>Here, getParameterEvalutor is given the parameter class, the name of the
                parameter, the code of the parent and then the code of the child, but works as
                ParameterEvaluator worked before.</para>
            <para>What if the parent’s disbursementCode allowed two different reimbursementCode’s?
                Then the parameter’s text would look like this: <emphasis role="bold"
                    >A=Z,Y;B=X,Y;C=K,J,L</emphasis></para>
            <para>Commas separate the child’s distinct values. The invocation of the parameter
                evaluator is precisely the same as the call above:</para>
            <para><emphasis role="bold">ParameterService#getParameterValues()</emphasis> can return
                a parsed version of a multiple value parameter, and there is a version of <emphasis
                    role="bold">ParameterService#getParameterValue()</emphasis> which takes in a
                constrained value for parameters in the form of “A=B”; if given the value “A”, it
                will simply return “B”.</para>
        </sect2>
        <sect2>
            <title>Calling missing System Parameters</title>
            <para>All of the methods which use a parameter’s value – <emphasis role="bold"
                    >ParameterService#getParameterValue</emphasis>, <emphasis role="bold"
                    >ParameterService#getIndicatorParameter</emphasis>, and <emphasis role="bold"
                    >ParameterService#getParameterEvaluator</emphasis> – will throw an exception if
                the system parameter with the specified name cannot be found. If there is an
                expectation in the code that a parameter may not be found in the database, then it
                is advisable to call <emphasis role="bold"
                    >ParameterService#parameterExists</emphasis> method first. If the method returns
                true, then it is safe to use any of the methods above to utilize the parameter’s
                value.</para>
            <para>This is often useful in cases where there is a parameter that is different from
                document to document, but for which there exists a default fallback case. It would
                work like this:</para>
            <programlisting>final ParameterService parameterService = KNSLocator.getParameterService();
if (parameterService.parameterExists(document.getClass(), "EXAMPLE_VALUE")) {
    return parameterService.getParameterValue(document.getClass(), "EXAMPLE_VALUE");
} else {
    return parameterService.getParameterValue(ParameterConstants.NERVOUS_SYSTEM_DOCUMENT, "EXAMPLE_VALUE");
}
</programlisting>
            <para>In this example, <emphasis role="bold">ParameterService#parameterExists</emphasis>
                is called to see if there’s a parameter named “EXAMPLE_VALUE” with the namespace and
                parameter detail code of “document”. If that exists, then it returns the value of
                that parameter. If it does not exist, it uses the more general KR-NS / Document /
                EXAMPLE_VALUE parameter.</para>
        </sect2>
        <sect2>
            <title>Overriding Rice Parameters</title>
            <para>Rice comes with a number of system parameters which affect KIM, the KNS, and KEW.
                They have namespace codes “KR-IDM”, “KR-NS”, and “KR-WKFLW” respectively. These
                provide defaults for Rice behavior which occurs in sample applications.</para>
            <para>This poses a problem. If a client application is built to be used with a
                standalone Rice server, then each client application would have to share the
                defaults set in these system parameters. To allow client applications to have the
                ability to set these Rice system parameters separately from other client
                applications in a shared Rice server, the application namespace code field was
                added.</para>
            <para>For instance, Rice applications come with a system parameter KR-NS / All /
                DEFAULT_COUNTRY which lists the default country code used in the application. If,
                for some reason, a client application needed a separate DEFAULT_COUNTRY, a new
                system parameter would need to be created through the maintenance document. The
                existing system parameter and the new system parameter would differ only in their
                values and in their application namespace codes.</para>
            <para>All Rice system parameters come with the default Rice application namespace code
                of “KUALI”. If the client application’s version of the KR-NS / All / DEFAULT_COUNTRY
                had an application namespace code matching that of the app.namespace configuration
                property of the client application, then that would be used before the KR-NS / All /
                DEFAULT_COUNTRY parameter with the “KUALI” application namespace.</para>
        </sect2>
    </sect1>
<!-- TODO: Section was in original Word Document as 'Topic Coming Soon'
    <sect1>
        <title>KNS Help Framework</title>
    </sect1>
-->
    <sect1>
        <title>Building Screens using the KNS Tag Libraries</title>
        <para>The Kuali Nervous System handles the rendering of several pieces of standard
            functionality: maintenance documents, inquiry pages, and lookups. However, that leaves
            two pieces of functionality where writing JSP is required: on transactional documents
            and on non-document screens. However, even though JSP coding is required in these cases,
            the KNS still provides a wealth of rendering functionality through the use of tag
            libraries.</para>
        <para>This section examines several categories of the most used tags that are provided by
        the KNS.</para>
        <sect2>
            <title>Implicit Variables</title>
            <para>The KNS provides a number of implicit variables which can be used in the context
                of JSP pages. These variables exist to give the web layer the ability to read
                variables from the other KNS layers.</para>
            <para>For instance, the variable Constants is used to give web layer developers access
                to <emphasis role="bold">org.kuali.rice.kns.util.KNSConstants</emphasis>, as
                so:</para>
            <programlisting>&lt;c:if test="${KualiForm.documentActions[Constants.KUALI_ACTION_CAN_EDIT]}">
    Howdy, end user!  You can edit this page!
&lt;/c:if></programlisting>
            <para>Client applications often overload this variable to hold not only KNS constants
                but application specific constants as well. There is also a <emphasis role="bold"
                    >RiceConstants</emphasis> variable which holds the constants in <emphasis
                    role="bold">org.kuali.rice.core.util.RiceConstants</emphasis>, a <emphasis
                    role="bold">KEWConstants</emphasis> which holds all of the constants in
                    <emphasis role="bold">org.kuali.rice.kew.util.KEWConstants</emphasis>, and a
                    <emphasis role="bold">PropertyConstants</emphasis> which holds the values in
                    <emphasis role="bold"
                >org.kuali.rice.kns.util.KNSPropertyConstants</emphasis>.</para>
            <para>All configuration properties are loaded into a variable <emphasis role="bold"
                    >ConfigProperties</emphasis></para>
            <programlisting>&lt;p>
application namespace is &lt;c:out value="${ConfigProperties['config.namespace']}" />
&lt;/p></programlisting>
            <para>The entirety of the data dictionary as also exposed in the map constant <emphasis
                    role="bold">DataDictionary</emphasis>. The keys for this map are either the
                simple class name of a business object:</para>
            <programlisting>&lt;c:set var="countryBODataDictionaryEntry" value="${DataDictionary['CountryImpl']}" /></programlisting>
            <para>Or, for documents, the KEW document type name:</para>
            <programlisting>&lt;c:set var="identityManagementPersonDocumentEntry" value="${DataDictionary['IdentityManagementPersonDocument']}" /></programlisting>
            <para>Data dictionary values can then be accessed via JSP EL.</para>
            <para>The final implicit variable to mention is <emphasis role="bold"
                    >KualiForm</emphasis>. This is the Struts form for the current page. For JSP
                pages supporting transactional documents, values from the document can be read
                through <emphasis role="bold">KualiForm</emphasis>. As such, this implicit variable
                is practically the most used.</para>
            <para>These implicit variables work together to support the various tags the KNS
                provides.</para>
        </sect2>
        <sect2>
            <title>Tags for Layout</title>
            <para>KNS applications have a standard look, and client application developers will want
                to preserve that look. KNS layout tags provide an easy way to use the KNS look and
                feel.</para>
            <para>First of all, JSP pages using tag libraries need to have <emphasis role="bold"
                    >@taglib</emphasis> directives added to the page:</para>
            <para>The KNS tag library is typically imported with the kul: prefix:</para>
            <para>Thankfully, a collection of common JSTL, Struts, and Rice tags are readily
                imported using a single import at the top of any custom developed JSP page:</para>
            <para>Having done that, the developer can use the <emphasis role="bold"
                    >kul:page</emphasis> tag to draw the main outline of the page, such as in this
                example, from KFS’s Format Disbursements page (<emphasis role="bold"
                    >formatselection.jsp</emphasis>):</para>
            <para>The <emphasis role="bold">kul:page</emphasis> simply draws the frame around the
                page. It has two required attributes: the <emphasis role="bold">docTitle</emphasis>,
                which is the title it will use for the page in the gray bar which runs along the
                top, and the <emphasis role="bold">transactionalDocument</emphasis> attribute, which
                should only be true if the JSP page is supporting a transactional document.</para>
            <para>This example uses a number of other attributes as well. The <emphasis role="bold"
                    >headerTitle</emphasis> is what will show in the browser’s title bar. <emphasis
                    role="bold">showDocumentInfo</emphasis> will treat the page as a document page
                and will attempt to, for instance, show a link for document type. The <emphasis
                    role="bold">errorKey</emphasis> is the key for errors which should be associated
                with the top level of the page (in this case, it likely should have been neglected).
                Finally, the <emphasis role="bold">htmlFormAction</emphasis> is the url to the
                action that the form within the page – every page is assumed to have HTML form data,
                so an HTML form variable is constructed for it – should post to.</para>
            <para>There’s also a convenience tag that encapsulates the <emphasis role="bold"
                    >kul:page</emphasis> with all of the attributes needed for documents turned on:
                the aptly named <emphasis role="bold">kul:documentPage</emphasis>, exemplified here
                from the sample travel app:</para>
            <para>The only required attribute here is <emphasis role="bold"
                    >documentTypeName</emphasis>; the <emphasis role="bold">docTitle</emphasis> will
                display the label from the data dictionary entry associated with this document, and
                the value for the <emphasis role="bold">transactionalDocument</emphasis> attribute
                will also be determined from the data dictionary entry. All other attributes will
                simply be passed along to the<emphasis role="bold"> kul:page</emphasis> tag.</para>
            <para>The <emphasis role="bold">kul:documentPage</emphasis> tag makes sure that not only
                is the document title splashed across at the top of the page with a light gray,
                scrubbed looking background graphic, but also shows common read-only document
                information: document number, KEW workflow status, initiator, and when the document
                was created.</para>
            <para>The next most distinctive visual feature of KNS pages are the tabs which visually
                organize related information (through headers, it organizes the information for
                sight disabled end users as well). The KNS provides a main tag to draw these: not
                surprisingly, it’s the <emphasis role="bold">kul:tab</emphasis> tag.</para>
            <para>Here is an example of the tag, again from <emphasis role="bold"
                    >travelDocument2.jsp</emphasis>, which is part of the sample travel
                application:</para>
            <para>There is only one required attribute for the tab: <emphasis role="bold"
                    >defaultOpen</emphasis>, which declares whether the tab should be initially
                rendered as open or closed (all tabs can be opened or closed once rendered).
                However, this example gives us a number of other useful attributes as well.
                    <emphasis role="bold">tabTitle</emphasis> is the name that will appear in the
                tab; while not required, best practice suggests that developers provide one so the
                tab have a label even when closed. <emphasis role="bold">tabErrorKey</emphasis>
                lists the keys that will be associated with this tab; when those errors are
                rendered, their messages will be associated with the given tab.</para>
            <para>Another thing to notice in the example was the inclusion of a <emphasis
                    role="bold">div</emphasis> with class “<emphasis role="bold"
                    >tab-container</emphasis>”. In practice, practically all KNS tabs have such a
                tab included. This leads to the natural question of why the tab is not part of the
                tag itself.</para>
            <para>The <emphasis role="bold">div</emphasis> with a class of “<emphasis role="bold"
                    >h2-container</emphasis>” draws a header stripe at the top of the tab, with a
                black background and white text. This distinctive visual element should be used to
                mark off sub-sections of the tab.</para>
            <para>There is also a <emphasis role="bold">kul:subtab</emphasis>. This visually
                provides an in-set tab, typically set off with a stripe that has a gray background
                and bolded black text. KIM’s Identity Management Person Document, has such an
                example. It includes the tag <emphasis role="bold">personContact.tag</emphasis>,
                which builds a tab:</para>
            <para>This splits the various sub-sections into distinctive visual elements.</para>
            <para>The only required attribute for the tag is width, which specifies the width of the
                sub-element <emphasis role="bold">(kul:subtab</emphasis>’s are sometimes shorter
                than their surrounding tab – while they are always rendered with some padding, the
                amount of padding and thus the amount of visual separation can be increased as width
                is decreased). </para>
            <para>Sub tabs often have titles, specified through the <emphasis role="bold"
                    >subTabTitle</emphasis> attribute. Whereas all tabs have hide/show buttons, they
                can be turned off from sub tabs through the use of the <emphasis role="bold"
                    >noShowHideButton</emphasis> attribute.</para>
            <para>Finally, sub tabs are often associated with lookups, they have two attributes,
                    <emphasis role="bold">lookedUpBODisplayName</emphasis> and <emphasis role="bold"
                    >lookedUpCollectionName</emphasis>, which allow results of lookups to be
                displayed in the sub tab itself.</para>
            <para>Astute readers will have noticed an important visual point about tabs: the tab is
                rendered with the tab title in an offset visual element (like the tab in a file
                folder) and behind it is the gray background of the tab above. However, the top tab
                does not have a tab above it. Therefore, for that special top tab, there is a
                    <emphasis role="bold">kul:tabTop</emphasis> which is identical to the <emphasis
                    role="bold">kul:tab</emphasis> tag, save that it visually looks like the top
                tab. Also, to round off the bottom tab, there is a tag, <emphasis role="bold"
                    >kul:panelFooter</emphasis>, which takes no attributes, which will round off the
                bottom corners of the set of tabs.</para>
            <para>It should be noted that for documents, general practice is that the top tab
                provides the standard set of fields that all KNS documents have: the document
                description, which is a required field, as well as a text area for the document
                explanation and an internal Org Doc #. Since this is standard, the KNS provides a
                tag, <emphasis role="bold">kul:documentOverview</emphasis>, which displays these
                fields and which is commonly the top tab of the document (thus obviating the need
                for the developer to use the <emphasis role="bold">kul:tabTop</emphasis>
                tag).</para>
            <para>Practically all documents will share this line of code as the top tab. The
                    <emphasis role="bold">editingMode</emphasis> attribute is required, but will
                practically always be the value of <emphasis role="bold"
                    >KualiForm.editingMode</emphasis>.</para>
            <para>Armed with these visual layout tags, client application developers are ready to
                start filling in pages with form controls.</para>
        </sect2>
        <sect2>
            <title>Tags for Controls</title>
            <para>Certainly, controls can be hard coded in JSP files as HTML. However, the KNS
                provides several tags which provide standard functionality to controls – thus
                preserving the flexibility of declaring control information in the data dictionary
                as well as supporting masking, accessibility, and a number of other concerns without
                the application developer needing to concern with those details.</para>
            <para>The basic tag for showing a field is kul:htmlControlAttribute. Dozens of examples
                can be found in even the simplest Rice client application. Here is the tag being
                used in travelDocument2.jsp in the Rice sample travel application:</para>
            <programlisting>&lt;table width="100%" border="0" cellpadding="0" cellspacing="0" class="datatable">
    &lt;tr>
        &lt;kul:htmlAttributeHeaderCell labelFor="document.traveler" attributeEntry="${travelAttributes.traveler}" align="left" />
        &lt;td>&lt;kul:htmlControlAttribute property="document.traveler" attributeEntry="${travelAttributes.traveler}" readOnly="${readOnly}" />&lt;/td>
    &lt;/tr>
    &lt;tr>
        &lt;kul:htmlAttributeHeaderCell labelFor="document.origin" attributeEntry="${travelAttributes.origin}" align="left" />
        &lt;td>&lt;kul:htmlControlAttribute property="document.origin" attributeEntry="${travelAttributes.origin}" readOnly="${readOnly}" />&lt;/td>
    &lt;/tr>
    ...
&lt;/table>
</programlisting>
            <para>This example has two controls which will appear on the form: one for <emphasis
                    role="bold">document.traveler</emphasis> and one for <emphasis role="bold"
                    >document.origin</emphasis>. This is set via the property attribute; that
                attribute is required. Also required is the <emphasis role="bold"
                    >attributeEntry</emphasis> attribute, which takes in the DataDictionary
                attribute entry for the attribute that is being displayed:</para>
            <programlisting>&lt;c:set var="travelAttributes" value="${DataDictionary.TravelRequest.attributes}" /></programlisting>
            <para>There are also many optional attributes. One is seen in both examples above:
                    <emphasis role="bold">readOnly</emphasis>, which determines if the field will
                simply have a read only version of its value displayed, or a control will be
                displayed. This attribute allows a lot of flexibility about when a field will be
                    <emphasis role="bold">readOnly</emphasis> or not. Typically, though, <emphasis
                    role="bold">readOnly</emphasis> is determined based on the whether there’s an
                action “can edit” in the form’s <emphasis role="bold">documentActions</emphasis>
                map:</para>
            <programlisting>&lt;c:set var="readOnly" value="${!KualiForm.documentActions[Constants.KUALI_ACTION_CAN_EDIT]}" /></programlisting>
            <para>As covered earlier, masking is handled automatically if the field is read only. If
                the value of the property should not be displayed at all, the attribute <emphasis
                    role="bold">readOnlyBody</emphasis> can be set to true and the value of the
                tag’s body is displayed if the control attribute is rendered read only.</para>
            <para>Among the other optional attributes are html attributes which are applied directly
                to the drawn control, such as <emphasis role="bold">onblur</emphasis>, <emphasis
                    role="bold">onclick</emphasis>, and <emphasis role="bold">onchange</emphasis>.
                There is a <emphasis role="bold">styleClass</emphasis>, which is where a CSS class
                can be specified to render the value or control in.</para>
            <para>Note that the type of control is not specified here. The data dictionary entry
                will be referred to, and that control definition will used to determine which
                control will be rendered. Select controls will use a values finder to find the
                values to display in the drop down. This means that controls can be changed without
                altering the JSP, which is a major strength.</para>
            <para>The only exception to be aware of is that if a text control document contains a
                date, there is an attribute, <emphasis role="bold">datePicker</emphasis>, should be
                set to true.</para>
            <para>Also in the example, the tag <emphasis role="bold"
                    >kul:htmlAttributeHeaderCell</emphasis> is used. It displays the label for the
                field in a &lt;td> cell. There aren’t officially any required attributes, though one
                of the following three would have a value set: <emphasis role="bold"
                    >attributeEntry</emphasis>, <emphasis role="bold">attributeEntryName</emphasis>,
                and <emphasis role="bold">literalLabel</emphasis>. <emphasis role="bold"
                    >literalLabel</emphasis> will force the header cell to simply display the given
                String. <emphasis role="bold">attributeEntry</emphasis>, on the other hand, will use
                a data dictionary attribute to find an appropriate label; it needs to be handed the
                proper label much as the <emphasis role="bold">kul:htmlControlAttribute</emphasis>
                uses. <emphasis role="bold">attributeEntryName</emphasis> takes the full name of a
                data dictionary attribute (such as “<emphasis role="bold"
                    >DataDictionary.TravelRequest.attributes.origin</emphasis>”). The label will
                come from the data dictionary, though the tag will do all of the lookup
                itself.</para>
            <para>There are a number of other attributes exist which control how the html of the
                &lt;td> tag will render. <emphasis role="bold">width</emphasis>, <emphasis
                    role="bold">rowspan</emphasis>, <emphasis role="bold">colspan</emphasis>,
                    <emphasis role="bold">align</emphasis>, and <emphasis role="bold"
                    >labelFor</emphasis>, as well as several others exist to customize the look of
                the tag.</para>
            <para>What if a label is being rendered outside a table? For that, there is a <emphasis
                    role="bold">kul:htmlAttributeLabel</emphasis> tag. It allows <emphasis
                    role="bold">attributeEntry</emphasis> and <emphasis role="bold"
                    >attributeEntryName</emphasis> attributes which work just as they do in
                    <emphasis role="bold">kul:htmlAttributeHeaderCell</emphasis>. <emphasis
                    role="bold">literalLabel</emphasis> is not supported (since it is assumed that a
                literal label would simply be written into the JSP).</para>
            <para>This too has a number of other attributes. Developers should consider three of
                these attributes. <emphasis role="bold">useShortLabel</emphasis> uses the short
                label in the data dictionary attribute instead of the regular label. <emphasis
                    role="bold">noColon</emphasis> is a boolean. If it is set to true, then there
                will not be a colon rendered after the label. Finally, <emphasis role="bold"
                    >forceRequired</emphasis> means that a symbol will let end users know that the
                field is required.</para>
            <para>There is also a convenience tag which belongs on every JSP page supporting a
                transactional tag, right after the <emphasis role="bold">kul:documentPage</emphasis>
                tag: <emphasis role="bold">kul:hiddenDocumentFields</emphasis>. Here is its use in
                travelDocument2.jsp:</para>
            <programlisting>&lt;kul:documentPage showDocumentInfo="true" htmlFormAction="travelDocument2"
 documentTypeName="TravelRequest" renderMultipart="true" showTabButtons="true" auditCount="0">
&lt;kul:hiddenDocumentFields />
</programlisting>
            <para>This will make sure that the <emphasis role="bold">docId</emphasis> and <emphasis
                    role="bold">document.documetNumber </emphasis>will be preserved to repopulate
                the form after an action occurs on the document by creating HTML hidden controls to
                carry the values through the POST. </para>
            <para>There are two optional attributes, used to ask for the saving of more variables.
                If <emphasis role="bold">includeDocumentHeaderFields</emphasis> has a value of true,
                it will make sure that <emphasis role="bold"
                    >document.documentHeader.documentNumber</emphasis> is saved. Setting <emphasis
                    role="bold">includeEditMode</emphasis> will preserve the edit modes determined
                for the document.</para>
            <para>Finally, <emphasis role="bold">kul:errors</emphasis> should be mentioned. As
                previously seen, errors are typically associated with pages and tabs via <emphasis
                    role="bold">errorKeys</emphasis>. If an error should show up not associated with
                a page or a tab but rather with some other visual element, then the <emphasis
                    role="bold">kul:errors</emphasis> tab can display those.</para>
            <para>There are no required attributes. If only the errors with a certain set of keys
                should be displayed, then the <emphasis role="bold">keyMatch</emphasis> attribute
                should be set. Otherwise, all remaining messages will be rendered. Forcing the
                rendering of all remaining messages can be forced by setting the <emphasis
                    role="bold">displayRemaining</emphasis> attribute to true. An <emphasis
                    role="bold">errorTitle</emphasis>, <emphasis role="bold"
                >warningTitle</emphasis>, and <emphasis role="bold">infoTitle</emphasis> can also be
                set to separate the message sections. Defaults are provided if these attributes are
                not set.</para>
        </sect2>
        <sect2>
            <title>Tags for KNS Functionality</title>
            <para>Developers of transactional documents or screens will often want to hook into KNS
                functionality, such as inquiries and lookups. A set of tags makes this easily
                accomplished.</para>
            <para>For instance, in Rice client applications, many controls have a question mark icon
                next to them, which allows the user to do a lookup and return the value into the
                control. To get one of those to display, the <emphasis role="bold">kul:lookup
                    tag</emphasis> must be utilized, precisely as it is on <emphasis role="bold"
                    >travelRequest2.jsp</emphasis>:</para>
            <programlisting>&lt;kul:htmlControlAttribute property="travelAccount.number" attributeEntry="${accountAttributes.number}" readOnly="${readOnly}" />
&lt;kul:lookup boClassName="edu.sampleu.travel.bo.TravelAccount" fieldConversions="number:travelAccount.number" />
&lt;kul:directInquiry boClassName="edu.sampleu.travel.bo.TravelAccount" inquiryParameters="travelAccount.number:number" /></programlisting>
            <para>Right after the <emphasis role="bold">travelAccount.number</emphasis> control is
                rendered, the <emphasis role="bold">kul:lookup</emphasis> tag will render the
                question mark lookup icon. </para>
            <para>It takes the class of the business object it will perform a lookup against through
                the required <emphasis role="bold">boClassName</emphasis> attribute. The <emphasis
                    role="bold">fieldConversions</emphasis> attribute is not strictly required but
                often used: it is a list of attributes from the result business object matched by a
                colon with the field that it should populate in the document upon return. <emphasis
                    role="bold">kul:lookup</emphasis> also has support for a <emphasis role="bold"
                    >lookupParameters</emphasis> tag, which will populate the lookup with values
                from the document. There are a number of other optional attributes as well.</para>
            <para>Also in this example is the kul:directInquiry tag. If the travelAccount.number
                field is filled in, then clicking the directInquiry tag will open up an inquiry page
                for the value given.</para>
            <para>It, too, needs the class of the business object it is inquiring on through the
                required <emphasis role="bold">boClassName</emphasis> attribute. The non-required
                    <emphasis role="bold">inquiryParameter</emphasis> attribute tells the tag which
                values to take from the document to use as keys for the inquiry page.</para>
            <para>What if the value is read only and an inquiry should be displayed? In that case,
                the <emphasis role="bold">kul:inquiry</emphasis> tag should be used. Here is an
                example from the KFS <emphasis role="bold"
                    >procurementCardTransactions.tag</emphasis>:</para>
            <programlisting>&lt;kul:inquiry boClassName="org.kuali.kfs.fp.businessobject.ProcurementCardTransactionDetail" keyValues="documentNumber=${currentTransaction.documentNumber}&amp;financialDocumentTransactionLineNumber=${currentTransaction.financialDocumentTransactionLineNumber}" render="true">
    &lt;bean:write name="KualiForm" property="document.transactionEntries[${ctr}].transactionReferenceNumber" />

&lt;/kul:inquiry></programlisting>
            <para>The <emphasis role="bold">kul:inquiry</emphasis> works much like the &lt;a> tag it
                renders. Any text within the body of the tag is rendered as the text for the link.
                It, too, requires the <emphasis role="bold">boClassName</emphasis> attribute which
                specifies which business object will be rendered on. </para>
            <para>It also requires two other attributes, <emphasis role="bold">keyValues</emphasis>
                and <emphasis role="bold">render</emphasis>. <emphasis role="bold">render</emphasis>
                is an odd attribute. It decides whether the inquiry link will be rendered or not.
                This allows some display level logic to check whether the field should actually be
                rendered on. If render is false, then only the text of the tag’s body will be
                rendered.</para>
            <para><emphasis role="bold">keyValues</emphasis> hands in the query string to pass to
                the inquiry page, theoretically with the keys the inquiry page will need to find the
                record to display.</para>
            <para><emphasis role="bold">kul:inquiry</emphasis> has no optional attributes.</para>
            <para>A variation of the <emphasis role="bold">kul:lookup</emphasis> tag also exists,
                which supports multiple value lookups, <emphasis role="bold"
                    >kul:multipleValueLookup</emphasis>. Here is an example from KC’s
                awardKeywords.tag:</para>
            <programlisting>&lt;kul:multipleValueLookup boClassName="org.kuali.kra.bo.ScienceKeyword" lookedUpCollectionName="keywords" anchor="${tabKey}"/></programlisting>
            <para>Once again, <emphasis role="bold">boClassName</emphasis> of the business object
                class to be looked up is a required attribute. Also required is the <emphasis
                    role="bold">lookedUpCollectionName</emphasis> attribute. Once the multiple
                values are returned from the lookup, the KNS will attempt to populate the named
                collection on the document with the values.</para>
            <para>In this example, <emphasis role="bold">anchor</emphasis> is an optional attribute.
                It gives the link to return to an anchor to navigate to when it returns to the page.
                This is helpful on long pages. There is also an attribute <emphasis role="bold"
                    >lookedUpBODisplayName</emphasis> which will control the label for the business
                object being looked up.</para>
            <para>Last, but by no means least, among these tags is the reliable kul:documentControls
                tag. Every JSP supporting a transactional document will include this tag, as it
                draws the row of controls on the very bottom of the page, thereby allowing end users
                to route, save, approve, cancel, and otherwise work with the document.
                travelRequest2.jsp uses it:</para>
            <programlisting>&lt;kul:panelFooter />
&lt;kul:documentControls transactionalDocument="false" /></programlisting>
            <para>Properly utilized this control appears just beneath the kul:panelFooter. The only
                required attribute is the <emphasis role="bold">transactionalDocument</emphasis>
                attribute, though, ironically, that attribute is never used within the tag. It
                therefore does not matter if false or true is entered as the value.</para>
            <para>The other main attributes to be aware of support adding extra buttons. There are
                two mechanisms. In the first, by specifying the <emphasis role="bold"
                    >extraButtonSource</emphasis>, <emphasis role="bold"
                    >extraButtonProperty</emphasis>, and <emphasis role="bold"
                    >extraButtonAlt</emphasis> attributes, a single extra button will be rendered.
                For the image source, it will use <emphasis role="bold"
                >extraButtonSource</emphasis>, with the alternate text specified by <emphasis
                    role="bold">extraButtonAlt</emphasis>. The <emphasis role="bold"
                    >extraButtonProperty</emphasis> specifies the property of action to call (for
                instance, the property of the route button is “<emphasis role="bold"
                    >methodToCall.route</emphasis>”).</para>
            <para>That’s fine for one extra button, but what if multiple extra buttons need to be
                added? The KNS supports this as well. <emphasis role="bold"
                    >org.kuali.rice.kns.web.struts.form.KualiForm</emphasis> has a List property
                named <emphasis role="bold">extraButtons</emphasis>. The List is made up of
                    <emphasis role="bold">org.kuali.rice.kns.web.ui.ExtraButton</emphasis> objects.
                Each <emphasis role="bold">ExtraButton</emphasis> object, in turn, has an <emphasis
                    role="bold">extraButtonProperty</emphasis>, <emphasis role="bold"
                    >extraButtonSource</emphasis>, and <emphasis role="bold"
                    >extraButtonAltText</emphasis> properties which can be set. Those properties
                have the same effect as the <emphasis role="bold">extraButtonSource</emphasis>,
                    <emphasis role="bold">extraButtonProperty</emphasis>, and <emphasis role="bold"
                    >extraButtonAlt</emphasis> attributes covered above. <emphasis role="bold"
                    >ExtraButton</emphasis> objects have two extra properties as well: <emphasis
                    role="bold">extraButtonParams</emphasis> and <emphasis role="bold"
                    >extraButtonOnclick</emphasis> which provide the ability to hand extra
                parameters to the action and the ability for javascript to react to the button click
                respectively.</para>
            <para>The form can have its <emphasis role="bold">extraButtons</emphasis> list populated
                before reaching the presentation layer. Most often, this is accomplished by simply
                overriding the form’s <emphasis role="bold">getExtraButtons()</emphasis> method.
                Then the extra buttons are simply sent from the form into the <emphasis role="bold"
                    >kul:documentControls</emphasis> tag, as so:</para>
            <programlisting>&lt;kul:documentControls transactionalDocument="false" extraButtons="${KualiForm.extraButtons}" /></programlisting>
            <para>The <emphasis role="bold">kul:documentControls</emphasis> tag will then render all
                of the extra buttons. Given its extra flexibility, this is the preferred method of
                adding extra buttons.</para>
        </sect2>
        <sect2>
            <title>Useful Pre-Created Tabs</title>
            <para>Finally, the KNS provides a number of tabs that happen to exist on most
                documents.</para>
            <para>For instance, practically every document has the ability to add notes. If that
                functionality is to be turned off, it’s much easier to do in the data dictionary –
                so frankly, every document should have a place to enter notes. Documents should also
                have the route log of the document, and a place where ad hoc KEW recipients can be
                added. The KNS makes adding all of these tabs easy:</para>
            <programlisting>&lt;kul:notes />
&lt;kul:adHocRecipients />
&lt;kul:routeLog /></programlisting>
            <para>The names of the tags are self-explanatory; and as easy as that, these three
                standard tabs have been added to the document.</para>
        </sect2>
    </sect1>
</chapter>