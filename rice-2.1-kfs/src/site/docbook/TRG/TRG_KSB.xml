<?xml version="1.0" encoding="UTF-8"?>
<!--

    Copyright 2005-2012 The Kuali Foundation

    Licensed under the Educational Community License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.opensource.org/licenses/ecl2.php

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->
<chapter version="5.0" xml:id="TRG_KSB" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:ns5="http://www.w3.org/1999/xhtml"
         xmlns:ns4="http://www.w3.org/2000/svg"
         xmlns:ns3="http://www.w3.org/1998/Math/MathML"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>KSB</title>

  <sect1>
    <title>How to Use the KSB</title>

    <sect2>
      <title>Introduction</title>

      <para>The Kuali Service Bus (KSB) is a lightweight service bus designed
      to allow developers to quickly develop and deploy services for remote
      and local consumption. You can deploy services to the bus using Spring
      or programmatically. Services must be named when they are deployed to
      the bus. Services are acquired from the bus using their name.</para>

      <para>At the heart of the KSB is a service registry. This registry is a
      listing of all services available for consumption on the bus. The
      registry provides the bus with the information necessary to achieve load
      balancing, failover and more.</para>
    </sect2>

    <sect2>
      <title>Bean Based Services</title>

      <para>Typically, KSB programming is centered on exposing
      Spring-configured beans to other calling code using a number of
      different protocols. Using this paradigm the client developer and the
      organization can rapidly build and consume services, often a daunting
      challenge using other buses.</para>

      <figure>
        <title>Overview of Supported Service Protocols</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="../images/supported_service_protocols2.png"/>
          </imageobject>
        </mediaobject>
      </figure>
    </sect2>

    <sect2>
      <title>Diagram Notes</title>

      <para>This drawing is conceptual and not representative of a true
      deployment architecture. Essentially, the KSB is a registry with service
      calling behavior on the client end (Java client). All policies and
      behaviors (Asynchronous as opposed to Synchronous) are coordinated on
      the client. The client offers some very attractive messaging features:
      <itemizedlist>
          <listitem>
            <para><emphasis role="bold">Synchronization</emphasis> of message
            sending with currently running transaction (meaning all messages
            sent during a transaction are ONLY sent if the transaction is
            successfully committed)</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">Failover</emphasis> - If a call to a
            service comes back with a 404 (or various other network-related
            errors), it will try to call other services of the same name on
            the bus. This is for both sync and async calls.</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">Load balancing</emphasis> - Clients
            will round-robin call services of the same name on the bus. Proxy
            instances, however, are bound to single machines if you want to
            keep a line of communication open to a single machine for long
            periods of time.</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">Topics and Queues</emphasis></para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">Persistent messages</emphasis> - When
            using message persistence a message cannot be lost. It will be
            persisted until it is sent.</para>
          </listitem>
        </itemizedlist></para>
    </sect2>
  </sect1>

  <sect1>
    <title>Details of Supported Service Protocols</title>

    <sect2>
      <title>Java Rice Client</title>

      <sect3>
        <title>As Consumer</title>

        <para>If configured for the KSB, a Java Rice Client can invoke any
        service in the KSB Registry using these protocols:<orderedlist>
            <listitem>
              <para>Synchronously <itemizedlist>
                  <listitem>
                    <para>SOAP WS p2p using KSB Spring configuration</para>
                  </listitem>

                  <listitem>
                    <para>Java call if it is within the same JVM</para>
                  </listitem>

                  <listitem>
                    <para>Spring HTTP Remoting</para>
                  </listitem>
                </itemizedlist></para>
            </listitem>

            <listitem>
              <para>Asynchronously <itemizedlist>
                  <listitem>
                    <para>Messaging Queues – As a Consumer, a Java Rice Client
                    can invoke a one-shot deal for calling a KSB-registered
                    service asynchronously</para>
                  </listitem>

                  <listitem>
                    <para>Java, SOAP, Spring HTTP Remoting</para>
                  </listitem>

                  <listitem>
                    <para>Messaging Topics - As a Consumer listening to a
                    topic, the Java Rice Client will receive a broadcast
                    message</para>
                  </listitem>
                </itemizedlist></para>
            </listitem>
          </orderedlist></para>
      </sect3>

      <sect3>
        <title>As Producer</title>

        <para>You can register Spring-defined services in the KSB Registry
        through the KSB Configurer. Consumers can call these services as
        described in other sections.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Any Java Client</title>

      <sect3>
        <title>As Consumer</title>

        <para>A <emphasis role="bold">Java Client</emphasis>, regardless of
        whether or not it's a Rice Client configured for the KSB, can invoke
        any web service:<orderedlist>
            <listitem>
              <para>As a SOAP WS p2p using a straight-up WS call through CXF,
              Axis, etc. If the external web service is not registered on the
              KSB, the Java client must discover the service on its
              own.</para>
            </listitem>

            <listitem>
              <para>Through Java if they are within the same JVM</para>
            </listitem>

            <listitem>
              <para>Through Spring HTTP Remoting; you must know the endpoint
              URL of the service.</para>
            </listitem>
          </orderedlist></para>
      </sect3>

      <sect3>
        <title>As Producer</title>

        <orderedlist>
          <listitem>
            <para>Currently, you can't leverage the KSB and its registry for
            exposing any of its services. It is possible to bring up the
            registry and register services without the rest of the KSB.</para>
          </listitem>

          <listitem>
            <para>A Java Client can expose its web services directly using
            XFire (CXF), Axis, etc.</para>
          </listitem>

          <listitem>
            <para>You can bring up only the registry for discovery. However,
            the registry can't be a 'service;' it can only be a piece of code
            talking to a database.</para>
          </listitem>
        </orderedlist>
      </sect3>
    </sect2>

    <sect2>
      <title>Non-Java/Non-Rice Client</title>

      <sect3>
        <title>As Consumer</title>

        <para>A <emphasis role="bold">non-Java/non-Rice Client</emphasis> that
        knows nothing about the KSB or its registry can only invoke web
        services synchronously using:<itemizedlist>
            <listitem>
              <para>SOAP WS p2p using straight-up WS call through native
              language-specific WS libs</para>
            </listitem>

            <listitem>
              <para>Discovery cannot be handled by leveraging the KSB Registry
              at this time.</para>
            </listitem>
          </itemizedlist></para>
      </sect3>

      <sect3>
        <title>As Producer</title>

        <orderedlist>
          <listitem>
            <para>Currently cannot register services on KSB in registry</para>
          </listitem>

          <listitem>
            <para>Can still produce services, but they can’t be called
            leveraging the KSB; clients need to discover and invoke the
            services directly (on their own).</para>
          </listitem>
        </orderedlist>
      </sect3>
    </sect2>

    <sect2>
      <title>KSB Registry as a Service</title>

      <para>As of the 2.0 version of Rice, the ServiceRegistry is now itself a
      service. In order to bring the registry online for the client
      application, the application needs to configure a URL similar to the
      following:</para>

      <programlisting>&lt;param name="rice.ksb.registry.serviceUrl"&gt;http://localhost:8080/kr-dev/remoting/serviceRegistrySoap&lt;/param&gt;</programlisting>

      <para>Currently, this connector is only configured to understand a SOAP
      interface to the service registry which is secured by digital
      signatures. This is the only type of interface to the registry that the
      standalone server currently publishes. Additionally, only a single URL
      to the registry can be configured at the current time. If someone wants
      to do load balancing amongst potential registry endpoints, then a
      hardware or software load balancer could be configured to do
      this.</para>
    </sect2>

    <sect2>
      <para/>
    </sect2>
  </sect1>

  <sect1>
    <title>Configuring the KSB Client in Spring</title>

    <sect2>
      <title>Overview</title>

      <para>The Kuali Service Bus (KSB) is installed as a Kuali Rice (Rice)
      Module using Spring. Here is an example XML snippet showing how to
      configure Rice and KSB using Spring:</para>

      <programlisting>&lt;beans&gt;
  ...
  &lt;bean id="coreConfigurer" class="org.kuali.rice.core.impl.config.module.CoreConfigurer"&gt;
    &lt;property name="dataSource" ref="riceDataSource${connection.pool.impl}" /&gt;
    &lt;property name="nonTransactionalDataSource" ref="riceNonTransactionalDataSource" /&gt;
    &lt;property name="transactionManager" ref="transactionManager${connection.pool.impl}" /&gt;
    &lt;property name="userTransaction" ref="jtaUserTransaction" /&gt;
  &lt;/bean&gt;

  &lt;bean id="ksbConfigurer" class="org.kuali.rice.ksb.messaging.config.KSBConfigurer"/&gt;
&lt;/beans&gt;</programlisting>
    </sect2>

    <sect2>
      <title>Spring Property Configuration</title>

      <para>The <emphasis role="italic">KSBTestHarnessSpring.xml</emphasis>
      located in the project folder under /ksb/src/test/resources/ is a good
      starting place to explore KSB configuration in depth. The first thing
      the file does is use a PropertyPlaceholderConfigurer to bring tokens
      into the Spring file for runtime configuration. The source of the tokens
      is the xml file: ksb-test-config.xml located in the
      /ksb/src/test/resources/META-INF directory.</para>

      <programlisting>&lt;bean id="config" class="org.kuali.rice.core.config.spring.ConfigFactoryBean"&gt;
    &lt;property name="configLocations"&gt;
        &lt;list&gt;
            &lt;value&gt;classpath:META-INF/ksb-test-config.xml&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;


&lt;bean class="org.springframework.beans.factory.config.MethodInvokingFactoryBean"&gt;
    &lt;property name="staticMethod" value="org.kuali.rice.core.impl.config.property.ConfigInitializer.initialize"/&gt;
    &lt;property name="arguments"&gt;
        &lt;list&gt;
            &lt;ref bean="config"/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;


&lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;
    &lt;property name="properties" value="#{config.getProperties()}" /&gt;
&lt;/bean&gt;</programlisting>

      <note>
        <para><itemizedlist>
            <listitem>
              <para>Properties are passed into the Rice configurer directly.
              These could be props loaded from Spring and injected into the
              bean directly.</para>
            </listitem>

            <listitem>
              <para>You could use the Rice configuration subsystem for
              configuration.</para>
            </listitem>

            <listitem>
              <para>A JTA TransactionManager and UserTransaction are also
              being injected into the CoreConfigurer.</para>
            </listitem>
          </itemizedlist></para>
      </note>

      <para>As mentioned above, this allows tokens to be used in the Spring
      file. If you are not familiar with tokens, they look like this in the
      Spring file: ${datasource.pool.maxSize}</para>

      <para>Let's take a look at the ksb-test-config.xml file:</para>

      <programlisting>&lt;config&gt;
    &lt;param name="config.location"&gt;classpath:META-INF/common-derby-connection-config.xml&lt;/param&gt;
    &lt;param name="config.location"&gt;classpath:META-INF/common-config-test-locations.xml&lt;/param&gt;
    &lt;param name="client1.location"&gt;${basedir}/src/test/clients/TestClient1&lt;/param&gt;
    &lt;param name="client2.location"&gt;${basedir}/src/test/clients/TestClient2&lt;/param&gt;
    &lt;param name="ksb.client1.port"&gt;9913&lt;/param&gt;
    &lt;param name="ksb.client2.port"&gt;9914&lt;/param&gt;
    &lt;param name="ksb.testharness.port"&gt;9915&lt;/param&gt;
    &lt;param name="threadPool.size"&gt;1&lt;/param&gt;
    &lt;param name="threadPool.fetchFrequency"&gt;3000&lt;/param&gt;
    &lt;param name="bus.refresh.rate"&gt;3000&lt;/param&gt;
    &lt;param name="bam.enabled"&gt;true&lt;/param&gt;
    &lt;param name="transaction.timeout"&gt;3600&lt;/param&gt;
    &lt;param name="keystore.alias"&gt;rice&lt;param&gt;
    &lt;param name="keystore.password"&gt;keystorepass&lt;/param&gt;
    &lt;param name="keystore.file"&gt;${basedir}/src/test/resources/keystore/ricekeystore&lt;/param&gt;
    &lt;param name="keystore.location"&gt;${basedir}/src/test/resources/keystore/ricekeystore&lt;/param&gt;
    &lt;param name="use.clearDatabaseLifecycle"&gt;true&lt;/param&gt;
    &lt;param name="use.sqlDataLoaderLifecycle"&gt;true&lt;/param&gt;
    &lt;!-- bus messaging props --&gt;
    &lt;param name="message.delivery"&gt;synchronous&lt;/param&gt;
    &lt;param name="message.persistence"&gt;true&lt;/param&gt;
    &lt;param name="useQuartzDatabase"&gt;false&lt;/param&gt;
    &lt;param name="config.location"&gt;${additional.config.locations}&lt;/param&gt;
    &lt;param name="config.location"&gt;${alt.config.location}&lt;/param&gt;
&lt;/config&gt;</programlisting>

      <para>This is an XML file for configuring key value pairs. When used in
      conjunction with Spring tokenization and the
      PropertyPlaceHolderConfigurer bean, the parameter name must be equal to
      the key value in the Spring file so that the properties propagate
      successfully.</para>
    </sect2>

    <sect2>
      <title>Spring JTA Configuration</title>

      <para>When doing persistent messaging it is best practice to use JTA as
      your transaction manager. This ensures that the messages you are sending
      are synchronized with the current executed transaction in your
      application. It also allows message persistence to be put in a different
      database than the application’s logic if needed. Currently, <emphasis
      role="italic">KSBTestHarnessSpring.xml</emphasis> uses JOTM to configure
      JTA without an application server. Bitronix is another JTA product that
      could be used in Rice and you could consider using it instead of JOTM.
      Below is the bean definition for JOTM that you can find in
      Spring:</para>

      <programlisting>&lt;bean id="jotm" class="org.springframework.transaction.jta.JotmFactoryBean"&gt;
    &lt;property name="defaultTimeout" value="${transaction.timeout}"/&gt;

&lt;/bean&gt;
&lt;bean id="dataSource" class="org.kuali.rice.database.XAPoolDataSource"&gt;
    &lt;property name="transactionManager" ref="jotm" /&gt;
    &lt;property name="driverClassName" value="${datasource.driver.name}" /&gt;
    &lt;property name="url" value="${datasource.url}" /&gt;
    &lt;property name="maxSize" value="${datasource.pool.maxSize}" /&gt;
    &lt;property name="minSize" value="${datasource.pool.minSize}" /&gt;
    &lt;property name="maxWait" value="${datasource.pool.maxWait}" /&gt;
    &lt;property name="validationQuery" value="${datasource.pool.validationQuery}" /&gt;
    &lt;property name="username" value="${datasource.username}" /&gt;
    &lt;property name="password" value="${datasource.password}" /&gt;

&lt;/bean&gt;</programlisting>

      <para>Bittronix’s configuration is similar. Datasources for both are set
      up in org.kuali.rice.core.RiceDataSourceSpringBeans.xml. If using JOTM,
      use the Rice XAPoolDataSource class as your data source because it
      addresses some bugs in the StandardXAPoolDataSource, which extends from
      this class.</para>
    </sect2>

    <sect2>
      <title>Put JTA and the Rice Config object in the CoreConfigurer</title>

      <para>Next, you must inject the JOTM into the RiceConfigurer:</para>

      <programlisting>&lt;bean id="rice" class="org.kuali.rice.core.impl.config.module.CoreConfigurer"&gt;
    &lt;property name="dataSource" ref="dataSource" /&gt;
    &lt;property name="transactionManager" ref="jotm" /&gt;
    &lt;property name="userTransaction" ref="jotm" /&gt;  
&lt;...more.../&gt;</programlisting>

      <para>Configuring JTA from an appserver is no different, except the
      TransactionManager and UserTransaction are going to be fetched using a
      JNDI FactoryBean from Spring.</para>

      <note>
        <para>You set the serviceNamespace property in the example above by
        injecting the name into the RiceConfigurer. You can do this instead of
        setting the property in the configuration system.</para>
      </note>
    </sect2>

    <sect2>
      <title>Configuring KSB without JTA</title>

      <para>You can configure KSB by injecting a PlatformTransactionManager
      into the KSBConfigurer. <itemizedlist>
          <listitem>
            <para>This eliminates the need for JTA. Behind the scenes, KSB
            uses Apache's OJB as its Object Relational Mapping.</para>
          </listitem>

          <listitem>
            <para>Before you can use PlatformTransactionManager, you must have
            a client application set up the OJB so that KSB can use it.</para>
          </listitem>
        </itemizedlist></para>

      <para>This is a good option if you are an OJB shop and you want to
      continue using your current setup without introducing JTA into your
      stack. Normally, when a JTA transaction is found, the message is not
      sent until the transaction commits. In this case, the message is sent
      immediately.</para>

      <para>Let's take a look at the <emphasis
      role="italic">KSBTestHarnessNoJtaSpring.xml</emphasis> file. Instead of
      JTA, the following transaction and DataSource configuration is
      declared:</para>

      <programlisting>&lt;bean id="ojbConfigurer" class="org.springmodules.orm.ojb.support.LocalOjbConfigurer" /&gt;


&lt;bean id="transactionManager" class="org.springmodules.orm.ojb.PersistenceBrokerTransactionManager"&gt;
    &lt;property name="jcdAlias" value="dataSource" /&gt;
&lt;/bean&gt;


&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;
    &lt;property name="driverClassName"&gt;
        &lt;value&gt;${datasource.driver.name}&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="url"&gt;
        &lt;value&gt;${datasource.url}&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="username"&gt;
        &lt;value&gt;${datasource.username}&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="password"&gt;
        &lt;value&gt;${datasource.password}&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>

      <para>The RiceNoJtaOJB.properties file needs to include the Rice
      connection factory property value:</para>

      <programlisting>ConnectionFactoryClass=org.kuali.rice.core.framework.persistence.ojb.RiceDataSourceConnectionFactory</programlisting>

      <para>Often, the DataSource is pulled from JNDI using a Spring
      FactoryBean. Next, we inject the DataSource and transactionManager (now
      a Spring PlatformTransactionManager).</para>

      <programlisting>&lt;bean id="rice" class="org.kuali.rice.core.impl.config.module.CoreConfigurer"&gt;
    &lt;property name="dataSource" ref="dataSource" /&gt;
    &lt;property name="nonTransactionalDataSource" ref="dataSource" /&gt;
    ...
&lt;/bean


&lt;bean id="ksbConfigurer" class="org.kuali.rice.ksb.messaging.config.KSBConfigurer"&gt;
    &lt;property name="platformTransactionManager" ref="transactionManager" /&gt;
    &lt;... more .../&gt;
&lt;/bean&gt;</programlisting>

      <para>Notice that the transactionManager is injected into the
      KSBConfigurer directly. This is because only KSB, and not Rice, supports
      this type of configuration. The DataSource is injected normally. When
      doing this, the OJB setup is entirely in the hands of the client
      application. That doesn't mean anything more than providing an
      OJB.properties object at the root of the classpath so OJB can load
      itself. KSB will automatically register its mappings with OJB, so they
      don't need to be included in the repository.xml file.</para>
    </sect2>

    <sect2>
      <title>web.xml Configuration</title>

      <para>To allow external bus clients to invoke services on the
      bus-connected node, you must configure the KSBDispatcherServlet in the
      web applications web.xml file. For example:</para>

      <programlisting>&lt;servlet&gt;
    &lt;servlet-name&gt;remoting&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.kuali.rice.ksb.messaging.servlet.KSBDispatcherServlet&lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;

&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;remoting&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/remoting/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</programlisting>

      <para>This allows bus-exposed services to be accessed at a URL like
      <emphasis
      role="bold">http://yourlocalip:8080/myapp/remoting/[KSB:service
      name]</emphasis>. Notice how this URL corresponds to the configured
      <emphasis role="bold">serviceServletUrl</emphasis> property on the
      KSBConfigurer.</para>
    </sect2>

    <sect2>
      <title>Configuration Parameters</title>

      <para>The service bus leverages the Rice configuration system for its
      configuration. Here is a comprehensive set of configuration parameters
      that you can use to configure the Kuali Service Bus:</para>

      <para><table frame="none">
          <title>KSB Configuration Parameters</title>

          <tgroup cols="3">
            <colspec colname="c1" colnum="1" colwidth="1.0*"/>

            <colspec colname="c2" colnum="2" colwidth="1.0*"/>

            <colspec colname="c3" colnum="3" colwidth="1.0*"/>

            <thead>
              <row>
                <entry>Parameter</entry>

                <entry>Required</entry>

                <entry>Default Value</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>bam.enabled</entry>

                <entry>Whether Business Action Messaging is enabled</entry>

                <entry>false</entry>
              </row>

              <row>
                <entry>bus.refresh.rate</entry>

                <entry>How often the service bus will update the services it
                has deployed in minutes.</entry>

                <entry>60</entry>
              </row>

              <row>
                <entry>dev.mode</entry>

                <entry>no</entry>

                <entry>false</entry>
              </row>

              <row>
                <entry>message.persistence</entry>

                <entry>no</entry>

                <entry>true</entry>
              </row>

              <row>
                <entry>message.delivery</entry>

                <entry>no</entry>

                <entry>asynch</entry>
              </row>

              <row>
                <entry>message.off</entry>

                <entry>no</entry>

                <entry>false</entry>
              </row>

              <row>
                <entry>ksb.mode</entry>

                <entry>The mode that KSB will run in; choices are "local",
                "embedded", or "remote".</entry>

                <entry>LOCAL</entry>
              </row>

              <row>
                <entry>ksb.url</entry>

                <entry>The base URL of KSB services and pages.</entry>

                <entry>${application.url}/ksb</entry>
              </row>

              <row>
                <entry>RouteQueue.maxRetryAttempts</entry>

                <entry>no</entry>

                <entry>5</entry>
              </row>

              <row>
                <entry>RouteQueue.timeIncrement</entry>

                <entry>no</entry>

                <entry>5000</entry>
              </row>

              <row>
                <entry>Routing.ImmediateExceptionRouting</entry>

                <entry>no</entry>

                <entry>false</entry>
              </row>

              <row>
                <entry>RouteQueue.maxRetryAttemptsOverride</entry>

                <entry>no</entry>

                <entry>None</entry>
              </row>

              <row>
                <entry>rice.ksb.batch.mode</entry>

                <entry>A service bus mode suitable for running batch jobs; it,
                like the KSB dev mode, runs only local services.</entry>

                <entry>false</entry>
              </row>

              <row>
                <entry>rice.ksb.struts.config.files</entry>

                <entry>The struts-config.xml configuration file that the KSB
                portion of the Rice application will use.</entry>

                <entry>/ksb/WEB-INF/struts-config.xml</entry>
              </row>

              <row>
                <entry>rice.ksb.web.forceEnable</entry>

                <entry>no</entry>

                <entry>false</entry>
              </row>

              <row>
                <entry>threadPool.size</entry>

                <entry>The size of the KSB thread pool.</entry>

                <entry>5</entry>
              </row>

              <row>
                <entry>useQuartzDatabase</entry>

                <entry>no</entry>

                <entry>true</entry>
              </row>

              <row>
                <entry>ksb.org.quartz.*</entry>

                <entry>no</entry>

                <entry>None</entry>
              </row>

              <row>
                <entry>rice.ksb.config.allowSelfSignedSSL</entry>

                <entry>no</entry>

                <entry>false</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>

      <sect3>
        <title>dev.mode</title>

        <para>Indicates whether this node should export and consume services
        from the entire service bus. If set to true, then the machine will not
        register its services in the global service registry. Instead, it can
        only consume services that it has available locally. In addition to
        this, other nodes on the service bus will not be able to "see" this
        node and will therefore not forward any messages to it.</para>
      </sect3>

      <sect3>
        <title>message.persistence</title>

        <para>If <emphasis role="italic">true</emphasis>, then messages will
        be persisted to the datastore. Otherwise, they will only be stored in
        memory. If message persistence is not turned on and the server is
        shutdown while there are still messages that need to be sent, those
        messages will be lost. For a production environment, it is recommended
        that you set message.persistence to <emphasis
        role="italic">true</emphasis>.</para>
      </sect3>

      <sect3>
        <title>message.delivery</title>

        <para>Can be set to either <emphasis
        role="italic">synchronous</emphasis> or <emphasis
        role="italic">asynchronous</emphasis>. If this is set to synchronous,
        then messages that are sent in an asynchronous fashion using the KSB
        API will instead be sent synchronously. This is useful in certain
        development and unit testing scenarios. For a production environment,
        it is recommended that you set message delivery to <emphasis
        role="italic">asynchronous</emphasis>.</para>

        <note>
          <para>It is strongly recommended that you set <emphasis
          role="bold">message.delivery</emphasis> to <emphasis
          role="italic">asynchronous</emphasis> for all cases except for when
          implementing automated tests or short-lived programs that interact
          with the service bus.</para>
        </note>
      </sect3>

      <sect3>
        <title>message.off</title>

        <para>If set to true, then asynchronous messages will not be sent. In
        the case that message persistence is turned on, they will be persisted
        in the message store and can even be picked up later using the Message
        Fetcher. However, if message persistence is turned off, these messages
        will be lost. This can be useful in certain debugging or testing
        scenarios.</para>
      </sect3>

      <sect3>
        <title>RouteQueue.maxRetryAttempts</title>

        <para>Sets the default number of retries that will be executed if a
        message fails to be sent. You can also customize this retry count for
        a specific service (see Exposing Services on the Bus).</para>
      </sect3>

      <sect3>
        <title>RouteQueue.timeIncrement</title>

        <para>Sets the default time increment between retry attempts. As with
        RouteQueue.maxRetryAttempts, you can also configure this at the
        service level.</para>
      </sect3>

      <sect3>
        <title>Routing.ImmediateExceptionRouting</title>

        <para>If set to <emphasis role="italic">true</emphasis>, then messages
        that fail to be sent will not be retried. Instead, their
        MessageExceptionHandler will be invoked immediately.</para>
      </sect3>

      <sect3>
        <title>RouteQueue.maxRetryAttemptsOverride</title>

        <para>If set with a number, it will temporarily set the retry attempts
        for ALL services going into exception routing. You can set the number
        arbitrarily high to prevent all messages in a node from making it to
        exception routing if they are having trouble. The message.off param
        produces the same result.</para>
      </sect3>

      <sect3>
        <title>useQuartzDatabase</title>

        <para>When using the embedded Quartz scheduler started by the KSB,
        indicates whether that Quartz scheduler should store its entries in
        the database. If this is true, then the appropriate Quartz properties
        should be set as well. (See ksb.org.quartz.* below).</para>
      </sect3>

      <sect3>
        <title>ksb.org.quartz.*</title>

        <para>Can be used to pass Quartz properties to the embedded Quartz
        scheduler. See the configuration documentation on the <link
        xlink:href="http://www.quartz-scheduler.org/">Quartz site</link>.
        Essentially, any property prefixed with <emphasis
        role="italic">ksb.org.quartz</emphasis>. will have the "ksb." portion
        stripped and will be sent as configuration parameters to the embedded
        Quartz scheduler.</para>
      </sect3>

      <sect3>
        <title>rice.ksb.config.allowSelfSignedSSL</title>

        <para>If <emphasis role="italic">true</emphasis>, then the bus will
        allow communication using the <emphasis role="bold">https</emphasis>
        protocol between machines with self-signed certificates. By default,
        this is not permitted and if attempted you will receive an error
        message like this:</para>

        <note>
          <para>It is best practice to only set this to 'true' in
          non-production environments!</para>
        </note>
      </sect3>

      <sect3>
        <title>rice.ksb.web.forceEnable</title>

        <para>publish the KSB user interface components (such as the Message
        Queue, Thread Pool, Service Registry screens) even when the ksb.mode
        is not set to <emphasis role="italic">local</emphasis>.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>KSBConfigurer Properties</title>

      <para>In addition to the configuration parameters that you can specify
      using the Rice configuration system, the KSBConfigurer bean itself has
      some properties that can be injected in order to configure it:</para>

      <sect3>
        <title>exceptionMessagingScheduler</title>

        <para>By default, KSB uses an embedded Quartz scheduler for scheduling
        the retry of messages that fail to be sent. If desired, a Quartz
        scheduler can instead be injected into the KSBConfigurer and it will
        use that scheduler instead. See Quartz Scheduling for more
        detail.</para>
      </sect3>

      <sect3>
        <title>messageDataSource</title>

        <para>Specifies the javax.sql.DataSource to use for storing the
        asynchronous message queue. If not specified, this defaults to the
        DataSource injected into the RiceConfigurer.</para>

        <para>If this DataSource is injected, then the registryDataSource must
        also be injected and vice-versa.</para>
      </sect3>

      <sect3>
        <title>nonTransactionalMessageDataSource</title>

        <para>Specifies the javax.sql.DataSource to use that matches the
        messageDataSource property. This datasource instance must not be
        transactional. If not specified, this defaults to the
        nonTransactionalDataSource injected into the RiceConfigurer.</para>
      </sect3>

      <sect3>
        <title>registryDataSource</title>

        <para>Specifies the javax.sql.DataSource to use for reading and
        writing from the Service Registry. If not specified, this defaults to
        the DataSource injected into the RiceConfigurer.</para>

        <para>If this DataSource is injected, then the messageDataSource must
        also be injected and vice-versa.</para>
      </sect3>

      <sect3>
        <title>services</title>

        <para>Specifies a list of Java service definitions relating to SOAP to
        use as part of messaging.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>KSB Configurer</title>

      <para>The application needs to do one more thing to begin publishing
      services to the bus: Configure the KSBConfigurer object. This can be
      done using Spring or programmatically. We'll use Spring because it's the
      easiest way to get things configured:</para>

      <programlisting>&lt;bean id="jotm" class="org.springframework.transaction.jta.JotmFactoryBean"&gt;
    &lt;property name="defaultTimeout" value="${transaction.timeout}"/&gt;
&lt;/bean&gt;



&lt;bean id="dataSource" class=" org.kuali.rice.core.database.XAPoolDataSource "&gt;
    &lt;property name="transactionManager" ref="jotm"/&gt;
    &lt;property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/&gt;
    &lt;property name="maxSize" value="25"/&gt;
    &lt;property name="minSize" value="2"/&gt;
    &lt;property name="maxWait" value="5000"/&gt;
    &lt;property name="validationQuery" value="select 1 from dual"/&gt;
    &lt;property name="url" value="jdbc:oracle:thin:@LOCALHOST:1521:XE"/&gt;
    &lt;property name="username" value="myapp"/&gt;
    &lt;property name="password" value="password"/&gt;
&lt;/bean&gt;


&lt;bean id="nonTransactionalDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
        &lt;property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/&gt;
        &lt;property name="url" value="jdbc:oracle:thin:@LOCALHOST:1521:XE"/&gt;
        &lt;property name="maxActive" value="50"/&gt;
        &lt;property name="minIdle" value="7"/&gt;
        &lt;property name="initialSize" value="7"/&gt;
        &lt;property name="validationQuery" value="select 1 from dual"/&gt;
        &lt;property name="username" value="myapp"/&gt;
        &lt;property name="password" value="password"/&gt;
        &lt;property name="accessToUnderlyingConnectionAllowed" value="true"/&gt;
&lt;/bean&gt;

&lt;bean id="coreConfigurer" class="org.kuali.rice.core.impl.config.module.CoreConfigurer"&gt;
    &lt;property name="dataSource" ref="datasource" /&gt;
    &lt;property name="nonTransactionalDataSource" ref="nonTransactionalDataSource" /&gt;
    &lt;property name="transactionManager" ref="jotm" /&gt;
    &lt;property name="userTransaction" ref="jotm" /&gt;
&lt;/bean&gt;

&lt;bean id="ksbConfigurer" class="org.kuali.rice.ksb.messaging.config.KSBConfigurer"/&gt;</programlisting>

      <para>The application is now ready to deploy services to the bus. Let's
      take a quick look at the Spring file above and what's going on there:
      The following configures JOTM, which is currently required to run
      KSB.</para>

      <programlisting>&lt;bean id="jotm" class="org.springframework.transaction.jta.JotmFactoryBean" /&gt;</programlisting>

      <para>Next, we configure the XAPoolDataSource and the non transactional
      BasicDataSource. This is pretty much standard data source configuration
      stuff. The XAPoolDataSource is configured through Spring and not JNDI so
      it can take advantage of JTOM. Servlet containers, which don't support
      JTA, require this configuration step so the datasource will use
      JTA.</para>

      <programlisting>&lt;bean id="dataSource" class=" org.kuali.rice.core.database.XAPoolDataSource "&gt;
    &lt;property name="transactionManager" ref="jotm"/&gt;
    &lt;property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/&gt;
    &lt;property name="url" value="jdbc:oracle:thin:@LOCALHOST:1521:XE"/&gt;
    &lt;property name="maxSize" value="25"/&gt;
    &lt;property name="minSize" value="2"/&gt;
    &lt;property name="maxWait" value="5000"/&gt;
    &lt;property name="validationQuery" value="select 1 from dual"/&gt;
    &lt;property name="username" value="myapp"/&gt;
    &lt;property name="password" value="password"/&gt;
&lt;/bean&gt;

&lt;bean id="nonTransactionalDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/&gt;
    &lt;property name="url" value="jdbc:oracle:thin:@LOCALHOST:1521:XE"/&gt;
    &lt;property name="maxActive" value="50"/&gt;
    &lt;property name="minIdle" value="7"/&gt;
    &lt;property name="initialSize" value="7"/&gt;
    &lt;property name="validationQuery" value="select 1 from dual"/&gt;
    &lt;property name="username" value="myapp"/&gt;
    &lt;property name="password" value="password"/&gt;
    &lt;property name="accessToUnderlyingConnectionAllowed" value="true"/&gt;
&lt;/bean&gt;        </programlisting>

      <para>Next, we configure the bus:</para>

      <programlisting>&lt;bean id="rice" class="org.kuali.rice.core.config.CoreConfigurer"&gt;
    &lt;property name="dataSource" ref="dataSource" /&gt;
    &lt;property name="nonTransactionalDataSource" ref="nonTransactionalDataSource" /&gt;
    &lt;property name="transactionManager" ref="jotm" /&gt;
    &lt;property name="userTransaction" ref="jotm" /&gt;
&lt;/bean&gt;

&lt;bean id="ksbConfigurer" class="org.kuali.rice.ksb.messaging.config.KSBConfigurer"&gt;
    &lt;property name="registryDataSource" ref="dataSource" /&gt;
    &lt;property name="bamDataSource" ref="dataSource" /&gt;
    &lt;property name="messageDataSource" ref="dataSource" /&gt;
    &lt;property name="nonTransactionalMessageDataSource" ref="nonTransactionalDataSource" /&gt;
&lt;/bean&gt;</programlisting>

      <para>We are injecting JOTM, and the datasources. The injection of the
      KSBConfigurer class into the ksbConfigurer property tells this instance
      of Rice to start the Service Bus. The final necessary step is making
      sure the configuration parameter 'application.id' is set properly to
      some value that will identify all services deployed from this node as a
      member of this node. </para>

      <para>At this point, the application is configured to use the bus, both
      for publishing services and to send messages to services. Usually,
      applications will publish services on the bus using the KSBConfigurer or
      the SoapServiceExporter classes. See Acquiring and invoking services for
      more detail.</para>

      <sect3>
        <title>Implications of “synchronous” vs. “asynchronous” Message
        Delivery</title>

        <para>As noted in Configuration Parameters, it is possible to
        configure message delivery to run asynchronously or synchronously. It
        is imported to understand that asynchronous messing should be used in
        almost all cases.</para>

        <para>Asynchronous messing will result in messages being sent in a
        separate thread after the original transaction that requested the
        message to be sent is committed. This is the appropriate behavior in a
        “fire-and-forget” messaging model. The option to configure message
        deliver as synchronous was added for two reasons:<orderedlist>
            <listitem>
              <para>To allow for the implementation of automated unit tests
              which could perform various tests without having to right
              “polling” code to wait for asynchronous messing to
              complete.</para>
            </listitem>

            <listitem>
              <para>For short-lived programs (such as batch programs) which
              need to send messages. This allows for a guarantee that all
              messages will be sent prior to the application being
              terminated.</para>
            </listitem>
          </orderedlist></para>

        <para>The second case is the only case where synchronous messaging
        should be used in a production setting, and even then it should be
        used with care. Synchronous message processing in Rice currently has
        the following major differences from asynchronous messaging that need
        to be understood:<orderedlist>
            <listitem>
              <para>Order of Execution</para>
            </listitem>

            <listitem>
              <para>Exception Handling</para>
            </listitem>
          </orderedlist></para>

        <sect4>
          <title>Order of Execution</title>

          <para>In asynchronous messaging, messages are queued up until the
          end of the transaction, and then sent after the transaction is
          committed (technically, they are sent <emphasis
          role="bold">when</emphasis> the transaction is committed).</para>

          <para>In synchronous messaging, messages are processed <emphasis
          role="bold">immediately</emphasis> when they are “sent”. This
          results in a different ordering of execution when using these two
          different messaging models.</para>
        </sect4>

        <sect4>
          <title>Exception Handling</title>

          <para>In asynchronous messaging, whenever there is a failure
          processing a message, an exception handler is invoked. Recovery from
          such failures can include resending the message multiple times, or
          recording and handling the error in some other way. Since all of
          this is happening after the original transaction was committed, it
          does not affect the original processing which invoked the sending of
          the message.</para>

          <para>With synchronous messaging, since the message processing is
          invoked immediately and the calling code blocks until the processing
          is complete, any errors raised during messaging will be thrown back
          up to the calling code. This means that if you are writing something
          like a batch program which relies on synchronous messaging, you must
          be aware of this and add code to handle any errors if you want to
          deal with them gracefully.</para>

          <para>Another implication of this is that message exception handlers
          will <emphasis role="bold">not</emphasis> be invoked in this case.
          Additionally, because an exception is being thrown, this will
          typically trigger a rollback in any transaction that the calling
          code is running. So transactional issues must be dealt with as well.
          For example, if the failure of a single message shouldn’t cause the
          sending of all messages in a batch job to fail, then each message
          will need to be sent in it’s own transaction, and errors handled
          appropriately.</para>
        </sect4>
      </sect3>
    </sect2>
  </sect1>

  <sect1>
    <title>Configuring Quartz for KSB</title>

    <sect2>
      <title>Quartz Scheduling</title>

      <para>The Kuali Service Bus (KSB) uses Quartz to schedule delayed tasks,
      including retry attempts for messages that cannot be sent the first
      time. By default, KSB uses an embedded quartz scheduler that can be
      configured by passing parameters starting with “<emphasis
      role="italic">ksb.org.quartz.</emphasis>” into the Rice
      configuration.</para>

      <para>If the application is already running a quartz scheduler, you can
      inject a custom quartz scheduler using code like this:</para>

      <programlisting>&lt;bean class="org.kuali.rice.ksb.messaging.config.KSBConfigurer"&gt;
    ...
    &lt;property name="exceptionMessagingScheduler"&gt;
        &lt;bean class="org.springframework.scheduling.quartz.SchedulerFactoryBean"&gt;
            ...
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>

      <para>When you do this, KSB will not create an embedded scheduler but
      will instead use the one provided.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Acquiring and Invoking Services Deployed on KSB</title>

    <sect2>
      <title>Service invocation overview</title>

      <para><orderedlist>
          <listitem>
            <para>Acquired and called directly<itemizedlist>
                <listitem>
                  <para>Automatic Failover</para>
                </listitem>

                <listitem>
                  <para>No Persistence</para>
                </listitem>

                <listitem>
                  <para>Direct call - Request/Response</para>
                </listitem>
              </itemizedlist></para>
          </listitem>

          <listitem>
            <para>Acquired and called through the MessageHelper <itemizedlist>
                <listitem>
                  <para>Automatic Failover</para>
                </listitem>

                <listitem>
                  <para>Message Persistence</para>
                </listitem>

                <listitem>
                  <para>KSB Exception Messaging</para>
                </listitem>

                <listitem>
                  <para>Callback Mechanisms</para>
                </listitem>
              </itemizedlist></para>
          </listitem>
        </orderedlist></para>

      <para>In the examples below, notice that the <emphasis
      role="bold">client code is unaware of the protocol with which the
      underlying service is deployed</emphasis>. Given a connector for a given
      protocol and a compatible service definition, you could move a service
      to different protocols as access needs change without affecting
      dependent client code.</para>
    </sect2>

    <sect2>
      <title>Acquiring and invoking a service directly</title>

      <para>The easiest way to call a service is to grab it and invoke it
      directly. This uses a direct request/response pattern and what you see
      is what you get. You will wait for the processing the call takes on the
      other side plus the cost of the remote connection time. Any exceptions
      thrown will come across the wire in a protocol-acceptable way.</para>

      <para>This code acquires a SOAP-based service and calls it:</para>

      <programlisting>QName serviceName = new QName("testNameSpace", "soap-repeatTopic");

SOAPService soapService = (SOAPService) GlobalResourceLoader.getService(serviceName);
soapService.doTheThing("hello");</programlisting>

      <para>The SOAPService interface needs to be in the client classpath and
      bindable to the WSDL. The easiest way to achieve this in Java is to
      create a bean that is exported as a SOAP service. This is the
      server-side service declaration in a Spring file:</para>

      <programlisting>&lt;bean id="ksbConfigurer" class="org.kuali.rice.ksb.messaging.config.KSBConfigurer"&gt;
  ...
  &lt;property name="services"&gt;
    &lt;list&gt;
        &lt;bean class="org.kuali.rice.ksb.api.bus.support.SoapServiceDefinition"&gt;
            &lt;property name="service"&gt;
              &lt;ref bean="soapService" /&gt;
            &lt;/property&gt;
            &lt;property name="localServiceName" value="soap-repeatTopic" /&gt;
            &lt;property name="serviceNameSpaceURI" value="testNameSpace" /&gt;
            &lt;property name="priority" value="3" /&gt;
            &lt;property name="queue" value="false" /&gt;
            &lt;property name="retryAttempts" value="1" /&gt;
        &lt;/bean&gt;
        ...
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt; </programlisting>

      <para>This declaration exposes the bean soapService on the bus as a SOAP
      available service. The Web Service Definition Language is available at
      the serviceServletUrl + serviceNameSpaceURI + localServiceName +
      ?wsdl.</para>

      <para>This next code snippet acquires and calls a Java base
      service:</para>

      <programlisting>EchoService echoService = (EchoService)GlobalResourceLoader.getService(new QName("TestCl1", "echoService"));
String echoValue = "echoValue";
String result = echoService.echo(echoValue);</programlisting>

      <para>Again, the interface is all that is required to make the call.
      This is the server-side service declaration that deploys a bean using
      Spring’s HttpInvoker as the underlying transport:</para>

      <programlisting>&lt;bean id="ksbConfigurer" class="org.kuali.rice.ksb.messaging.config.KSBConfigurer"&gt;
  ...
  &lt;property name="services"&gt;
    &lt;list&gt;
        &lt;bean class="org.kuali.rice.ksb.api.bus.support.SoapServiceDefinition"&gt;
            &lt;property name="service" ref="echoService" /&gt;
            &lt;property name="serviceInterface" value="org.kuali.rice.ksb.messaging.remotedservices.EchoService" /&gt;
            &lt;property name="localServiceName" value="soap-echoService" /&gt;
            &lt;property name="busSecurity" value="false"&gt;&lt;/property&gt;
        &lt;/bean&gt;
        ...
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt; </programlisting>

      <para>Below is a description of each property on the ServiceDefinition
      (JavaServiceDefinition and SOAPServiceDefinition):</para>

      <para><table frame="none">
          <title>Properties of the ServiceDefinition</title>

          <tgroup cols="4">
            <colspec colname="c1" colnum="1" colwidth="1.0*"/>

            <colspec colname="c2" colnum="2" colwidth="1.0*"/>

            <colspec colname="c3" colnum="3" colwidth="1.0*"/>

            <colspec colname="c4" colnum="4" colwidth="1.0*"/>

            <thead>
              <row>
                <entry>property</entry>

                <entry>required</entry>

                <entry>default</entry>

                <entry>description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>busSecurity</entry>

                <entry>no</entry>

                <entry>yes (JavaServiceDefinition), no
                (SOAPServiceDefinition)</entry>

                <entry>For Java-based services, message is digitally signed
                before calling the service and verified at the node hosting
                the service. For SOAP services, WSS4J is used to digitally
                sign the SOAP request/response in accordance with the WS
                Security specification. More info on Bus Security
                here.</entry>
              </row>

              <row>
                <entry>localServiceName</entry>

                <entry>yes</entry>

                <entry>none</entry>

                <entry>The local name of the QName that makes up the complete
                service name.</entry>
              </row>

              <row>
                <entry>messageExceptionHandler</entry>

                <entry>no</entry>

                <entry>DefaultMessageExceptionHandler</entry>

                <entry>Name of the MessageExceptionHandler that is called when
                a service call fails. This is called after the retryAttempts
                or millisToLive policy of the service or Node has been
                met.</entry>
              </row>

              <row>
                <entry>millisToLive</entry>

                <entry>no</entry>

                <entry>none</entry>

                <entry>Used instead of retryAttempts. Only considered in case
                of error when invoking service. Defines how long the message
                should continue to be tried before being put into KSB
                Exception Messaging.</entry>
              </row>

              <row>
                <entry>priority</entry>

                <entry>no</entry>

                <entry>5</entry>

                <entry>Only applies when asynchronous messaging is enabled.
                The lower the priority is, the sooner the message will be
                executed. For example, if 100 <emphasis role="italic">priority
                10</emphasis> messages are waiting for invocation and a
                <emphasis role="italic">priority 5</emphasis> message is sent,
                the <emphasis role="italic">priority 5</emphasis> message will
                be executed first.</entry>
              </row>

              <row>
                <entry>queue</entry>

                <entry>no</entry>

                <entry>true</entry>

                <entry><para>If <emphasis role="italic">true</emphasis>, the
                service will behave like a queue in that there is only one
                real service call when a message is sent. </para><para>If
                <emphasis role="italic">false</emphasis>, the service will
                behave like a topic. All beans bound to the service name will
                be sent a message when a message is sent to the service.
                </para><para>Use queues for operations you only want to happen
                once (for example, to route a document). Use topics for
                notifications across a cluster (for example, to invalidate
                cache entry).</para></entry>
              </row>

              <row>
                <entry>retryAttempts</entry>

                <entry>no</entry>

                <entry>7</entry>

                <entry>Determines the number of times a service can be invoked
                before being put into KSB Exception Messaging (the error
                state)</entry>
              </row>

              <row>
                <entry>service</entry>

                <entry>yes</entry>

                <entry>none</entry>

                <entry>The bean to be exposed for invocation on the
                bus</entry>
              </row>

              <row>
                <entry>serviceEndPoint</entry>

                <entry>no</entry>

                <entry>serviceServletUrl + serviceName</entry>

                <entry>This can be explicitly set to create an alternate
                service end point, different from the one the bus
                automatically creates.</entry>
              </row>

              <row>
                <entry>serviceName</entry>

                <entry>yes</entry>

                <entry>serviceNameSpaceURI + localServiceName</entry>

                <entry>If <emphasis role="italic">localServiceName</emphasis>
                and <emphasis role="italic">serviceNameSpaceURI</emphasis> are
                omitted, the QName of the service. This can be used instead of
                the <emphasis role="italic">localServiceName</emphasis> and
                <emphasis role="italic">serviceNameSpaceURI</emphasis>
                convenience methods.</entry>
              </row>

              <row>
                <entry>serviceNameSpaceURI</entry>

                <entry>no</entry>

                <entry>messageEntity property or message.entity config param
                is used</entry>

                <entry>The namespaceURI of the QName that makes up the
                complete service name. If set to "" (blank string) the
                property is NOT included in the construction of the QName
                representing the service and the service name will just be the
                localServiceName with no namespace.</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </sect2>

    <sect2>
      <title>Acquiring and invoking a service using messaging</title>

      <para>To make a call to a service through messaging, acquire the service
      by its name using the MessageHelper:</para>

      <programlisting>QName serviceName = new QName("testAppsSharedQueue", "sharedQueue");

KEWSampleJavaService testJavaAsyncService = (KEWSampleJavaService) KsbApiServiceLocator.getMessageHelper().getServiceAsynchronously(serviceName);
</programlisting>

      <para>At this point, the testJavaAsyncService can be called like a
      normal JavaBean:</para>

      <programlisting>testJavaAsyncService.invoke(new ClientAppServiceSharedPayloadObj("message content", false));</programlisting>

      <para>Because this is a queue, a single message is sent to one of the
      beans bound to the service name <emphasis role="italic">new
      QName("testAppsSharedQueue", "sharedQueue")</emphasis>. That 'message'
      is the call 'invoke' and it takes a ClientAppServiceSharedPayloadObj.
      Typically, messaging is done asynchronously. Messages are sent when the
      currently running JTA transaction is committed - that is, the messaging
      layer automatically synchronizes with the current transaction. So, using
      JTA, even though the above is coded in line with code, invocation is
      normally delayed until the transaction surrounding the logic at runtime
      is committed.</para>

      <para>When not using JTA, the message is sent asynchronously (by a
      different thread of execution), but it's sent ASAP.</para>

      <para>To review, the requirements to use a service that is exposed to
      the bus on a different machine are:<orderedlist>
          <listitem>
            <para>The service name</para>
          </listitem>

          <listitem>
            <para>The interface to which to cast the returned service proxy
            object</para>
          </listitem>

          <listitem>
            <para>The ExceptionMessageHandler required by the service in case
            invocation fails</para>
          </listitem>
        </orderedlist></para>

      <note>
        <para>Typically, service providers give clients a JAR with this
        content or organizations maintain a JAR with this content.</para>
      </note>

      <para>To complete the example: Below is the Spring configuration used to
      expose this service to the bus. This is taken from the file <emphasis
      role="italic">TestClient1SpringBeans.xml</emphasis>:</para>

      <programlisting>&lt;!-- bean declaration --&gt;
&lt;bean id="sharedQueue" class=" org.kuali.rice.ksb.testclient1.ClientApp1SharedQueue" /&gt;

&lt;bean id="ksbConfigurer" class="org.kuali.rice.ksb.messaging.config.KSBConfigurer"&gt;
  ...
  &lt;property name="services"&gt;
    &lt;list&gt;
        &lt;bean class=" org.kuali.rice.ksb.messaging.JavaServiceDefinition"&gt;
            &lt;property name="service" ref="sharedQueue" /&gt;
            &lt;property name="localServiceName" value="sharedQueue" /&gt;
            &lt;property name="serviceNameSpaceURI" value="testAppsSharedQueue" /&gt;
        &lt;/bean&gt;
        &lt;... more .../&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt; </programlisting>

      <para>This is located in the Spring file of the application exposing the
      service (in other words, the location in which the actual invocation
      will occur). The client does not need a Spring configuration to invoke
      the service.</para>

      <para>There are two messaging call paradigms, called <emphasis
      role="italic">Topics</emphasis> and <emphasis
      role="italic">Queues</emphasis>. When any number of services is declared
      a Topic, then those services are invoked at least once or multiple
      times. If any number of services is declared a Queue, then one and only
      one service name will be invoked.</para>
    </sect2>

    <sect2>
      <title>Getting responses from service calls made with messaging</title>

      <para>You can use Callback objects to get responses from service calls
      made using messaging. Acquiring a service for use with a
      Callback:</para>

      <programlisting>QName serviceName = new QName("TestCl1", "testXmlAsyncService");
SimpleCallback callback = new SimpleCallback();
KSBXMLService testXmlAsyncService = (KSBXMLService) KsbApiServiceLocator.getMessageHelper().getServiceAsynchronously(serviceName, callback);

testXmlAsyncService.invoke("message content");</programlisting>

      <para>When the service is invoked asynchronously, the
      AsynchronousCallback object's (the SimpleCallback class above) callback
      method is called.</para>

      <para>When message persistence is turned on, this object is serialized
      with any method call made through the messaging API. Take into
      consideration that this object (and the result of a method call) may
      survive machine restart and therefore it’s recommended that you NOT
      depend on certain transient in-memory resources.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Failover</title>

    <sect2>
      <title>Service call failover</title>

      <para>Failover works the same whether making direct service calls or
      using messaging.</para>

      <para>Services exported to the bus have automatic failover from the
      client’s perspective. For example, if service A is deployed on machines
      1 and 2 and a client happens to get a proxy that points to machine 1 but
      machine 1 crashes, the KSB will automatically detect that the exception
      is a result of some network issue and direct the call to machine 2. KSB
      then removes machine 1 from the registry so new clients to the bus don't
      try to acquire the service. When machine 1 returns to the network it
      will register itself with the service registry and therefore the
      bus.</para>

      <para>When a message calls a service, the failover rules determine which
      service KSB assigns (topic or queue) to the message.</para>
    </sect2>

    <sect2>
      <title>Failover with queues</title>

      <para>Because queues require only one call between all beans bound to
      the queue, if a single call to a queue fails, failover to the next bean
      occurs. If successful, the call is done. If it is not successful, it
      continues until a suitable bean is found. If none is found, the message
      is marked for retry later. Eventually, the message either goes to KSB
      exception messaging or successfully completes.</para>
    </sect2>

    <sect2>
      <title>Failover with topics</title>

      <para>If a machine in a topic is unavailable, a failed call to that
      machine will continue to be retried until that call is successful or
      that call goes into KSB exception messaging.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>KSB Exception Messaging</title>

    <para>Exception Messaging is the set of services and configuration options
    that handle messages that cannot be delivered successfully. Exception
    Messaging is primarily used by configuring your service using the
    properties outlined in KSB Module Configuration. When services are
    configured to use message persistence and there is a problem invoking a
    service, the persisted message or service call is relied upon to make
    another call to that service until the call is either:<orderedlist>
        <listitem>
          <para>Successful</para>
        </listitem>

        <listitem>
          <para>Certain configuration policies have been met and the message
          goes into the Exception state</para>
        </listitem>
      </orderedlist></para>

    <para>The Exception state means that KSB can't doing anything more with
    this message. The message will not invoke properly. That generally means
    that some sort of technical intervention is required by both the consumer
    and the provider of the service to determine what the problem is.</para>

    <para>All Exception behavior is configurable at the service level by
    setting the name of the class to be used as MessageExceptionHandler. This
    class determines what to do when a client of a service cannot invoke a
    message. The DefaultMessageExceptionHandler is enough to meet most
    requirements.</para>

    <para>When a message is put into the Exception state, KSB puts it back
    into the message store and marks it with a status of 'E'. At that point,
    it is up to the person responsible for monitoring this node on the bus to
    determine what to do with the message.</para>

    <para>Because the node exposing the service configures the
    MessageExceptionHandler, any clients depending on the service need that
    MessageExceptionHandler and any dependent code and configuration.</para>
  </sect1>

  <sect1>
    <title>KSB Messaging Paradigms</title>

    <para>KSB supports two types of messaging paradigms; Queues and Topics,
    and the differences are explained below. These are very similar to JMS
    messaging concepts. An open source solution was not used for KSB messaging
    because an open source JMS provider wasn’t found that provided JTA
    synchronization, discovery, failover, and load balancing. Many claim such
    features, but when put to the test in real world scenarios (i.e., machines
    going down and coming back up, databases failing, network connectivity
    issues); none managed to reliably deliver messages.</para>

    <para>The advantage here is that we can apply these messaging concepts to
    any support protocol with which we can communicate.</para>

    <sect2>
      <title>Queues</title>

      <para>When any number of services is bound to a queue and a method is
      invoked, one and only one service gets the invocation.</para>
    </sect2>

    <sect2>
      <title>Topics</title>

      <para>When any number of services is bound to a topic and a method is
      invoked, all services are invoked AT LEAST once or multiple
      times.</para>
    </sect2>

    <sect2>
      <title>Message Fetcher</title>

      <para><emphasis
      role="italic">org.kuali.rice.ksb.messaging.MessageFetcher</emphasis> is
      a Runnable that needs to be configured by the client application to
      retrieve stored messages from the database that weren’t processed when
      the node went down. This can happen for many reasons. The machine can be
      under load and just crash.</para>

      <para>When message persistence is enabled, a service that fails or
      throws an Exception stores preprocessed messages in the database until
      they can be resent. This makes certain that a crash or emergency restart
      of your machine will not result in message loss.</para>

      <para>The KSB does not automatically fetch all these messages and
      attempt to invoke them when it starts, because often the KSB is started
      when the services the messages are bound for are not yet started. For
      now, you need to decide when to call the run method on the
      MessageFetcher. Because it's a Runnable, you could also put the
      MessageFetcher in the KSBThreadPool that is available on the
      KSBServiceLocator. You could wrap it in a TimerTask, etc. All that is
      required is this:</para>

      <programlisting>new MessageFetcher((Integer) null).run()</programlisting>

      <para>Unfortunately, the cast to Integer is required. The MessageFetcher
      also has a constructor that takes a long variable as a parameter. This
      can be used to pull any message in the message store and put it in
      memory for invocation. <emphasis role="italic">Integer</emphasis> is a
      fetch size; <emphasis role="italic">null</emphasis> means all.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Load Balancing</title>

    <para>Load balancing between service calls is automatic. If there are
    multiple nodes that expose services of the same name, clients will
    randomly acquire proxies to each endpoint bound to that name.</para>
  </sect1>

  <sect1>
    <title>Object Remoting</title>

    <para>As of Rice 2.0, Object remoting support has been removed.</para>
  </sect1>

  <sect1>
    <title>Publishing Services to KSB</title>

    <para>You can publish Services on the service bus either by configuring
    them directly in the application's KSBConfigurer module definition, or by
    using the PropertyConditionalServiceBusExporter bean. In either case, a
    ServiceDefinition is provided that specifies various bus settings and the
    target Spring bean.</para>

    <sect2>
      <title>KSBConfigurer</title>

      <para>A service can be exposed by explicitly registering it with the
      KSBConfigurer module, services property:</para>

      <programlisting>&lt;bean class="org.kuali.rice.ksb.messaging.config.KSBConfigurer"&gt;
    &lt;property name="serviceServletUrl" value="${base url}/MYAPP/remoting/" /&gt;
    ...
    &lt;property name="services"&gt;
      &lt;list&gt;
          &lt;bean class="org.kuali.rice.ksb.api.bus.support.SoapServiceDefinition"&gt;
              &lt;property name="service"&gt;
                  &lt;ref bean="mySoapService" /&gt;
              &lt;/property&gt;
              &lt;property name="serviceInterface"&gt;&lt;value&gt;org.myapp.services.MySOAPService&lt;/value&gt;&lt;/property&gt;
              &lt;property name="localServiceName" value="myExposedSoapService" /&gt;
          &lt;/bean&gt;
          &lt;bean class="org.kuali.rice.ksb.api.bus.support.JavaServiceDefinition"&gt;
              &lt;property name="service"&gt;
                  &lt;ref bean="myJavaService" /&gt;
              &lt;/property&gt;
              &lt;property name="serviceInterface"&gt;
                  &lt;value&gt;org.myapp.services.MyJavaService&lt;/value&gt;&lt;/property&gt;
              &lt;property name="localServiceName" value="myExposedJavaService" /&gt;
          &lt;/bean&gt;
</programlisting>
    </sect2>

    <sect2>
      <title>Service Exporter</title>

      <para>You can also publish Services in any context using the
      ServiceBusExporter (or PropertyConditionalServiceBusExporter) bean. Note
      that KSBConfigurer must also be defined in your RiceConfigurer.</para>

      <programlisting>&lt;bean id="myapp.serviceBus"
        class="org.kuali.rice.krad.config.GlobalResourceLoaderServiceFactoryBean"&gt;
    &lt;property name="serviceName" value="rice.ksb.serviceBus"/&gt;
&lt;/bean&gt;

&lt;bean id="myAppServiceExporter"
        class="org.kuali.rice.ksb.api.bus.support.ServiceBusExporter"
        abstract="true"&gt;
    &lt;property name="serviceBus" ref="myapp.serviceBus"/&gt;
&lt;/bean&gt;

&lt;bean id="myJavaService.exporter" parent="myAppServiceExporter"&gt;
    &lt;property name="serviceDefinition"&gt;
        &lt;bean class="org.kuali.rice.ksb.api.bus.support.JavaServiceDefinition"&gt;
            &lt;property name="service"&gt;
                &lt;ref bean="myJavaService" /&gt;
            &lt;/property&gt;
            &lt;property name="serviceInterface"&gt;
                &lt;value&gt;org.myapp.services.MyJavaService&lt;/value&gt;
            &lt;/property&gt;
            &lt;property name="localServiceName" value="myExposedJavaService" /&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="mySoapService.exporter" parent="myAppServiceExporter"&gt;
    &lt;property name="serviceDefinition"&gt;
        &lt;bean class="org.kuali.rice.ksb.api.bus.support.SoapServiceDefinition"&gt;
            &lt;property name="service"&gt;
                &lt;ref bean="mySoapService" /&gt;
            &lt;/property&gt;
            &lt;property name="serviceInterface"&gt;
                &lt;value&gt;org.myapp.services.MySOAPService&lt;/value&gt;
            &lt;/property&gt;
            &lt;property name="localServiceName" value="myExposedSoapService" /&gt;
        &lt;/bean&gt;
    &lt;/property&gt;

&lt;/bean&gt;</programlisting>
    </sect2>

    <sect2 xml:id="callback_service_exporter">
      <title>CallbackServiceExporter</title>

      <para>The term "Callback Service" refers to services that client
      applications write and configure and which are used by various modules
      of Rice including KIM, KEW, and KRMS. Because of the naming convention
      on these, they are often referred to as "Type Services". These
      include:</para>

      <para><itemizedlist>
          <listitem>
            <para>KIM<itemizedlist>
                <listitem>
                  <para>RoleTypeService</para>
                </listitem>

                <listitem>
                  <para>PermissionTypeService</para>
                </listitem>

                <listitem>
                  <para>GroupTypeService</para>
                </listitem>

                <listitem>
                  <para>etc.</para>
                </listitem>
              </itemizedlist></para>
          </listitem>

          <listitem>
            <para>KRMS<itemizedlist>
                <listitem>
                  <para>ActionTypeService</para>
                </listitem>

                <listitem>
                  <para>PropositionTypeService</para>
                </listitem>

                <listitem>
                  <para>AgendaTypeService</para>
                </listitem>

                <listitem>
                  <para>etc.</para>
                </listitem>
              </itemizedlist></para>
          </listitem>

          <listitem>
            <para>KEW<itemizedlist>
                <listitem>
                  <para>PeopleFlowTypeService</para>
                </listitem>
              </itemizedlist></para>
          </listitem>
        </itemizedlist>These are typically called back into from the Rice
      Standalone Server when needing information for rendering of various
      components in the server-side user interface. Additionally, in some
      cases they can also be used to provide custom processing hooks for
      different components of the various Kuali Rice frameworks.</para>

      <sect3>
        <title>Version Compatibility for Callback Services</title>

        <para>Callback services (like all services in Rice) can be evolved
        over time and across versions. This means that new functionality might
        be added to them. Since the Rice Standalone Server interacts with
        these services remotely, it really needs to know what version of a
        particular callback service that the client application is running.
        They also must be published as the appropriate type of service
        endpoint that the standalone server knows how to talk to (i.e. SOAP
        instead of Java Serialization). Thankfully, the KSB service registry
        can store metadata about a service which includes the service version.
        However, in order to for this to work properly the client application
        must be sure they publish the service with a version that matches the
        version of Rice they are using.</para>

        <para>In order to make this easier on client applications, a helper
        has been implemented which can be used for this purpose in
        Rice.</para>
      </sect3>

      <sect3>
        <title>Callback Service Exporter Helper</title>

        <para>There is a helper class which can be used by client applications
        to export these callback services onto the Kuali Service Bus. The
        class is
        <code>org.kuali.rice.ksb.api.bus.support.CallbackServiceExporter</code>.
        This is a class which can be wired up inside of a Spring context in
        order to publish a callback service to the KSB with the appropriate
        Rice version. The version of Rice is packaged up into the Rice jars
        inside of a file called
        <emphasis>common-config-defaults.xml</emphasis> and it uses the
        version that matches the version of Rice in the POM when the jar was
        packaged.</para>

        <para>Typical configuration might look like the
        following:<programlisting>&lt;bean id="sampleAppPeopleFlowTypeService.exporter"
      class="org.kuali.rice.ksb.api.bus.support.CallbackServiceExporter"
      p:serviceBus-ref="rice.ksb.serviceBus"
      p:callbackService-ref="sampleAppPeopleFlowTypeService"
      p:serviceNameSpaceURI="http://rice.kuali.org/sample-app"
      p:localServiceName="sampleAppPeopleFlowTypeService"
      p:serviceInterface="org.kuali.rice.kew.framework.peopleflow.PeopleFlowTypeService"/&gt;</programlisting></para>

        <para>The javadocs for <code>CallbackServiceExporter</code> provide
        more detail on the options for publishing of callback services.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>ServiceDefinition properties</title>

      <para>ServiceDefinitions define how the service is published to the KSB.
      Currently KSB supports three types of services: Java RPC (via
      serialization over HTTP), SOAP, and JMS.</para>

      <sect3>
        <title>Basic parameters</title>

        <para>All service definitions support these properties:</para>

        <para><table frame="none">
            <title>ServiceDefinition Properties</title>

            <tgroup cols="3">
              <colspec colname="c1" colnum="1" colwidth="1.0*"/>

              <colspec colname="c2" colnum="2" colwidth="1.0*"/>

              <colspec colname="c3" colnum="3" colwidth="1.0*"/>

              <thead>
                <row>
                  <entry>Property</entry>

                  <entry>Description</entry>

                  <entry>Required</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>Service</entry>

                  <entry>The reference to the target service bean</entry>

                  <entry>yes</entry>
                </row>

                <row>
                  <entry>localServiceName</entry>

                  <entry>The "local" part of the service name; together with a
                  namespace this forms a qualified name, or QName</entry>

                  <entry>yes</entry>
                </row>

                <row>
                  <entry>serviceNameSpaceURI</entry>

                  <entry>The "namespace" part of the service name; together
                  with a local name forms a qualified name, or QName</entry>

                  <entry>Not required; if omitted, the <emphasis
                  role="bold">Core.currentContextConfig().getMessageEntity()</emphasis>
                  is used when exporting the service</entry>
                </row>

                <row>
                  <entry>serviceEndpoint</entry>

                  <entry>URL at which the service can be invoked by a remote
                  call</entry>

                  <entry>Not required; defaults to the serviceServletUrl
                  parameter defined in the Rice config</entry>
                </row>

                <row>
                  <entry>retryAttempts</entry>

                  <entry>Number of attempts to retry the service invocation on
                  failure; for services with side-effects you are advised to
                  omit this property</entry>

                  <entry>Not required; defaults to 0</entry>
                </row>

                <row>
                  <entry>millisToLive</entry>

                  <entry>Number of milliseconds the call should persist before
                  resulting in failure</entry>

                  <entry>Not required; defaults to no limit (-1)</entry>
                </row>

                <row>
                  <entry>Priority</entry>

                  <entry>Priority</entry>

                  <entry>Not required; defaults to 5</entry>
                </row>

                <row>
                  <entry>MessageExceptionHandler</entry>

                  <entry>Reference to a MessageExceptionHandler that should be
                  invoked in case of exception</entry>

                  <entry>Not required; default implementation handles retries
                  and timeouts</entry>
                </row>

                <row>
                  <entry>busSecurity</entry>

                  <entry>Whether to enable bus security for the
                  service</entry>

                  <entry>Not required; defaults to <emphasis
                  role="italic">ON</emphasis></entry>
                </row>
              </tbody>
            </tgroup>
          </table></para>
      </sect3>
    </sect2>

    <sect2>
      <title>ServiceNameSpaceURI/MessageEntity</title>

      <para>ServiceNameSpaceURI is the same as the <emphasis
      role="italic">Message Entity</emphasis> that composes the qualified name
      under which the service is exposed. When omitted, this namespace
      defaults to the message entity configured for Rice (e.g., in the
      RiceConfigurer), thereby qualifying the local name. Note: Although this
      implicit qualification occurs during export, you must always specify an
      explicit message entity when acquiring a resource, for example:</para>

      <programlisting>GlobalResourceLoader.getService(new QName("MYAPP", "myExposedSoapService"))</programlisting>
    </sect2>

    <sect2>
      <title>SOAPServiceDefinition</title>

      <table frame="none">
        <title>SOAPServiceDefinition</title>

        <tgroup cols="3">
          <colspec colname="c1" colnum="1" colwidth="1.0*"/>

          <colspec colname="c2" colnum="2" colwidth="1.0*"/>

          <colspec colname="c3" colnum="3" colwidth="1.0*"/>

          <thead>
            <row>
              <entry>Property</entry>

              <entry>Description</entry>

              <entry>Required</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>serviceInterface</entry>

              <entry>The interface to expose and from which to generate the
              WSDL</entry>

              <entry>Not required; if omitted the first interface implemented
              by the class is used</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </sect2>

    <sect2>
      <title>JavaServiceDefinition</title>

      <table frame="none">
        <title>JavaServiceDefinition</title>

        <tgroup cols="3">
          <colspec colname="c1" colnum="1" colwidth="1.0*"/>

          <colspec colname="c2" colnum="2" colwidth="1.0*"/>

          <colspec colname="c3" colnum="3" colwidth="1.0*"/>

          <thead>
            <row>
              <entry>Property</entry>

              <entry>Description</entry>

              <entry>Required</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>serviceInterface</entry>

              <entry>The interface to expose</entry>

              <entry>Not required; if omitted, all application-layer
              interfaces implemented by the class are exposed</entry>
            </row>

            <row>
              <entry>serviceInterfaces</entry>

              <entry>A list of interfaces to expose</entry>

              <entry>Not required; if omitted, all application-layer
              interfaces implemented by the class are exposed</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </sect2>

    <sect2>
      <title>Publishing Rice services</title>

      <para>We show how you can "import" Rice services into the client Spring
      application context in Configuring KSB Client in Spring. Using this
      technique, you can also publish Rice services on the KSB:</para>

      <programlisting>&lt;!-- import a Rice service from the ResourceLoader stack --&gt;
&lt;bean id="myapp.aRiceService" class="org.kuali.rice.krad.config.GlobalResourceLoaderServiceFactoryBean"&gt;
    &lt;property name="serviceName" value="aRiceService"/&gt;
&lt;/bean


&lt;!-- if Rice does not publish this service on the bus, one can explicitly publish it --&gt;
&lt;bean id="myAppServiceExporter"
        class="org.kuali.rice.ksb.api.bus.support.ServiceBusExporter"
        abstract="true"&gt;
    &lt;property name="serviceBus" ref="myapp.serviceBus"/&gt;
&lt;/bean&gt;

&lt;bean id="myJavaService.exporter" parent="myAppServiceExporter"&gt;
    &lt;property name="serviceDefinition"&gt;
        &lt;bean class="org.kuali.rice.ksb.api.bus.support.JavaServiceDefinition"&gt;
            &lt;property name="service"&gt;
                &lt;ref bean="aRiceService" /&gt;
            &lt;/property&gt;
            &lt;property name="serviceInterface" value="org.kuali.rice...SomeInterface" /&gt;
            &lt;property name="localServiceName" value="aPublishedRiceService" /&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>

      <warning>
        <para>Not all Rice services are intended for public use. Do not
        arbitrarily expose them on the bus</para>
      </warning>
    </sect2>
  </sect1>

  <sect1>
    <title>The ResourceLoader Stack</title>

    <sect2>
      <title>Overview</title>

      <para>Rice is composed of a set of modules that provide distinct
      functionality and expose various services. <itemizedlist>
          <listitem>
            <para>Services in Rice are accessible by the <emphasis
            role="bold">ResourceLoader</emphasis>, which can be thought of as
            analogous to Spring's <emphasis
            role="italic">BeanFactory</emphasis> interface. (In fact, Rice
            modules themselves back ResourceLoaders with Spring bean
            factories.)</para>
          </listitem>

          <listitem>
            <para>Services can be acquired by name. (Rice adds several
            additional concepts, including qualification of service names by
            namespaces.)</para>
          </listitem>

          <listitem>
            <para>When the <emphasis role="bold">RiceConfigurer</emphasis> is
            instantiated, it constructs a GlobalResourceLoader that is
            composed of an initial <emphasis
            role="italic">RootResourceLoader</emphasis> (which may be provided
            by the application via the RiceConfigurer), as well as resource
            loaders supplied by each module:</para>

            <figure>
              <title>Global Resource Loader</title>

              <mediaobject>
                <imageobject>
                  <imagedata fileref="../images/global_resource_loader.png"
                             scalefit="1"/>
                </imageobject>
              </mediaobject>
            </figure>
          </listitem>
        </itemizedlist></para>

      <para>The <emphasis role="bold">GlobalResourceLoader</emphasis> is the
      top-level entry point through which all application code should go to
      obtain services. The <emphasis role="bold">getService</emphasis> call
      will iterate through each registered ResourceLoader, looking for the
      service of the specified name. If the service is found, it is returned,
      but if it is <emphasis role="italic">not</emphasis> found, ultimately
      the call will reach the <emphasis
      role="bold">RemoteResourceLoader</emphasis>. The Root ResourceLoader is
      registered by the KSB module that exposes services that have been
      registered on the bus.</para>
    </sect2>

    <sect2>
      <title>Accessing and overriding Rice services and beans from
      Spring</title>

      <sect3>
        <title>ResourceLoaderFactoryBean</title>

        <para>In addition to programmatically acquiring service references,
        you can also import Rice services into a Spring context with the help
        of the <emphasis
        role="bold">GlobalResourceLoaderServiceFactoryBean</emphasis>:</para>

        <para>This bean is <emphasis role="italic">bean-name-aware</emphasis>
        and will produce a bean of the same name obtained from Rice's resource
        loader stack. The bean can then be wired in Spring like any other
        bean.</para>
      </sect3>

      <sect3>
        <title>Installing an application root resource loader </title>

        <para>Applications can install their own root ResourceLoader to
        override beans defined by Rice. To do so, inject a bean that
        implements the ResourceLoader interface into the RiceConfigurer
        rootResourceLoader property. For example:</para>

        <programlisting>&lt;!-- a Rice bean we want to override in our application --&gt;
&lt;bean id="overriddenRiceBean" class="my.app.package.MyRiceServiceImpl"/&gt;

&lt;!-- supplies services from this Spring context --&gt;
&lt;bean id="appResourceLoader" class="org.kuali.rice.core.impl.resourceloader.SpringBeanFactoryResourceLoader"/&gt;
&lt;bean id="coreConfigurer" class="org.kuali.rice.core.impl.config.module.CoreConfigurer"&gt;
    &lt;property name="dataSource" ref="standaloneDataSource" /&gt;
    &lt;property name="transactionManager" ref="atomikosTransactionManager" /&gt;
    &lt;property name="userTransaction" ref="atomikosUserTransaction" /&gt;
    &lt;property name="rootResourceLoader" ref="appResourceLoader"/&gt;
&lt;/bean&gt;</programlisting>

        <warning>
          <para><emphasis role="bold">Application ResourceLoader and Circular
          Dependencies</emphasis></para>

          <para>Be careful when mixing registration of an application root
          resourceloader and lookup of Rice services through the
          GlobalResourceLoader. If you are using an application resourceloader
          to override a Rice bean, but one of your application beans requires
          that bean to be injected during startup, you may create a circular
          dependency. In this case, you will either have to make sure you are
          not unintentionally exposing application beans (which may not yet
          have been fully initialized by Spring) in the application
          resourceloader, or you will have to arrange for the GRL lookup to
          occur lazily, after Spring initialization has completed (either
          programmatically or through a proxy).</para>
        </warning>
      </sect3>

      <sect3>
        <title>Overriding Rice services: Alternate method</title>

        <para>A Rice-enabled webapp (including the Rice Standalone
        distribution) contains a multiple module configurers, typically
        defined in an xml Spring context file. These load the Rice modules.
        Each module has its own ResourceLoader, which is typically backed by
        an XML Spring context file. Overriding and/or setting global beans
        and/or services (such as data sources and transaction managers) is
        done as described above. However, because in each module services can
        be injected into each other, overriding module services involves
        overriding the respective module’s Spring context file.</para>

        <para>The cleanest way to do this is to set the
        rice.*.addtionalSpringFiles to an accessible spring beans file that
        overrides one or more spring beans in the existing module's context.
        Each rice module has a corresponding configuration parameter that can
        be pointed to a file that will override any existing services.</para>

        <programlisting>&lt;param name="rice.kew.additionalSpringFiles"&gt;classpath:myapp/config/MyAppKewOverrideSpringBeans.xml&lt;/param&gt;

&lt;param name="rice.ksb.additionalSpringFiles"&gt;classpath:myapp/config/MyAppKsbOverrideSpringBeans.xml&lt;/param&gt;

&lt;param name="rice.krms.additionalSpringFiles"&gt;classpath:myapp/config/MyAppKrmsOverrideSpringBeans.xml&lt;/param&gt;

&lt;param name="rice.kim.additionalSpringFiles"&gt;classpath:myapp/config/MyAppKimOverrideSpringBeans.xml&lt;/param&gt;</programlisting>

        <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN//EN" "http://www.springframework.org/dtd/spring-beans.dtd"&gt;
&lt;!-- override of KNS encryption service --&gt;
&lt;beans&gt;


    &lt;!-- override encryption services --&gt;
    &lt;bean id="encryptionService" class="edu.my.school.myapp.service.impl.MyEncryptionServiceImpl" lazy-init="true"&gt;
        &lt;property name="cipherAlgorithm" value="${encryption.cipherAlg}"/&gt;
        &lt;property name="keyAlgorithm" value="${encryption.keyAlg}"/&gt;
        &lt;property name="key" value="${encryption.key}"/&gt;
        &lt;property name="enabled" value="${encryption.busEncryption}"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</programlisting>
      </sect3>
    </sect2>
  </sect1>

  <sect1>
    <title>KSB Security -- STILL NEEDS TO BE REVIEWED!!!!</title>

    <sect2>
      <title>Overview</title>

      <para>Acegi handles the security layer for KSB. Acegi uses remote method
      invocation to hold the application’s security context and to propagate
      this object through to the service layer.</para>
    </sect2>

    <sect2>
      <title>Credentials types</title>

      <para>There are several security types you can use to propagate the
      security context object:<itemizedlist>
          <listitem>
            <para>CAS</para>
          </listitem>

          <listitem>
            <para>USERNAME_PASSWORD</para>
          </listitem>

          <listitem>
            <para>JAAS</para>
          </listitem>

          <listitem>
            <para>X509</para>
          </listitem>
        </itemizedlist></para>
    </sect2>

    <sect2>
      <title>CredentialsSource</title>

      <para>The CredentialsSource is an interface that helps obtain security
      credentials. It encapsulates the actual source of credentials. The two
      ways to obtain the source are:<itemizedlist>
          <listitem>
            <para>X509CredentialsSource - X509 Certificate</para>
          </listitem>

          <listitem>
            <para>UsernamePasswordCredentialsSource - Username and
            Password</para>
          </listitem>
        </itemizedlist></para>

      <sect3>
        <title>KSB security: Server side configuration</title>

        <para>Here is a code snippet that shows the changes needed to
        configure KSB security on the server side:</para>

        <programlisting>&lt;bean id="ksbConfigurer" class="org.kuali.rice.ksb.messaging.config.KSBConfigurer"&gt;
    &lt;!-- Other properties removed --&gt;
    &lt;property name="services"&gt;
        &lt;list&gt;
            &lt;bean class="org.kuali.rice.ksb.api.bus.support.SoapServiceDefinition"&gt;
                &lt;property name="service"&gt;
                    &lt;ref bean="soapService" /&gt;
                &lt;/property&gt;
                &lt;property name="localServiceName" value="soapLocalName"/&gt;
                &lt;property name="serviceNameSpaceURI" value="soapNameSpace"/&gt;
                &lt;property name="serviceInterface" value="org.kuali.ksb.examples.SOAPEchoService"/&gt;
                &lt;property name="priority" value="3"/&gt;
                &lt;property name="retryAttempts" value="1" /&gt;
                &lt;property name="busSecurity" value="false"&gt;&lt;/property&gt;
    
                &lt;!-- Valid Values: CAS, KERBEROS --&gt;
                &lt;property name="credentialsType" value="CAS"/&gt;
            &lt;/bean&gt;
            &lt;bean class="org.kuali.rice.ksb.api.bus.support.JavaServiceDefinition"&gt;
                &lt;property name="service" ref="echoService"&gt;&lt;/property&gt;
                &lt;property name="localServiceName" value="javaLocalName" /&gt;
                &lt;property name="serviceNameSpaceURI" value="javaNameSpace"/&gt;
                &lt;property name="serviceInterface" value="org.kuali.ksb.examples.EchoService"/&gt;
                &lt;property name="priority" value="5" /&gt;
                &lt;property name="retryAttempts" value="1" /&gt;
                &lt;property name="busSecurity" value="true" /&gt;

                &lt;!-- Valid Values: CAS, KERBEROS --&gt;
                &lt;property name="credentialsType" value="CAS"/&gt;
            &lt;/bean&gt;
            &lt;!-- Other services removed --&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>
      </sect3>

      <sect3>
        <title>KSB security: Client side configuration</title>

        <programlisting>&lt;bean id="customCredentialsSourceFactory" class="edu.myinstituition.myapp.security.credentials.CredentialsSourceFactory" /&gt;

&lt;bean id="coreConfigurer" class="org.kuali.rice.core.impl.config.module.CoreConfigurer"&gt;
    &lt;!-- Other properties removed --&gt;
    &lt;property name="credentialsSourceFactory" ref="customCredentialsSourceFactory"&gt;
&lt;/bean&gt;
</programlisting>
      </sect3>
    </sect2>

    <sect2>
      <title>KSB connector and exporter code</title>

      <sect3>
        <title>Connectors</title>

        <para>Connectors are used by a client to connect to a service that is
        usually exposed through the KSB registry. The Service Connector
        factory provides a bean that holds a proxy to a remote service with
        some contextual information. The factory determines the type of proxy
        to invoke based on the service definition. The service definition used
        by the server is serialized to the database and de-serialized by the
        client. There are different types of connectors supported by KSB, most
        notable are SOAP and Java over HTTP.</para>
      </sect3>

      <sect3>
        <title>Exporters</title>

        <para>Services, when exported, can be secured using standard Acegi
        methods. A security manager and an interceptor help organize the set
        of Business Objects that are exported.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="security_and_keystores">
      <title>Security and Keystores</title>

      <sect3>
        <title>Generating the Keystore</title>

        <para>For client applications to be able to consume secured services
        hosted from a Rice server, the implementer must generate a keystore.
        As an initial setup, KSB security relies on the creation of a keystore
        using the JVM keytool as follows:</para>
      </sect3>

      <sect3>
        <title>Step 1: Create the Keystore</title>

        <para>The first step is to create the keystore and generate a
        public-private key combination for the client application. When using
        secured services on the KSB, we require the client applications
        transfer their messages digitally signed so that Rice can verify the
        messages authenticity. This is why we must generate these keys.</para>

        <para>Generate your initial Rice keystore as follows:</para>

        <programlisting>keytool -genkey -validity 9999 -alias rice -keyalg RSA -keystore rice.keystore -dname "cn=rice" -keypass r1c3pw -storepass r1c3pw</programlisting>

        <caution>
          <para>keypass and storepass should be the same.</para>

          <para>r1c3pw is the password used for the provided example.</para>
        </caution>
      </sect3>

      <sect3>
        <title>Step 2: Sign the Key</title>

        <para>This generates the keystore in a file called "rice_keystore" in
        the current directory and generates an RSA key with the alias of
        "rice". Since there is no certificate signing authority to sign our
        key, we must sign it ourselves. To do this, execute the following
        command:</para>

        <programlisting>keytool  -selfcert -validity 9999 -alias rice -keystore rice.keystore -keypass r1c3pw -storepass r1c3pw</programlisting>
      </sect3>

      <sect3>
        <title>Step 3: Generate the Certificate</title>

        <para>After the application's certificate has been signed, we must
        export it so that it can be imported into the Rice keystore. To export
        a certificate, execute the following command:</para>

        <programlisting>keytool  -export -alias rice -file rice.cert -keystore rice.keystore -storepass r1c3pw</programlisting>
      </sect3>

      <sect3>
        <title>Step 4: Import Application Certificates</title>

        <para>The client application's certificate can be imported using the
        following command:</para>

        <programlisting>keytool  -import -alias rice -file client.application.cert.file -keystore rice.keystore -storepass r1c3pw</programlisting>

        <para>The keystore file will end up deployed wherever your keystores
        are stored so hang on to both of these files and don't lose them!
        Also, notice that we specified a validity of 9999 days for the
        keystore and cert. This is so you do not have to continually update
        these keystores. This will be determined by your computing standards
        on how you handle key management.</para>
      </sect3>

      <sect3>
        <title>Configure KSB to use the keystore</title>

        <para>The following params are needed in the xml config to allow the
        ksb to use the keystore:</para>

        <programlisting>&lt;param name="keystore.file"&gt;/usr/local/rice/rice.keystore&lt;/param&gt;
&lt;param name="keystore.alias"&gt;rice&lt;/param&gt;
&lt;param name="keystore.password"&gt; password &lt;/param&gt;
</programlisting>

        <para><itemizedlist>
            <listitem>
              <para>keystore.file - is the location of the keystore</para>
            </listitem>

            <listitem>
              <para>keystore.alias - is the alias used in creating the
              keystore above</para>
            </listitem>

            <listitem>
              <para>keystore.password - this is the password of the alias AND
              the keystore. This assumes that the keystore is up in such a way
              that these are the same.</para>
            </listitem>
          </itemizedlist></para>
      </sect3>
    </sect2>
  </sect1>

  <sect1>
    <title>Queue and Topic invocation</title>

    <para>When you deploy a service, you can configure it for queue or for
    topic invocation using the <emphasis role="bold">setQueue</emphasis>
    property on the <emphasis role="bold">ServiceDefinition</emphasis>. The
    default is to register it as a queue-style service. The distinction
    between queue and topic invocation occurs when there is more than one
    service registered under the same <emphasis
    role="bold">QName</emphasis>.</para>

    <sect2>
      <title>Queue invocation</title>

      <para>Remote service proxies obtained through the resource loader stack
      using <emphasis role="bold">getService(QName)</emphasis> (ultimately
      through the <emphasis role="bold">ServiceBus</emphasis>) are inherently
      synchronous. In the presence of multiple service registrations, the
      <emphasis role="bold">ServiceBus</emphasis> will choose one at
      random.</para>

      <para>When invoking services asynchronously through the <emphasis
      role="bold">MessageHelper</emphasis>, an asynchronous service call proxy
      will be constructed with all available service definitions. The
      <emphasis role="bold">MessageServiceInvoker</emphasis> is called to
      invoke each service. If the service is defined as a queue service, then
      the <emphasis role="bold">ServiceBus</emphasis> will be consulted in a
      similar fashion to determine a single service to call. After the first
      queue service invocation the <emphasis
      role="bold">MessageServiceInvoker</emphasis> will return.</para>
    </sect2>

    <sect2>
      <title>Topic invocation</title>

      <para>The simplest way to invoke a topic service is using the <emphasis
      role="bold">MessageHelper</emphasis> functions to invoke the service
      asynchronously. As described above for an asynchronous queue invocation,
      an asynchronous service call proxy will be constructed with the list of
      all of the services registered as a topic under the given name. Each of
      these services will be independently obtained and invoked by the
      <emphasis role="bold">MessageServiceInvoker</emphasis>.</para>

      <para>Invoking a topic synchronously, however, requires use of a
      synchronous service call proxy to aggregate all of the topic's services.
      This functionality is not directly available via the <emphasis
      role="bold">ServiceBus</emphasis> API because the <emphasis
      role="bold">ServiceBus</emphasis> acts as a facade for direct service
      invocation.</para>

      <para>To invoke a topic synchronously, you can construct a <emphasis
      role="bold">SynchronousServiceCallProxy</emphasis> using <emphasis
      role="bold">SynchronousServiceCallProxy.createInstance</emphasis>,
      passing the list of <emphasis role="bold">Endpoint</emphasis> obtained
      using <emphasis role="bold">ServiceBus.getEndpoints(QName)</emphasis>.
      This is done, for example, by <emphasis
      role="bold">MessageHelperImpl</emphasis> when the bus has been forced
      into synchronous mode via the <emphasis
      role="bold">message.delivery</emphasis> config param.</para>

      <para>The synchronous service call proxy is the same as the asynchronous
      service call proxy, except that it does not queue up the invocation, it
      will invoke it blockingly. The same queue/topic distinctions described
      above apply when you invoke a topic synchronously. Under the normal
      queue situation, use of the synchronous service call proxy is not
      necessary because, as mentioned above, remote services obtained through
      the <emphasis role="bold">ServiceBus</emphasis> are naturally
      synchronous. You can see this in the example below:</para>

      <programlisting>List&lt;Endpoint&gt; servicesToProxy = KsbApiServiceLocator.getServiceBus().getEndpoints(qname);

SynchronousServiceCallProxy sscp = return SynchronousServiceCallProxy.createInstance(servicesToProxy, callback, context, value1, value2);</programlisting>
    </sect2>
  </sect1>

  <sect1>
    <title>KSB Parameters</title>

    <para>Here is a comprehensive set of configuration parameters used to
    configure the Kuali Service Bus.</para>

    <sect2>
      <title>Core Parameters</title>

      <para><table frame="none">
          <title>Core Parameters</title>

          <tgroup cols="3">
            <colspec colname="c1" colnum="1" colwidth="1.0*"/>

            <colspec colname="c2" colnum="2" colwidth="1.0*"/>

            <colspec colname="c3" colnum="3" colwidth="1.0*"/>

            <thead>
              <row>
                <entry>Core</entry>

                <entry>Description</entry>

                <entry>Default</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>serviceServletUrl</entry>

                <entry>URL that maps to the KSB Servlet. It handles incoming
                requests from the service bus.</entry>

                <entry>${application.url}/remoting/</entry>
              </row>

              <row>
                <entry>rice.ksb.config.allowSelfSignedSSL</entry>

                <entry>Indicates if self-signed certificates are permitted for
                https communication on the service bus</entry>

                <entry>false</entry>
              </row>

              <row>
                <entry>application.id</entry>

                <entry>Application identifier for client application</entry>

                <entry/>
              </row>

              <row>
                <entry>keystore.file</entry>

                <entry>Path to the keystore file to use for security</entry>

                <entry/>
              </row>

              <row>
                <entry>keystore.alias</entry>

                <entry>Alias of the standalone server's key</entry>

                <entry/>
              </row>

              <row>
                <entry>keystore.password</entry>

                <entry>Password to access the keystore and the server's
                key</entry>

                <entry/>
              </row>

              <row>
                <entry>ksb.mode</entry>

                <entry>Mode in which to load the KSB module</entry>

                <entry>local</entry>
              </row>

              <row>
                <entry>ksb.url</entry>

                <entry>The URL of the KSB web application</entry>

                <entry>${application.url}/ksb</entry>
              </row>

              <row>
                <entry>rice.ksb.struts.config.files</entry>

                <entry>The file that defines the struts context for the KRice
                KSB struts module</entry>

                <entry>/ksb/WEB-INF/struts-config.xml</entry>
              </row>

              <row>
                <entry>dev.mode</entry>

                <entry>If <emphasis role="italic">true</emphasis>, application
                will not publish or consume services from the central service
                registry, but will maintain a local copy of the registry. This
                is intended only for client application development
                purposes.</entry>

                <entry>false</entry>
              </row>

              <row>
                <entry>bam.enabled</entry>

                <entry><para>If <emphasis role="italic">true</emphasis>, will
                monitor and log the service calls made and general business
                activity performed to the database. </para><para><emphasis
                role="italic">Recommendation</emphasis>: Enable this only for
                testing purposes, as there is a significant performance impact
                when enabled.</para></entry>

                <entry>false</entry>
              </row>

              <row>
                <entry>message.persistence</entry>

                <entry>If <emphasis role="italic">true</emphasis>, messages
                are stored in the database until sent. If <emphasis
                role="italic">false</emphasis>, they are stored in
                memory.</entry>

                <entry>true</entry>
              </row>

              <row>
                <entry>message.delivery</entry>

                <entry>Specifies whether messages are sent synchronously are
                asynchronously. Valid values are <emphasis
                role="italic">synchronous</emphasis> or <emphasis
                role="italic">async</emphasis></entry>

                <entry>async</entry>
              </row>

              <row>
                <entry>message.off</entry>

                <entry>If set to <emphasis role="italic">true</emphasis>, then
                messages will not be sent but will instead pile up in the
                message queue. Intended for development and debugging purposes
                only.</entry>

                <entry>false</entry>
              </row>

              <row>
                <entry>Routing.ImmediateExceptionRouting</entry>

                <entry>If <emphasis role="italic">true</emphasis>, messages
                will go immediately to exception routing if they fail, rather
                than being retried</entry>

                <entry>false</entry>
              </row>

              <row>
                <entry>RouteQueue.maxRetryAttempts</entry>

                <entry>Default number of times to retry messages that fail to
                be delivered successfully.</entry>

                <entry>5</entry>
              </row>

              <row>
                <entry>RouteQueue.maxRetryAttemptsOverride</entry>

                <entry>If set, will override the max retry setting for ALL
                services, even if they have their own custom retry
                setting.</entry>

                <entry/>
              </row>

              <row>
                <entry>ksb.org.quartz.*</entry>

                <entry>Can define any property beginning with <emphasis
                role="italic">ksb.org.quartz</emphasis> and it will be passed
                to the internal KSB quartz configuration as a property
                beginning with <emphasis role="italic">org.quartz</emphasis>
                (more details below)</entry>

                <entry/>
              </row>

              <row>
                <entry>useQuartzDatabase</entry>

                <entry>If <emphasis role="italic">true</emphasis>, then Quartz
                scheduler in Rice will use a database-backed job store; if
                <emphasis role="italic">false</emphasis>, then jobs will be
                stored in memory</entry>

                <entry>true</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>

      <sect3>
        <title>serviceServletUrl</title>

        <para>The URL that resolves to the KSB servlet that handles incoming
        requests from the service bus. All services exported onto the service
        bus use this value to construct their endpoint URLs when they are
        published to the service registry. See section below on configuring
        the <emphasis role="italic">KSBDispatcherServlet</emphasis>. This
        parameter should point to the absolute URL of where that servlet is
        mapped. It should include a trailing slash.</para>
      </sect3>

      <sect3>
        <title>application.id</title>

        <para>An identifier that indicates the name of the <emphasis
        role="italic">logical</emphasis> node on the service bus. If the
        application is running in a cluster, this should be the same for each
        machine in the cluster. This is used for namespacing of services,
        among other things. All services exported from the client application
        onto the service bus use this value as their default namespace unless
        otherwise specified.</para>
      </sect3>

      <sect3>
        <title>keystore.file, keystore.alias, keystore.password</title>

        <para>See the documentation below on keystore management.</para>
      </sect3>

      <sect3>
        <title>ksb.mode</title>

        <para>Mode in which to load the KSB module. Valid values are <emphasis
        role="italic">local</emphasis> and <emphasis
        role="italic">embedded</emphasis>. There is currently no difference in
        how the KSB module loads based on these settings. It will always try
        to load the KSB struts module if a <emphasis
        role="italic">KualiActionServlet</emphasis> is configured.</para>
      </sect3>

      <sect3>
        <title>ksb.url</title>

        <para>The URL of the KSB web application screens</para>
      </sect3>

      <sect3>
        <title>rice.ksb.struts.config.files</title>

        <para>The file that defines the struts context for the KRice KSB
        struts module. The struts module is loaded automatically if a
        <emphasis role="italic">KualiActionServlet</emphasis> is configured in
        the <emphasis role="italic">web.xml</emphasis>.</para>
      </sect3>

      <sect3>
        <title>dev.mode</title>

        <para>Indicates whether this node should export and consume services
        from the entire service bus. If set to <emphasis
        role="italic">false</emphasis>, then the machine will not register its
        services in the global service registry. Instead, it can only consume
        services that it has available locally. In addition to this, other
        nodes on the service bus will not be able to "see" this node and will
        therefore not forward any messages to it.</para>
      </sect3>

      <sect3>
        <title>message.persistence</title>

        <para>If <emphasis role="italic">true</emphasis>, then messages will
        be persisted to the datastore. Otherwise, they will only be stored in
        memory. If message persistence is not turned on and the server is
        shutdown while there are still messages that need to be sent, those
        messages will be lost. For a production environment, it is recommended
        that message persistence be set to <emphasis
        role="italic">true</emphasis>.</para>
      </sect3>

      <sect3>
        <title>message.delivery</title>

        <para>Can be set to either <emphasis
        role="italic">synchronous</emphasis> or <emphasis
        role="italic">async</emphasis>. If this is set to <emphasis
        role="italic">synchronous</emphasis>, then messages that are sent in
        an asynchronous fashion using the KSB API will instead be sent
        synchronously. This is useful in certain development and unit testing
        scenarios. For a production environment, it is recommended that
        message delivery be set to <emphasis
        role="italic">async</emphasis>.</para>
      </sect3>

      <sect3>
        <title>message.off</title>

        <para>If set to <emphasis role="italic">true</emphasis> then
        asynchronous messages will not be sent. In the case that message
        persistence is turned on, they will be persisted in the message store
        and can even be picked up later using the Message Fetcher. However, if
        message persistence is turned off, these messages will be lost. This
        can be useful in certain debugging or testing scenarios.</para>
      </sect3>

      <sect3>
        <title>RouteQueue.maxRetryAttempts</title>

        <para>Sets the default number of retries that will be executed if a
        message fails to be sent. This retry count can also be customized for
        a specific service. (See Exposing Services on the Bus)</para>
      </sect3>

      <sect3>
        <title>RouteQueue.timeIncrement</title>

        <para>Sets the default time increment between retry attempts. As with
        <emphasis role="italic">RouteQueue.maxRetryAttempts</emphasis> this
        can also be configured at the service level.</para>
      </sect3>

      <sect3>
        <title>RouteQueue.maxRetryAttemptsOverride</title>

        <para>If set with a number, it will temporarily set the retry attempts
        for ALL services going into exception routing. A good way to prevent
        all messages in a node that is having trouble from making it to
        exception routing is by setting the number arbitrarily high. The
        <emphasis role="italic">message.off</emphasis> param does the same
        thing.</para>
      </sect3>

      <sect3>
        <title>Routing.ImmediateExceptionRouting</title>

        <para>If set to <emphasis role="italic">true</emphasis>, then messages
        that fail to be sent will not be re-tried. Instead their <emphasis
        role="italic">MessageExceptionHandler</emphasis> will be invoked
        immediately.</para>
      </sect3>

      <sect3>
        <title>useQuartzDatabase</title>

        <para>When using the embedded Quartz scheduler started by the KSB,
        indicates whether that Quartz scheduler should store its entries in
        the database. If this is <emphasis role="italic">true</emphasis>, then
        the appropriate Quartz properties should be set as well (see
        ksb.org.quartz.* below).</para>
      </sect3>

      <sect3>
        <title>ksb.org.quartz.*</title>

        <para>Can be used to pass Quartz properties to the embedded Quartz
        scheduler. See the configuration documentation on the Quartz site.
        Essentially, any property prefixed with <emphasis
        role="bold">ksb.org.quartz</emphasis>. will have the "<emphasis
        role="italic">ksb.</emphasis>" portion stripped and will be sent as
        configuration parameters to the embedded Quartz scheduler.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>KSB Configurer Properties</title>

      <para>In addition to the configuration parameters available in the KRice
      configuration system, the <emphasis
      role="italic">KSBConfigurer</emphasis> bean has some properties that can
      be injected to configure it:</para>

      <sect3>
        <title>exceptionMessagingScheduler</title>

        <para>By default, the KSB uses an embedded Quartz scheduler for
        scheduling the retry of messages that fail to be sent. If desired, a
        Quartz scheduler can instead be injected into the KSBConfigurer and it
        will use that scheduler instead. See Quartz Scheduling for more
        detail.</para>
      </sect3>

      <sect3>
        <title>messageDataSource</title>

        <para>Specifies the <emphasis
        role="bold">javax.sql.DataSource</emphasis> to use for storing the
        asynchronous message queue. If not specified, this defaults to the
        DataSource injected into the RiceConfigurer.</para>

        <para>If this DataSource is injected, then the registryDataSource must
        also be injected, and vice-versa.</para>
      </sect3>

      <sect3>
        <title>registryDataSource</title>

        <para>Specifies the<emphasis role="bold">
        javax.sql.DataSource</emphasis> to use for reading and writing from
        the Service Registry. If not specified, this defaults to the
        DataSource injected into the RiceConfigurer.</para>

        <para>If this DataSource is injected, then the <emphasis
        role="bold">messageDataSource</emphasis> must also be injected, and
        vice-versa.</para>
      </sect3>

      <sect3>
        <title>overrideServices</title>

        <para>See Acquiring and invoking services</para>
      </sect3>

      <sect3>
        <title>Services</title>

        <para>See Acquiring and invoking services</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1>
    <title>JAX-RS / RESTful services</title>

    <para>Rice now allows allows RESTful (JAX-RS) services to be exported and
    consumed on the Kuali Service Bus (KSB). For some background on REST, see
    <link
    xlink:href="http://en.wikipedia.org/wiki/Representational_State_Transfer">http://en.wikipedia.org/wiki/Representational_State_Transfer</link>.</para>

    <para>For details on JAX-RS, see <link
    xlink:href="http://jcp.org/en/jsr/detail?id=311">JSR-311</link>.</para>

    <sect2>
      <title>Caveats</title>

      <para><itemizedlist>
          <listitem>
            <para>The KSB does <emphasis role="bold">not</emphasis> currently
            support "busSecure" (digital signing of requests &amp; responses)
            REST services. Attempting to set a REST service's "busSecure"
            property to "true" will result in a RiceRuntimeException being
            thrown. Rice can be customized to expose REST services in a secure
            way, e.g. using SSL and an authentication mechanism such as client
            certificates, but that is beyond the scope of this
            documentation.</para>
          </listitem>

          <listitem>
            <para>If the JAX-RS annotations on your resource class don't cover
            all of its public methods, then accessing the non-annotated
            methods over the bus will result in an Exception being
            thrown.</para>
          </listitem>
        </itemizedlist></para>
    </sect2>

    <sect2>
      <title>A Simple Example</title>

      <para>To expose a simple JAX-RS annotated service on the bus, you can
      follow this recipe for your spring configuration (which comes from the
      Rice unit tests):</para>

      <programlisting>&lt;!-- The service implementation you want to expose --&gt;

&lt;bean id="baseballCardCollectionService" class="org.kuali.rice.ksb.testclient1.BaseballCardCollectionServiceImpl"/&gt;


&lt;!-- The service definition which tells the KSB to expose our RESTful service --&gt;
&lt;bean class="org.kuali.rice.ksb.messaging.RESTServiceDefinition"&gt;
    &lt;property name="serviceNameSpaceURI" value="test" /&gt;


    &lt;!-- as noted earlier, the servicePath property of RESTServiceDefinition can't be set here  --&gt;


    &lt;!-- The service to expose.  Refers to the bean above --&gt;
    &lt;property name="service" ref="baseballCardCollectionService" /&gt;


    &lt;!-- The "Resource class", the class with the JAX-RS annotations on it.  Could be the same as the  --&gt;
    &lt;!-- service implementation, or could be different, e.g. an interface or superclass    --&gt;
  
    &lt;property name="resourceClass" 
value="org.kuali.rice.ksb.messaging.remotedservices.BaseballCardCollectionService" /&gt;


    &lt;!-- the name of the service, which will be part of the RESTful URLs used to access it --&gt;
    &lt;property name="localServiceName" value="baseballCardCollectionService" /&gt;
&lt;/bean&gt;
</programlisting>

      <para>The following java interface uses JAX-RS annotations to specify
      its RESTful interface:</para>

      <programlisting>// … eliding package and imports

@Path("/")
public interface BaseballCardCollectionService {
    @GET
    public List&lt;BaseballCard&gt; getAll();


    /**
      * gets a card by it's (arbitrary) identifier
      */
    @GET
    @Path("/BaseballCard/id/{id}")
    public BaseballCard get(@PathParam("id") Integer id);
    /**
      * gets all the cards in the collection with the given player name
      */
    @GET
    @Path("/BaseballCard/playerName/{playerName}")
    public List&lt;BaseballCard&gt; get(@PathParam("playerName") String playerName);


    /**
      * Add a card to the collection.  This is a non-idempotent method
      * (because you can add more than one of the same card), so we'll use @POST
      * @return the (arbitrary) numerical identifier assigned to this card by the service
      */
    @POST
    @Path("/BaseballCard")
    public Integer add(BaseballCard card);


    /**
      * update the card for the given identifier.  This will replace the card that was previously
      * associated with that identifier.
      */
    @PUT
    @Path("/BaseballCard/id/{id}")
    @Consumes("application/xml")
    public void update(@PathParam("id") Integer id, BaseballCard card);


    /**
      * delete the card with the given identifier.
      */
    @DELETE
    @Path("/BaseballCard/id/{id}")
    public void delete(@PathParam("id") Integer id);

    /**
      * This method lacks JAX-RS annotations
      */
    public void unannotatedMethod();
}</programlisting>

      <para>Acquisition and use of this service over the KSB looks just like
      that of any other KSB service. In the synchronous case:</para>

      <programlisting>BaseballCardCollectionService baseballCardCollection = (BaseballCardCollectionService) GlobalResourceLoader.getService(new QName("test", "baseballCardCollectionService");
);


List&lt;BaseballCard&gt; allMyMickeyMantles = baseballCardCollection.get("Mickey Mantle");
// baseballCardCollection.&lt;other service method&gt;(...)
// etc</programlisting>
    </sect2>

    <sect2>
      <title>Composite Services</title>

      <para>It is also possible to aggregate multiple Rice service
      implementations into a single RESTful service where requests to
      different sub-paths off of the base service URL can be handled by
      different underlying services. This may be desirable to expose a RESTful
      service that is more complex than could be cleanly factored into a
      single java service interface.</para>

      <para>The configuration for a composite RESTfull service looks a little
      bit different, and as might be expected given the one-to-many mapping
      from RESTful service to java services, there are some caveats to using
      that service over the KSB. Here is a simple example of a composite
      service definition (which also comes from the Rice unit tests):</para>

      <programlisting>&lt;bean class="org.kuali.rice.ksb.messaging.RESTServiceDefinition"&gt;
    &lt;property name="serviceNameSpaceURI" value="test" /&gt;
    &lt;property name="localServiceName" value="kms" /&gt;
    &lt;property name="resources"&gt;
        &lt;list&gt;
            &lt;ref bean="inboxResource"/&gt;
            &lt;ref bean="messageResource"/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="servicePath" value="/" /&gt;
&lt;/bean&gt;


&lt;!-- the beans referenced above are just JAX-RS annotated Java services --&gt;
&lt;bean id="inboxResource" class="org.kuali.rice.ksb.testclient1.InboxResourceImpl"&gt;
    &lt;!-- ... eliding bean properties ... --&gt;
&lt;/bean&gt;
&lt;bean id="messageResource" class="org.kuali.rice.ksb.testclient1.MessageResourceImpl"&gt;
    &lt;!-- ... eliding bean properties ... --&gt;

&lt;/bean&gt;</programlisting>

      <para>As you can see in the bean definition above, the service name is
      kms, so the base service url would by default (in a dev environment) be
      <emphasis
      role="bold">http://localhost:8080/kr-dev/remoting/kms/</emphasis>.
      Acquiring a composite service such as this one on the KSB will actually
      return you a <emphasis
      role="bold">org.kuali.rice.ksb.messaging.serviceconnectors.ResourceFacade</emphasis>,
      which allows you to get the individual java services in a couple of
      ways, as shown in the following simple example:</para>

      <programlisting>ResourceFacade kmsService =
 (ResourceFacade) GlobalResourceLoader.getService(
new QName(NAMESPACE, KMS_SERVICE));


// Get service by resource name (url path)
InboxResource inboxResource = kmsService.getResource("inbox");
// Get service by resource class
MessageResource messageResource = kmsService.getResource(MessageResource.class);</programlisting>
    </sect2>

    <sect2>
      <title>Additional Service Definition Properties</title>

      <para>There are some properties on the RESTServiceDefinition object that
      let you do more advanced configuration:</para>

      <sect3>
        <title>Providers</title>

        <para>JAX-RS Providers allow you to define:<itemizedlist>
            <listitem>
              <para>ExceptionMappers which will handle specific Exception
              types with specific Responses.</para>
            </listitem>

            <listitem>
              <para>MessageBodyReaders and MessageBodyWriters that will
              convert custom Java types to and from streams.</para>
            </listitem>

            <listitem>
              <para>ContextResolver providers allow you to create special
              JAXBContexts for specific types, which will gives you fine
              control over marshalling, unmarshalling, and validation.</para>
            </listitem>
          </itemizedlist></para>

        <para>The JAX-RS specification calls for classes annotated with
        @Provider to be automatically used in the underlying implementation,
        but the CXF project which Rice uses under the hood does not (at the
        time of this writing) support this configuration mechanism, so this
        configuration property is currently necessary.</para>
      </sect3>

      <sect3>
        <title>Extension Mappings</title>

        <para>Ordinarily you need to set your ACCEPT header to ask for a
        specific representation of a resource. ExtensionMappings let you map
        certain file extensions to specific media types for your RESTful
        service, so your URLs can then optionally specify a media type
        directly. For example you could map the <emphasis
        role="bold">.xml</emphasis> extension to the media type <emphasis
        role="bold">text/xml</emphasis>, and then tag .xml on to the end of
        your resource URL to specify that representation.</para>
      </sect3>

      <sect3>
        <title>Language Mappings</title>

        <para>language mappings allow you a way to control the the
        Content-Language header, which lets you specify which languages your
        service can accept and provide.</para>
      </sect3>

      <sect3>
        <title>Additional Information</title>

        <para>For more information on what these properties provide, it may be
        helpful to consult the JAX-RS specification, or the CXF
        documentation.</para>
      </sect3>
    </sect2>
  </sect1>
</chapter>
