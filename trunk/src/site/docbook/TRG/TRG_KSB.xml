<?xml version='1.0' encoding='UTF-8'?> 
<!--

    Copyright 2005-2012 The Kuali Foundation

    Licensed under the Educational Community License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.opensource.org/licenses/ecl2.php

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->
<chapter xml:id="TRG_KSB" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">
    <title>KSB</title>
    <sect1>
        <title>How to Use the KSB</title>
        <sect2>
            <title>Introduction</title>
            <para>The Kuali Service Bus (KSB) is a lightweight service bus designed to allow
                developers to quickly develop and deploy services for remote and local consumption.
                You can deploy services to the bus using Spring or programmatically. Services must
                be named when they are deployed to the bus. Services are acquired from the bus using
                their name. </para>
            <para>At the heart of the KSB is a service registry. This registry is a listing of all
                services available for consumption on the bus. The registry provides the bus with
                the information necessary to achieve load balancing, failover and more.</para>
        </sect2>
        <sect2>
            <title>Bean Based Services</title>
            <para>Typically, KSB programming is centered on exposing Spring-configured beans to
                other calling code using a number of different protocols. Using this paradigm the
                client developer and the organization can rapidly build and consume services, often
                a daunting challenge using other buses.</para>
            <figure>
                <title>Overview of Supported Service Protocols</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="../images/supported_service_protocols.png"/>
                    </imageobject>
                </mediaobject>
                </figure>
        </sect2>
        <sect2>
            <title>Diagram Notes</title>
            <para>This drawing is conceptual and not representative of a true deployment
                architecture. Essentially, the KSB is a registry with service calling behavior on
                the client end (Java client). All policies and behaviors (Asynchronous as opposed to
                Synchronous) are coordinated on the client. The client offers some very attractive
                messaging features: <itemizedlist>
                    <listitem>
                        <para><emphasis role="bold">Synchronization</emphasis> of message sending
                            with currently running transaction (meaning all messages sent during a
                            transaction are ONLY sent if the transaction is successfully committed)
                        </para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">Failover</emphasis> - If a call to a service
                            comes back with a 404 (or various other network-related errors), it will
                            try to call other services of the same name on the bus. This is for both
                            sync and async calls. </para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">Load balancing</emphasis> - Clients will
                            round-robin call services of the same name on the bus. Proxy instances,
                            however, are bound to single machines if you want to keep a line of
                            communication open to a single machine for long periods of time. </para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">Topics and Queues</emphasis>
                        </para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">Persistent messages</emphasis> - When using
                            message persistence a message cannot be lost. It will be persisted until
                            it is sent. </para>
                    </listitem>
                </itemizedlist></para>
        </sect2>
    </sect1>
    <sect1>
        <title>Details of Supported Service Protocols</title>
        <sect2>
            <title>Java Rice Client</title>
            <sect3>
                <title>As Consumer</title>
                <para>If configured for the KSB, a Java Rice Client can invoke any service in the
                    KSB Registry using these protocols:<orderedlist>
                        <listitem>
                            <para>Synchronously <itemizedlist>
                                    <listitem>
                                        <para>SOAP WS p2p using KSB Spring configuration </para>
                                    </listitem>
                                    <listitem>
                                        <para>Java call if it is within the same JVM </para>
                                    </listitem>
                                    <listitem>
                                        <para>Spring HTTP Remoting </para>
                                    </listitem>
                                </itemizedlist></para>
                        </listitem>
                        <listitem>
                            <para>Asynchronously <itemizedlist>
                                    <listitem>
                                        <para>Messaging Queues – As a Consumer, a Java Rice Client
                                            can invoke a one-shot deal for calling a KSB-registered
                                            service asynchronously </para>
                                    </listitem>
                                    <listitem>
                                        <para>Java, SOAP, Spring HTTP Remoting </para>
                                    </listitem>
                                    <listitem>
                                        <para>Messaging Topics - As a Consumer listening to a topic,
                                            the Java Rice Client will receive a broadcast message
                                        </para>
                                    </listitem>
                                </itemizedlist></para>
                        </listitem>
                    </orderedlist></para>
            </sect3>
            <sect3>
                <title>As Producer</title>
                <para>You can register Spring-defined services in the KSB Registry through the KSB
                    Configurer. Consumers can call these services as described in other
                    sections.</para>
            </sect3>
        </sect2>
        <sect2>
            <title>Any Java Client</title>
            <sect3>
                <title>As Consumer</title>
                <para>A <emphasis role="bold">Java Client</emphasis>, regardless of whether or not
                    it's a Rice Client configured for the KSB, can invoke any web service:<orderedlist>
                        <listitem>
                            <para>As a SOAP WS p2p using a straight-up WS call through XFire (CXF),
                                Axis, etc. If the external web service is not registered on the KSB,
                                the Java client must discover the service on its own. </para>
                        </listitem>
                        <listitem>
                            <para>Through Java if they are within the same JVM </para>
                        </listitem>
                        <listitem>
                            <para>Through Spring HTTP Remoting; you must know the endpoint URL of
                                the service. </para>
                        </listitem>
                    </orderedlist></para>
            </sect3>
            <sect3>
                <title>As Producer</title>
                <orderedlist>
                    <listitem>
                        <para>Currently, you can't leverage the KSB and its registry for exposing
                            any of its services. It is possible to bring up the registry and
                            register services without the rest of the KSB. </para>
                    </listitem>
                    <listitem>
                        <para>A Java Client can expose its web services directly using XFire (CXF),
                            Axis, etc. </para>
                    </listitem>
                    <listitem>
                        <para>You can bring up only the registry for discovery. However, the
                            registry can't be a 'service;' it can only be a piece of code talking to
                            a database. </para>
                    </listitem>
                </orderedlist>
            </sect3>
        </sect2>
        <sect2>
            <title>Non-Java/Non-Rice Client</title>
            <sect3>
                <title>As Consumer</title>
                <para>A <emphasis role="bold">non-Java/non-Rice Client</emphasis> that knows nothing
                    about the KSB or its registry can only invoke web services synchronously using:<itemizedlist>
                        <listitem>
                            <para>SOAP WS p2p using straight-up WS call through native
                                language-specific WS libs </para>
                        </listitem>
                        <listitem>
                            <para>Discovery cannot be handled by leveraging the KSB Registry at this
                                time. </para>
                        </listitem>
                    </itemizedlist></para>
            </sect3>
            <sect3>
                <title>As Producer</title>
                <orderedlist>
                    <listitem>
                        <para>Currently cannot register services on KSB in registry </para>
                    </listitem>
                    <listitem>
                        <para>Can still produce services, but they can’t be called leveraging the
                            KSB; clients need to discover and invoke the services directly (on their
                            own). </para>
                    </listitem>
                </orderedlist>
            </sect3>
        </sect2>
        <sect2>
            <title>Future Enhancement to KSB: Remote the KSB Registry as a Service</title>
            <para>These are represented by the red lines in the diagram.</para>
            <para>
                <orderedlist>
                    <listitem>
                        <para>Expose the KSB registry as a SOAP available service, allowing non-Java
                            clients to easily have: <itemizedlist>
                                <listitem>
                                    <para>A method to discover available services and what protocols
                                        they can be invoked through </para>
                                </listitem>
                                <listitem>
                                    <para>A callback URL that is passed to the registry to let the
                                        publishers and consumers know when the KSB Registry has been
                                        updated </para>
                                </listitem>
                                <listitem>
                                    <para>A method to register external web services, their WSDLs,
                                        and other meta-data in the KSB Registry for discovery
                                    </para>
                                </listitem>
                                <listitem>
                                    <para>A connector to make creation of an XFire (CXF) dynamic
                                        SOAP object for Java clients that want to talk to these
                                        services without having a backing Java interface. (This may
                                        require some changes in the proxies that facilitate Async
                                        messaging.) </para>
                                </listitem>
                            </itemizedlist></para>
                    </listitem>
                    <listitem>
                        <para>Certainly, any <emphasis role="italic">Java Rice Client</emphasis>
                            could invoke any of these services either p2p via SOAP WS or through the
                            Messaging protocols. </para>
                    </listitem>
                </orderedlist>
            </para>
        </sect2>
        <sect2>
            <title>Additional Options Once Registry is a Service:</title>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>Bring up centralized queues and topics that sit on top of a PHP or
                            another deployed web service </para>
                    </listitem>
                </itemizedlist>
            </para>
        </sect2>
    </sect1>
    <sect1>
        <title>Configuring the KSB Client in Spring</title>
        <sect2>
            <title>Overview</title>
            <para>The Kuali Service Bus (KSB) is installed as a Kuali Rice (Rice) Module using Spring.
                Here is an example XML snippet showing how to configure Rice and KSB using
                Spring:</para>
            <programlisting>&lt;bean id="rice" class="org.kuali.rice.core.config.RiceConfigurer">
    &lt;property name="dataSource" ref="workflowDataSource" />
    &lt;property name="nonTransactionalDataSource" ref="nonTransactionalWorkflowDataSource" />
    &lt;property name="transactionManager" ref="myJtaTransactionManager" />
    &lt;property name="userTransaction" ref="myJtaUserTransaction" />
    &lt;!—- additional rice configuration here -->
    &lt;property name="properties">
        &lt;props>
            &lt;prop key="service.namespace">MYAPP&lt;/prop>
            &lt;prop key="message.persistence">true&lt;/prop>
            &lt;prop key="message.delivery">asynchronous&lt;/prop>
            &lt;prop key="Routing.ImmediateExceptionRouting">false&lt;/prop>
            &lt;prop key="RouteQueue.timeIncrement">1000&lt;/prop>
            &lt;prop key="RouteQueue.maxRetryAttempts">3&lt;/prop>
            &lt;prop key="useQuartzDatabase">true&lt;/prop>
            &lt;prop key="ksb.org.quartz.scheduler.instanceId">AUTO&lt;/prop>
            &lt;prop key="ksb.org.quartz.scheduler.instanceName">KSBScheduler&lt;/prop>
            &lt;prop key="ksb.org.quartz.jobStore.isClustered">true&lt;/prop>
            &lt;prop key="ksb.org.quartz.jobStore.tablePrefix">KR_QRTZ_&lt;/prop>
        &lt;/props>
    &lt;/property>

   &lt;property name="modules">
        &lt;list>
            &lt;!—- additional rice module configuration here -->
            &lt;bean class="org.kuali.rice.ksb.messaging.configorg.kuali.rice.ksb.messaging.config.KSBConfigurer">
                &lt;property name="serviceServletUrl" value="http://yourlocalip:8080/myapp/remoting" />
            &lt;/bean>
        &lt;/list>
    &lt;/property>
&lt;/bean></programlisting>
        </sect2>
        <sect2>
            <title>Spring Property Configuration</title>
            <para>The <emphasis role="italic">KSBTestHarnessSpring.xml</emphasis> located in the
                project folder under /ksb/src/test/resources/ is a good starting place to explore
                KSB configuration in depth. The first thing the file does is use a
                PropertyPlaceholderConfigurer to bring tokens into the Spring file for runtime
                configuration. The source of the tokens is the xml file: ksb-test-config.xml located
                in the /ksb/src/test/resources/META-INF directory. </para>
            <programlisting>&lt;bean id="config" class="org.kuali.rice.core.config.spring.ConfigFactoryBean">
    &lt;property name="configLocations">
        &lt;list>
            &lt;value>classpath:META-INF/ksb-test-config.xml&lt;/value>
        &lt;/list>
    &lt;/property>
&lt;/bean>


&lt;bean id="configProperties" class="org.springframework.beans.factory.config.MethodInvokingFactoryBean">
    &lt;property name="targetObject" ref="config" />
    &lt;property name="targetMethod" value="getProperties" />
&lt;/bean>


&lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
    &lt;property name="properties" ref="configProperties" />
&lt;/bean></programlisting>
            <note><para>
                <itemizedlist>
                    <listitem>
                        <para>Properties are passed into the Rice configurer directly. These could
                            be props loaded from Spring and injected into the bean directly. </para>
                    </listitem>
                    <listitem>
                        <para>You could use the Rice configuration subsystem for configuration.
                        </para>
                    </listitem>
                    <listitem>
                        <para>A JTA TransactionManager and UserTransaction are also being injected
                            into the RiceConfigurer. </para>
                    </listitem>
                </itemizedlist>
            </para></note>
            <para>As mentioned above, this allows tokens to be used in the Spring file. If you are
                not familiar with tokens, they look like this in the Spring file:
                ${datasource.pool.maxSize}</para>
            <para>Let's take a look at the ksb-test-config.xml file:</para>
            <programlisting>&lt;config>
    &lt;param name="config.location">classpath:META-INF/common-derby-connection-config.xml&lt;/param>
    &lt;param name="config.location">classpath:META-INF/common-config-test-locations.xml&lt;/param>
    &lt;param name="client1.location">${basedir}/src/test/clients/TestClient1&lt;/param>
    &lt;param name="client2.location">${basedir}/src/test/clients/TestClient2&lt;/param>
    &lt;param name="ksb.client1.port">9913&lt;/param>
    &lt;param name="ksb.client2.port">9914&lt;/param>
    &lt;param name="ksb.testharness.port">9915&lt;/param>
    &lt;param name="threadPool.size">1&lt;/param>
    &lt;param name="threadPool.fetchFrequency">3000&lt;/param>
    &lt;param name="bus.refresh.rate">3000&lt;/param>
    &lt;param name="bam.enabled">true&lt;/param>
    &lt;param name="transaction.timeout">3600&lt;/param>
    &lt;param name="keystore.alias">rice&lt;param>
    &lt;param name="keystore.password">keystorepass&lt;/param>
    &lt;param name="keystore.file">${basedir}/src/test/resources/keystore/ricekeystore&lt;/param>
    &lt;param name="keystore.location">${basedir}/src/test/resources/keystore/ricekeystore&lt;/param>
    &lt;param name="use.clearDatabaseLifecycle">true&lt;/param>
    &lt;param name="use.sqlDataLoaderLifecycle">true&lt;/param>
    &lt;!-- bus messaging props -->
    &lt;param name="message.delivery">synchronous&lt;/param>
    &lt;param name="message.persistence">true&lt;/param>
    &lt;param name="useQuartzDatabase">false&lt;/param>
    &lt;param name="config.location">${additional.config.locations}&lt;/param>
    &lt;param name="config.location">${alt.config.location}&lt;/param>
&lt;/config></programlisting>
            <para>This is an XML file for configuring key value pairs. When used in conjunction with
                Spring tokenization and the PropertyPlaceHolderConfigurer bean, the parameter name
                must be equal to the key value in the Spring file so that the properties propagate
                successfully. </para>
        </sect2>
        <sect2>
            <title>Spring JTA Configuration</title>
            <para>When doing persistent messaging it is best practice to use JTA as your transaction
                manager. This ensures that the messages you are sending are synchronized with the
                current executed transaction in your application. It also allows message persistence
                to be put in a different database than the application’s logic if needed. Currently,
                    <emphasis role="italic">KSBTestHarnessSpring.xml</emphasis> uses JOTM to
                configure JTA without an application server. Atomikos is another JTA product that
                could be used in the future for Rice and you could consider using it instead of
                JOTM. Below is the bean definition for JOTM that you can find in Spring:</para>
            <programlisting>&lt;bean id="jotm" class="org.springframework.transaction.jta.JotmFactoryBean">
    &lt;property name="defaultTimeout" value="${transaction.timeout}"/>

&lt;/bean>
&lt;bean id="dataSource" class="org.kuali.rice.database.XAPoolDataSource">
    &lt;property name="transactionManager" ref="jotm" />
    &lt;property name="driverClassName" value="${datasource.driver.name}" />
    &lt;property name="url" value="${datasource.url}" />
    &lt;property name="maxSize" value="${datasource.pool.maxSize}" />
    &lt;property name="minSize" value="${datasource.pool.minSize}" />
    &lt;property name="maxWait" value="${datasource.pool.maxWait}" />
    &lt;property name="validationQuery" value="${datasource.pool.validationQuery}" />
    &lt;property name="username" value="${datasource.username}" />
    &lt;property name="password" value="${datasource.password}" />

&lt;/bean></programlisting>
            <para>Atomikos’ configuration is very nearly the same. Configure the TransactionManager,
                UserTransaction, and a DataSource. If using JOTM, use the Rice XAPoolDataSource
                class as your data source because it addresses some bugs in the
                StandardXAPoolDataSource, which extends from this class.</para>
        </sect2>
        <sect2>
            <title>Put JTA and the Rice Config object in the RiceConfigurer</title>
            <para>Next, you must inject the JOTM into the RiceConfigurer:</para>
            <programlisting>&lt;bean id="rice" class="org.kuali.rice.core.config.RiceConfigurer">
    &lt;property name=" serviceNamespace" value="KEW" />
    &lt;property name="dataSource" ref="dataSource" />
    &lt;property name="transactionManager" ref="jotm" />
    &lt;property name="userTransaction" ref="jotm" />
    &lt;property name="rootConfig" ref="config" />
    &lt;property name="modules">    
&lt;...more.../></programlisting>
            <para>Configuring JTA from an appserver is no different, except the TransactionManager
                and UserTransaction are going to be fetched using a JNDI FactoryBean from
                Spring.</para>
            <note><para>You set the serviceNamespace property in the example above by injecting the name
                into the RiceConfigurer. You can do this instead of setting the property in the
                configuration system.</para></note>
        </sect2>
        <sect2>
            <title>Configuring KSB without JTA</title>
            <para>You can configure KSB by injecting a PlatformTransactionManager into the
                KSBConfigurer. <itemizedlist>
                    <listitem>
                        <para>This eliminates the need for JTA. Behind the scenes, KSB uses Apache's
                            OJB as its Object Relational Mapping. </para>
                    </listitem>
                    <listitem>
                        <para>Before you can use PlatformTransactionManager, you must have a client
                            application set up the OJB so that KSB can use it. </para>
                    </listitem>
                </itemizedlist></para>
            <para>This is a good option if you are an OJB shop and you want to continue using your
                current setup without introducing JTA into your stack. Normally, when a JTA
                transaction is found, the message is not sent until the transaction commits. In this
                case, the message is sent immediately.</para>
            <para>Let's take a look at the <emphasis role="italic"
                    >KSBTestHarnessNoJtaSpring.xml</emphasis> file. Instead of JTA, the following
                    transaction and DataSource configuration is declared:</para>
            <programlisting>&lt;bean id="ojbConfigurer" class="org.springmodules.orm.ojb.support.LocalOjbConfigurer" />


&lt;bean id="transactionManager" class="org.springmodules.orm.ojb.PersistenceBrokerTransactionManager">
    &lt;property name="jcdAlias" value="dataSource" />
&lt;/bean>


&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
    &lt;property name="driverClassName">
        &lt;value>${datasource.driver.name}&lt;/value>
    &lt;/property>
    &lt;property name="url">
        &lt;value>${datasource.url}&lt;/value>
    &lt;/property>
    &lt;property name="username">
        &lt;value>${datasource.username}&lt;/value>
    &lt;/property>
    &lt;property name="password">
        &lt;value>${datasource.password}&lt;/value>
    &lt;/property>
&lt;/bean></programlisting>
            <para>The RiceNoJtaOJB.properties file needs to include the Rice connection factory
                property value:</para>
            <programlisting>ConnectionFactoryClass=org.springmodules.orm.ojb.support.RiceDataSourceConnectionFactory</programlisting>
            <para>Often, the DataSource is pulled from JNDI using a Spring FactoryBean. Next, we
                inject the DataSource and transactionManager (now a Spring
                PlatformTransactionManager). </para>
            <programlisting>&lt;bean id="rice" class="org.kuali.rice.core.config.RiceConfigurer">
    &lt;property name="serviceNamespace" value="KEW" />
    &lt;property name="dataSource" ref="dataSource" />
    
&lt;property name="nonTransactionalDataSource" ref="dataSource" />
    &lt;property name="rootConfig" ref="config" />
    &lt;property name="modules">
        &lt;list>
            &lt;bean class="org.kuali.rice.ksb.messaging.config.KSBConfigurer">
                &lt;property name="serviceServletUrl" value="http://yourlocalip:${ksb.testharness.port}/en-test/remoting/" />
                &lt;property name="platformTransactionManager" ref="transactionManager" />

&lt;... more .../></programlisting>
            <para>Notice that the transactionManager is injected into the KSBConfigurer directly.
                This is because only KSB, and not Rice, supports this type of configuration. The
                DataSource is injected normally. When doing this, the OJB setup is entirely in the
                hands of the client application. That doesn't mean anything more than providing an
                OJB.properties object at the root of the classpath so OJB can load itself. KSB will
                automatically register its mappings with OJB, so they don't need to be included in
                the repository.xml file.</para>
        </sect2>
        <sect2>
            <title>web.xml Configuration</title>
            <para>To allow external bus clients to invoke services on the bus-connected node, you
                must configure the KSBDispatcherServlet in the web applications web.xml file. For
                example:</para>
            <programlisting>&lt;servlet>
    &lt;servlet-name>remoting&lt;/servlet-name>
    &lt;servlet-class>org.kuali.rice.ksb.messaging.servlet.KSBDispatcherServlet&lt;/servlet-class>
    &lt;load-on-startup>1&lt;/load-on-startup>

&lt;/servlet>

&lt;servlet-mapping>
    &lt;servlet-name>remoting&lt;/servlet-name>
    &lt;url-pattern>/remoting/*&lt;/url-pattern>
&lt;/servlet-mapping></programlisting>
            <para>This allows bus-exposed services to be accessed at a URL like <emphasis
                    role="bold">http://yourlocalip:8080/myapp/remoting/[KSB:service
                name]</emphasis>. Notice how this URL corresponds to the configured <emphasis
                    role="bold">serviceServletUrl</emphasis> property on the KSBConfigurer. </para>
        </sect2>
        <sect2>
            <title>Configuration Parameters</title>
            <para>The service bus leverages the Rice configuration system for its configuration.
                Here is a comprehensive set of configuration parameters that you can use to
                configure the Kuali Service Bus:</para>
            <para>
                <table frame="none">
                    <title>KSB Configuration Parameters</title>
                    <tgroup cols="3">
                        <colspec colname="c1" colnum="1" colwidth="1.0*"/>
                        <colspec colname="c2" colnum="2" colwidth="1.0*"/>
                        <colspec colname="c3" colnum="3" colwidth="1.0*"/>
                        <thead>
                            <row>
                                <entry>Parameter</entry>
                                <entry>Required</entry>
                                <entry>Default Value</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>bam.enabled</entry>
                                <entry>Whether Business Action Messaging is enabled</entry>
                                <entry>false</entry>
                            </row>
                            <row>
                                <entry>bus.refresh.rate</entry>
                                <entry>How often the service bus will update the services it has
                                    deployed in minutes.</entry>
                                <entry>30</entry>
                            </row>
                            <row>
                                <entry>bus.services</entry>
                                <entry>A list of services to deploy on the bus.</entry>
                                <entry/>
                            </row>
                            <row>
                                <entry>bus.storeAndForward</entry>
                                <entry>Determines whether to persist the call to the remove service
                                    on the bus before invoking the service.</entry>
                                <entry/>
                            </row>
                            <row>
                                <entry>dev.mode</entry>
                                <entry>no</entry>
                                <entry>false</entry>
                            </row>
                            <row>
                                <entry>service.namespace</entry>
                                <entry>yes</entry>
                                <entry>None</entry>
                            </row>
                            <row>
                                <entry>message.persistence</entry>
                                <entry>no</entry>
                                <entry>false</entry>
                            </row>
                            <row>
                                <entry>message.delivery</entry>
                                <entry>no</entry>
                                <entry>asynchronous</entry>
                            </row>
                            <row>
                                <entry>message.off</entry>
                                <entry>no</entry>
                                <entry>false</entry>
                            </row>
                            <row>
                                <entry>ksb.mode</entry>
                                <entry>The mode that KSB will run in; choices are "local",
                                    "embedded", or "remote".</entry>
                                <entry>local</entry>
                            </row>
                            <row>
                                <entry>ksb.url</entry>
                                <entry>The base URL of KSB services and pages.</entry>
                                <entry>${application.url}/ksb</entry>
                            </row>
                            <row>
                                <entry>RouteQueue.maxRetryAttempts</entry>
                                <entry>no</entry>
                                <entry>7</entry>
                            </row>
                            <row>
                                <entry>RouteQueue.timeIncrement</entry>
                                <entry>no</entry>
                                <entry>1 hour</entry>
                            </row>
                            <row>
                                <entry>Routing.ImmediateExceptionRouting</entry>
                                <entry>no</entry>
                                <entry>false</entry>
                            </row>
                            <row>
                                <entry>RouteQueue.maxRetryAttemptsOverride</entry>
                                <entry>no</entry>
                                <entry>None</entry>
                            </row>
                            <row>
                                <entry>rice.ksb.batch.mode</entry>
                                <entry>A service bus mode suitable for running batch jobs; it, like
                                    the KSB dev mode, runs only local services.</entry>
                                <entry>local</entry>
                            </row>
                            <row>
                                <entry>rice.ksb.struts.config.files</entry>
                                <entry>The struts-config.xml configuration file that the KSB portion
                                    of the Rice application will use.</entry>
                                <entry>/ksb/WEB-INF/struts-config.xml</entry>
                            </row>
                            <row>
                                <entry>threadPool.size</entry>
                                <entry>The size of the KSB thread pool.</entry>
                                <entry>5</entry>
                            </row>
                            <row>
                                <entry>useQuartzDatabase</entry>
                                <entry>no</entry>
                                <entry>false</entry>
                            </row>
                            <row>
                                <entry>ksb.org.quartz.*</entry>
                                <entry>no</entry>
                                <entry>None</entry>
                            </row>
                            <row>
                                <entry>rice.ksb.config.allowSelfSignedSSL</entry>
                                <entry>no</entry>
                                <entry>false</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>
            <sect3>
                <title>dev.mode</title>
                <para>Indicates whether this node should export and consume services from the entire
                    service bus. If set to true, then the machine will not register its services in
                    the global service registry. Instead, it can only consume services that it has
                    available locally. In addition to this, other nodes on the service bus will not
                    be able to "see" this node and will therefore not forward any messages to
                    it.</para>
            </sect3>
            <sect3>
                <title>service.namespace</title>
                <para>An identifier that indicates the name of the "logical" node on the service
                    bus. If the application is running in a cluster, this will typically be the same
                    for each machine in the cluster. The service namespace is used in exactly the
                    way it sounds, for namespacing of services, among other things. This can also be
                    set directly on RiceConfigurer using the serviceNamespace property. </para>
            </sect3>
            <sect3>
                <title>message.persistence</title>
                <para>If <emphasis role="italic">true</emphasis>, then messages will be persisted to
                    the datastore. Otherwise, they will only be stored in memory. If message
                    persistence is not turned on and the server is shutdown while there are still
                    messages that need to be sent, those messages will be lost. For a production
                    environment, it is recommended that you set message.persistence to <emphasis
                        role="italic">true</emphasis>.</para>
            </sect3>
            <sect3>
                <title>message.delivery</title>
                <para>Can be set to either <emphasis role="italic">synchronous</emphasis> or
                        <emphasis role="italic">asynchronous</emphasis>. If this is set to
                    synchronous, then messages that are sent in an asynchronous fashion using the
                    KSB API will instead be sent synchronously. This is useful in certain
                    development and unit testing scenarios. For a production environment, it is
                    recommended that you set message delivery to <emphasis role="italic"
                        >asynchronous</emphasis>.</para>
                <note><para>It is strongly recommended that you set <emphasis role="bold"
                        >message.delivery</emphasis> to <emphasis role="italic"
                        >asynchronous</emphasis> for all cases except for when implementing
                    automated tests or short-lived programs that interact with the service
                    bus.</para></note>
            </sect3>
            <sect3>
                <title>message.off</title>
                <para>If set to true, then asynchronous messages will not be sent. In the case that
                    message persistence is turned on, they will be persisted in the message store
                    and can even be picked up later using the Message Fetcher. However, if message
                    persistence is turned off, these messages will be lost. This can be useful in
                    certain debugging or testing scenarios.</para>
            </sect3>
            <sect3>
                <title>RouteQueue.maxRetryAttempts</title>
                <para>Sets the default number of retries that will be executed if a message fails to
                    be sent. You can also customize this retry count for a specific service (see
                    Exposing Services on the Bus).</para>
            </sect3>
            <sect3>
                <title>RouteQueue.timeIncrement</title>
                <para>Sets the default time increment between retry attempts. As with
                    RouteQueue.maxRetryAttempts, you can also configure this at the service
                    level.</para>
            </sect3>
            <sect3>
                <title>Routing.ImmediateExceptionRouting</title>
                <para>If set to <emphasis role="italic">true</emphasis>, then messages that fail to
                    be sent will not be retried. Instead, their MessageExceptionHandler will be
                    invoked immediately.</para>
            </sect3>
            <sect3>
                <title>RouteQueue.maxRetryAttemptsOverride</title>
                <para>If set with a number, it will temporarily set the retry attempts for ALL
                    services going into exception routing. You can set the number arbitrarily high
                    to prevent all messages in a node from making it to exception routing if they
                    are having trouble. The message.off param produces the same result.</para>
            </sect3>
            <sect3>
                <title>useQuartzDatabase</title>
                <para>When using the embedded Quartz scheduler started by the KSB, indicates whether
                    that Quartz scheduler should store its entries in the database. If this is true,
                    then the appropriate Quartz properties should be set as well. (See
                    ksb.org.quartz.* below).</para>
            </sect3>
            <sect3>
                <title>ksb.org.quartz.*</title>
                <para>Can be used to pass Quartz properties to the embedded Quartz scheduler. See
                    the configuration documentation on the <link
                        xlink:href="http://www.quartz-scheduler.org/">Quartz site</link>.
                    Essentially, any property prefixed with <emphasis role="italic"
                        >ksb.org.quartz</emphasis>. will have the "ksb." portion stripped and will
                    be sent as configuration parameters to the embedded Quartz scheduler.</para>
            </sect3>
            <sect3>
                <title>rice.ksb.config.allowSelfSignedSSL</title>
                <para>If <emphasis role="italic">true</emphasis>, then the bus will allow
                    communication using the <emphasis role="bold">https</emphasis> protocol between
                    machines with self-signed certificates. By default, this is not permitted and if
                    attempted you will receive an error message like this:</para>
                <note><para>It is best practice to only set this to 'true' in non-production
                    environments!</para></note>
            </sect3>
        </sect2>
        <sect2>
            <title>KSBConfigurer Properties</title>
            <para>In addition to the configuration parameters that you can specify using the Rice
                configuration system, the KSBConfigurer bean itself has some properties that can be
                injected in order to configure it:</para>
            <sect3>
                <title>exceptionMessagingScheduler</title>
                <para>By default, KSB uses an embedded Quartz scheduler for scheduling the retry of
                    messages that fail to be sent. If desired, a Quartz scheduler can instead be
                    injected into the KSBConfigurer and it will use that scheduler instead. See
                    Quartz Scheduling for more detail.</para>
            </sect3>
            <sect3>
                <title>messageDataSource</title>
                <para>Specifies the javax.sql.DataSource to use for storing the asynchronous message
                    queue. If not specified, this defaults to the DataSource injected into the
                    RiceConfigurer.</para>
                <para>If this DataSource is injected, then the registryDataSource must also be
                    injected and vice-versa. </para>
            </sect3>
            <sect3>
                <title>nonTransactionalMessageDataSource</title>
                <para>Specifies the javax.sql.DataSource to use that matches the messageDataSource
                    property. This datasource instance must not be transactional. If not specified,
                    this defaults to the nonTransactionalDataSource injected into the
                    RiceConfigurer.</para>
            </sect3>
            <sect3>
                <title>registryDataSource</title>
                <para>Specifies the javax.sql.DataSource to use for reading and writing from the
                    Service Registry. If not specified, this defaults to the DataSource injected
                    into the RiceConfigurer.</para>
                <para>If this DataSource is injected, then the messageDataSource must also be
                    injected and vice-versa.</para>
            </sect3>
            <sect3>
                <title>services</title>
                <para>Specifies a list of Java service definitions relating to SOAP to use as part
                    of messaging.</para>
            </sect3>
        </sect2>
        <sect2>
            <title>KSB Configurer</title>
            <para>The application needs to do one more thing to begin publishing services to the
                bus: Configure the KSBConfigurer object. This can be done using Spring or
                programmatically. We'll use Spring because it's the easiest way to get things
                configured:</para>
            <programlisting>&lt;bean id="jotm" class="org.springframework.transaction.jta.JotmFactoryBean">
    &lt;property name="defaultTimeout" value="${transaction.timeout}"/>
&lt;/bean>



&lt;bean id="dataSource" class=" org.kuali.rice.core.database.XAPoolDataSource ">
    &lt;property name="transactionManager">
        &lt;ref local="jotm" />
    &lt;/property>
    &lt;property name="driverClassName">
        &lt;value>oracle.jdbc.driver.OracleDriver&lt;/value>
    &lt;/property>
    &lt;property name="maxSize">
        &lt;value>25&lt;/value>
    &lt;/property>
    &lt;property name="minSize">
        &lt;value>2&lt;/value>
    &lt;/property>
    &lt;property name="maxWait">
        &lt;value>5000&lt;/value>
    &lt;/property>
    &lt;property name="validationQuery">
        &lt;value>select 1 from dual&lt;/value>
    &lt;/property>
    &lt;property name="url">
        &lt;value>jdbc:oracle:thin:@129.79.44.172:1521:XE&lt;/value>
    &lt;/property>
    &lt;property name="username">
        &lt;value>myapp&lt;/value>
    &lt;/property>
    &lt;property name="password">
        &lt;value>password&lt;/value>
    &lt;/property>
&lt;/bean>


&lt;bean id="nonTransactionalDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
    &lt;property name="driverClassName">
        &lt;value>oracle.jdbc.driver.OracleDriver&lt;/value>
    &lt;/property>
    &lt;property name="maxActive">
        &lt;value>50&lt;/value>
    &lt;/property>
    &lt;property name="minIdle">
        &lt;value>7&lt;/value>
    &lt;/property>
    &lt;property name="initialSize">
        &lt;value>7&lt;/value>
    &lt;/property>
    &lt;property name="validationQuery">
        &lt;value>select 1 from dual&lt;/value>
    &lt;/property>
    &lt;property name="url">
        &lt;value>jdbc:oracle:thin:@129.79.44.172:1521:XE&lt;/value>
    &lt;/property>
    &lt;property name="username">
        &lt;value>myapp&lt;/value>
    &lt;/property>
    &lt;property name="password">
        &lt;value>password&lt;/value>
    &lt;/property>
    &lt;property name="accessToUnderlyingConnectionAllowed">
        &lt;value>true&lt;/value>
    &lt;/property>
&lt;/bean>

    &lt;bean id="rice" class="org.kuali.rice.core.config.RiceConfigurer">
        &lt;property name="serviceNamespace" value="MyApp" />
        &lt;property name="dataSource" ref="dataSource" />
        &lt;property name="nonTransactionalDataSource" ref="nonTransactionalDataSource" />
        &lt;property name="transactionManager" ref="jotm" />
        &lt;property name="userTransaction" ref="jotm" />
        &lt;property name="ksbConfigurer">
            &lt;bean class="org.kuali.rice.ksb.messaging.config.KSBConfigurer"/>
        &lt;/property>
&lt;/bean></programlisting>
            <para>The application is now ready to deploy services to the bus. Let's take a quick
                look at the Spring file above and what's going on there: The following configures
                JOTM, which is currently required to run KSB. </para>
            <programlisting>&lt;bean id="jotm" class="org.springframework.transaction.jta.JotmFactoryBean" /></programlisting>
            <para>Next, we configure the XAPoolDataSource and the non transactional BasicDataSource.
                This is pretty much standard data source configuration stuff. The XAPoolDataSource
                is configured through Spring and not JNDI so it can take advantage of JTOM. Servlet
                containers, which don't support JTA, require this configuration step so the
                datasource will use JTA.</para>
            <programlisting>&lt;bean id="dataSource" class=" org.kuali.rice.core.database.XAPoolDataSource ">
    &lt;property name="transactionManager">
        &lt;ref local="jotm" />
    &lt;/property>
    &lt;property name="driverClassName">
        &lt;value>oracle.jdbc.driver.OracleDriver&lt;/value>
    &lt;/property>
    &lt;property name="maxSize">
        &lt;value>25&lt;/value>
    &lt;/property>
    &lt;property name="minSize">
        &lt;value>2&lt;/value>
    &lt;/property>
    &lt;property name="maxWait">
        &lt;value>5000&lt;/value>
    &lt;/property>
    &lt;property name="validationQuery">
        &lt;value>select 1 from dual&lt;/value>
    &lt;/property>
    &lt;property name="url">
        &lt;value>jdbc:oracle:thin:@129.79.44.172:1521:XE&lt;/value>
    &lt;/property>
    &lt;property name="username">
        &lt;value>myapp&lt;/value>
    &lt;/property>
    &lt;property name="password">
        &lt;value>password&lt;/value>
    &lt;/property>
&lt;/bean>
&lt;bean id="nonTransactionalDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
    &lt;property name="driverClassName">
        &lt;value>oracle.jdbc.driver.OracleDriver&lt;/value>
    &lt;/property>
    &lt;property name="maxActive">
        &lt;value>50&lt;/value>
    &lt;/property>
    &lt;property name="minIdle">
        &lt;value>7&lt;/value>
    &lt;/property>
    &lt;property name="initialSize">
        &lt;value>7&lt;/value>
    &lt;/property>
    &lt;property name="validationQuery">
        &lt;value>select 1 from dual&lt;/value>
    &lt;/property>
    &lt;property name="url">
        &lt;value>jdbc:oracle:thin:@129.79.44.172:1521:XE&lt;/value>
    &lt;/property>
    &lt;property name="username">
        &lt;value>myapp&lt;/value>
    &lt;/property>
    &lt;property name="password">
        &lt;value>password&lt;/value>
    &lt;/property>
    &lt;property name="accessToUnderlyingConnectionAllowed">
        &lt;value>true&lt;/value>
    &lt;/property>
&lt;/bean>        </programlisting>
            <para>Next, we configure the bus:</para>
            <programlisting>&lt;bean id="rice" class="org.kuali.rice.core.config.RiceConfigurer">
    &lt;property name="serviceNamespace" value="MyApp" />
    &lt;property name="dataSource" ref="dataSource" />
    &lt;property name="nonTransactionalDataSource" ref="nonTransactionalDataSource" />
    &lt;property name="transactionManager" ref="jotm" />
    &lt;property name="userTransaction" ref="jotm" />
    &lt;property name="ksbConfigurer">
        &lt;bean class="org.kuali.rice.ksb.messaging.config.KSBConfigurer"/>
    &lt;/property>
&lt;/bean></programlisting>
            <para>We are injecting JOTM, and the datasources. The injection of the KSBConfigurer
                class into the ksbConfigurer property tells this instance of Rice to start the
                Service Bus. The final necessary step is setting the 'serviceNamespace' property to
                some value that will identify all services deployed from this node as a member of
                this node. Effectively, this is the name of the application.</para>
            <para>At this point, the application is configured to use the bus, both for publishing
                services and to send messages to services. Usually, applications will publish
                services on the bus using the KSBConfigurer or the KSBExporter classes. See
                Acquiring and invoking services for more detail.</para>
            <sect3>
                <title>Implications of “synchronous” vs. “asynchronous” Message Delivery</title>
                <para>As noted in Configuration Parameters, it is possible to configure message
                    delivery to run asynchronously or synchronously. It is imported to understand
                    that asynchronous messing should be used in almost all cases.</para>
                <para>Asynchronous messing will result in messages being sent in a separate thread
                    after the original transaction that requested the message to be sent is
                    committed. This is the appropriate behavior in a “fire-and-forget” messaging
                    model. The option to configure message deliver as synchronous was added for two reasons:<orderedlist>
                        <listitem>
                            <para>To allow for the implementation of automated unit tests which
                                could perform various tests without having to right “polling” code
                                to wait for asynchronous messing to complete. </para>
                        </listitem>
                        <listitem>
                            <para>For short-lived programs (such as batch programs) which need to
                                send messages. This allows for a guarantee that all messages will be
                                sent prior to the application being terminated. </para>
                        </listitem>
                    </orderedlist></para>
                <para>The second case is the only case where synchronous messaging should be used in
                    a production setting, and even then it should be used with care. Synchronous
                    message processing in Rice currently has the following major differences from
                    asynchronous messaging that need to be understood:<orderedlist>
                        <listitem>
                            <para>Order of Execution </para>
                        </listitem>
                        <listitem>
                            <para>Exception Handling </para>
                        </listitem>
                    </orderedlist></para>
                <sect4>
                    <title>Order of Execution</title>
                    <para>In asynchronous messaging, messages are queued up until the end of the
                        transaction, and then sent after the transaction is committed (technically,
                        they are sent <emphasis role="bold">when</emphasis> the transaction is
                        committed).</para>
                    <para>In synchronous messaging, messages are processed <emphasis role="bold"
                            >immediately</emphasis> when they are “sent”. This results in a
                        different ordering of execution when using these two different messaging
                        models.</para>
                </sect4>
                <sect4>
                    <title>Exception Handling</title>
                    <para>In asynchronous messaging, whenever there is a failure processing a
                        message, an exception handler is invoked. Recovery from such failures can
                        include resending the message multiple times, or recording and handling the
                        error in some other way. Since all of this is happening after the original
                        transaction was committed, it does not affect the original processing which
                        invoked the sending of the message.</para>
                    <para>With synchronous messaging, since the message processing is invoked
                        immediately and the calling code blocks until the processing is complete,
                        any errors raised during messaging will be thrown back up to the calling
                        code. This means that if you are writing something like a batch program
                        which relies on synchronous messaging, you must be aware of this and add
                        code to handle any errors if you want to deal with them gracefully.</para>
                    <para>Another implication of this is that message exception handlers will
                            <emphasis role="bold">not</emphasis> be invoked in this case.
                        Additionally, because an exception is being thrown, this will typically
                        trigger a rollback in any transaction that the calling code is running. So
                        transactional issues must be dealt with as well. For example, if the failure
                        of a single message shouldn’t cause the sending of all messages in a batch
                        job to fail, then each message will need to be sent in it’s own transaction,
                        and errors handled appropriately.</para>
                </sect4>
            </sect3>
        </sect2>
    </sect1>
    <sect1>
        <title>Configuring Quartz for KSB</title>
        <sect2>
            <title>Quartz Scheduling</title>
            <para>The Kuali Service Bus (KSB) uses Quartz to schedule delayed tasks, including retry
                attempts for messages that cannot be sent the first time. By default, KSB uses an
                embedded quartz scheduler that can be configured by passing parameters starting with
                    “<emphasis role="italic">ksb.org.quartz.</emphasis>” into the Rice
                configuration.</para>
            <para>If the application is already running a quartz scheduler, you can inject a custom
            quartz scheduler using code like this:</para>
            <programlisting>&lt;bean class="org.kuali.rice.ksb.messaging.config.KSBConfigurer">
    ...
    &lt;property name="exceptionMessagingScheduler">
        &lt;bean class="org.springframework.scheduling.quartz.SchedulerFactoryBean">
            ...
        &lt;/bean>
    &lt;/property>
&lt;/bean></programlisting>
            <para>When you do this, KSB will not create an embedded scheduler but will instead use
                the one provided.</para>
        </sect2>
    </sect1>
    <sect1>
        <title>Acquiring and Invoking Services Deployed on KSB</title>
        <sect2>
            <title>Service invocation overview</title>
            <para>
                <orderedlist>
                    <listitem>
                        <para>Acquired and called directly<itemizedlist>
                                <listitem>
                                    <para>Automatic Failover </para>
                                </listitem>
                                <listitem>
                                    <para>No Persistence </para>
                                </listitem>
                                <listitem>
                                    <para>Direct call - Request/Response </para>
                                </listitem>
                            </itemizedlist></para>
                    </listitem>
                    <listitem>
                        <para>Acquired and called through the MessageHelper <itemizedlist>
                                <listitem>
                                    <para>Automatic Failover </para>
                                </listitem>
                                <listitem>
                                    <para>Message Persistence </para>
                                </listitem>
                                <listitem>
                                    <para>KSB Exception Messaging </para>
                                </listitem>
                                <listitem>
                                    <para>Callback Mechanisms </para>
                                </listitem>
                            </itemizedlist></para>
                    </listitem>
                </orderedlist>
            </para>
            <para>In the examples below, notice that the <emphasis role="bold">client code is
                    unaware of the protocol with which the underlying service is
                deployed</emphasis>. Given a connector for a given protocol and a compatible service
                definition, you could move a service to different protocols as access needs change
                without affecting dependent client code.</para>
        </sect2>
        <sect2>
            <title>Acquiring and invoking a service directly</title>
            <para>The easiest way to call a service is to grab it and invoke it directly. This uses
                a direct request/response pattern and what you see is what you get. You will wait
                for the processing the call takes on the other side plus the cost of the remote
                connection time. Any exceptions thrown will come across the wire in a
                protocol-acceptable way.</para>
            <para>This code acquires a SOAP-based service and calls it:</para>
            <programlisting>QName serviceName = new QName("testNameSpace", "soap-repeatTopic");

SOAPService soapService = (SOAPService) GlobalResourceLoader.getService(serviceName);
soapService.doTheThing("hello");</programlisting>
            <para>The SOAPService interface needs to be in the client classpath and bindable to the
                WSDL. The easiest way to achieve this in Java is to create a bean that is exported
                as a SOAP service. This is the server-side service declaration in a Spring
                file:</para>
            <programlisting>&lt;bean class=" org.kuali.rice.ksb.messaging.SOAPServiceDefinition">
    &lt;property name="service">
        &lt;ref bean="soapService" />
    &lt;/property>
    &lt;property name="localServiceName" value="soap-repeatTopic" />
    &lt;property name="serviceNameSpaceURI" value="testNameSpace" />
    &lt;property name="priority" value="3" />
    &lt;property name="retryAttempts" value="1" />
    &lt;property name="busSecurity" value="false" />
&lt;/bean>
</programlisting>
            <para>This declaration exposes the bean soapService on the bus as a SOAP available
                service. The Web Service Definition Language is available at the serviceServletUrl +
                serviceNameSpaceURI + localServiceName + ?wsdl. </para>
            <para>This next code snippet acquires and calls a Java base service:</para>
            <programlisting>EchoService echoService = (EchoService)GlobalResourceLoader.getService(new QName("TestCl1", "echoService"));
String echoValue = "echoValue";
String result = echoService.echo(echoValue);</programlisting>
            <para>Again, the interface is all that is required to make the call. This is the
                server-side service declaration that deploys a bean using Spring’s HttpInvoker as
                the underlying transport:</para>
            <programlisting>&lt;bean class="org.kuali.rice.ksb.messaging.JavaServiceDefinition ">
    &lt;property name="service" ref="echoService" />
    &lt;property name="serviceInterface" value=" org.kuali.rice.ksb.messaging.remotedservices. EchoService " />
    &lt;property name="localServiceName" value="soap-echoService" />
    &lt;property name="busSecurity" value="false" />
&lt;/bean></programlisting>
            <para>Below is a description of each property on the ServiceDefinition
                (JavaServiceDefinition and SOAPServiceDefinition):</para>
            <para>
                <table frame="none">
                    <title>Properties of the ServiceDefinition</title>
                    <tgroup cols="4">
                        <colspec colname="c1" colnum="1" colwidth="1.0*"/>
                        <colspec colname="c2" colnum="2" colwidth="1.0*"/>
                        <colspec colname="c3" colnum="3" colwidth="1.0*"/>
                        <colspec colname="c4" colnum="4" colwidth="1.0*"/>
                        <thead>
                            <row>
                                <entry>property</entry>
                                <entry>required</entry>
                                <entry>default</entry>
                                <entry>description</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>busSecurity</entry>
                                <entry>no</entry>
                                <entry>yes (JavaServiceDefinition), no
                                    (SOAPServiceDefinition)</entry>
                                <entry>For Java-based services, message is digitally signed before
                                    calling the service and verified at the node hosting the
                                    service. For SOAP services, WSS4J is used to digitally sign the
                                    SOAP request/response in accordance with the WS Security
                                    specification. More info on Bus Security here.</entry>
                            </row>
                            <row>
                                <entry>localServiceName</entry>
                                <entry>yes</entry>
                                <entry>none</entry>
                                <entry>The local name of the QName that makes up the complete
                                    service name.</entry>
                            </row>
                            <row>
                                <entry>messageExceptionHandler</entry>
                                <entry>no</entry>
                                <entry>DefaultMessageExceptionHandler</entry>
                                <entry>Name of the MessageExceptionHandler that is called when a
                                    service call fails. This is called after the retryAttempts or
                                    millisToLive policy of the service or Node has been met.</entry>
                            </row>
                            <row>
                                <entry>millisToLive</entry>
                                <entry>no</entry>
                                <entry>none</entry>
                                <entry>Used instead of retryAttempts. Only considered in case of
                                    error when invoking service. Defines how long the message should
                                    continue to be tried before being put into KSB Exception
                                    Messaging.</entry>
                            </row>
                            <row>
                                <entry>priority</entry>
                                <entry>no</entry>
                                <entry>5</entry>
                                <entry>Only applies when asynchronous messaging is enabled. The
                                    lower the priority is, the sooner the message will be executed.
                                    For example, if 100 <emphasis role="italic">priority
                                        10</emphasis> messages are waiting for invocation and a
                                        <emphasis role="italic">priority 5</emphasis> message is
                                    sent, the <emphasis role="italic">priority 5</emphasis> message
                                    will be executed first.</entry>
                            </row>
                            <row>
                                <entry>queue</entry>
                                <entry>no</entry>
                                <entry>true</entry>
                                <entry><para>If <emphasis role="italic">true</emphasis>, the service
                                        will behave like a queue in that there is only one real
                                        service call when a message is sent. </para><para>If <emphasis
                                        role="italic">false</emphasis>, the service will behave like
                                    a topic. All beans bound to the service name will be sent a
                                    message when a message is sent to the service. </para><para>Use queues
                                        for operations you only want to happen once (for example, to
                                        route a document). Use topics for notifications across a
                                        cluster (for example, to invalidate cache
                                    entry).</para></entry>
                            </row>
                            <row>
                                <entry>retryAttempts</entry>
                                <entry>no</entry>
                                <entry>7</entry>
                                <entry>Determines the number of times a service can be invoked
                                    before being put into KSB Exception Messaging (the error
                                    state)</entry>
                            </row>
                            <row>
                                <entry>service</entry>
                                <entry>yes</entry>
                                <entry>none</entry>
                                <entry>The bean to be exposed for invocation on the bus</entry>
                            </row>
                            <row>
                                <entry>serviceEndPoint</entry>
                                <entry>no</entry>
                                <entry>serviceServletUrl + serviceName</entry>
                                <entry>This can be explicitly set to create an alternate service end
                                    point, different from the one the bus automatically
                                    creates.</entry>
                            </row>
                            <row>
                                <entry>serviceName</entry>
                                <entry>yes</entry>
                                <entry>serviceNameSpaceURI + localServiceName</entry>
                                <entry>If <emphasis role="italic">localServiceName</emphasis> and
                                        <emphasis role="italic">serviceNameSpaceURI</emphasis> are
                                    omitted, the QName of the service. This can be used instead of
                                    the <emphasis role="italic">localServiceName</emphasis> and
                                        <emphasis role="italic">serviceNameSpaceURI</emphasis>
                                    convenience methods.</entry>
                            </row>
                            <row>
                                <entry>serviceNameSpaceURI</entry>
                                <entry>no</entry>
                                <entry>messageEntity property or message.entity config param is
                                    used</entry>
                                <entry>The namespaceURI of the QName that makes up the complete
                                    service name. If set to "" (blank string) the property is NOT
                                    included in the construction of the QName representing the
                                    service and the service name will just be the localServiceName
                                    with no namespace.</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>
        </sect2>
        <sect2>
            <title>Acquiring and invoking a service using messaging</title>
            <para>To make a call to a service through messaging, acquire the service by its name
                using the MessageHelper:</para>
            <programlisting>QName serviceName = new QName("testAppsSharedQueue", "sharedQueue");

KEWSampleJavaService testJavaAsyncService = (KEWSampleJavaService) KSBServiceLocator.getMessageHelper().getServiceAsynchronously(serviceName);
</programlisting>
            <para>At this point, the testJavaAsyncService can be called like a normal
                JavaBean:</para>
            <programlisting>testJavaAsyncService.invoke(new ClientAppServiceSharedPayloadObj("message content", false));</programlisting>
            <para>Because this is a queue, a single message is sent to one of the beans bound to the
                service name <emphasis role="italic">new QName("testAppsSharedQueue",
                    "sharedQueue")</emphasis>. That 'message' is the call 'invoke' and it takes a
                ClientAppServiceSharedPayloadObj. Typically, messaging is done asynchronously.
                Messages are sent when the currently running JTA transaction is committed - that is,
                the messaging layer automatically synchronizes with the current transaction. So,
                using JTA, even though the above is coded in line with code, invocation is normally
                delayed until the transaction surrounding the logic at runtime is committed. </para>
            <para>When not using JTA, the message is sent asynchronously (by a different thread of
                execution), but it's sent ASAP.</para>
            <para>To review, the requirements to use a service that is exposed to the bus on a
                different machine are:<orderedlist>
                    <listitem>
                        <para>The service name </para>
                    </listitem>
                    <listitem>
                        <para>The interface to which to cast the returned service proxy object
                        </para>
                    </listitem>
                    <listitem>
                        <para>The ExceptionMessageHandler required by the service in case invocation
                            fails </para>
                    </listitem>
                </orderedlist></para>
            <note><para>Typically, service providers give clients a JAR with this content or organizations
                maintain a JAR with this content.</para></note>
            <para>To complete the example: Below is the Spring configuration used to expose this
                service to the bus. This is taken from the file <emphasis role="italic"
                    >TestClient1SpringBeans.xml</emphasis>:</para>
            <programlisting>&lt;!-- bean declaration -->
&lt;bean id="sharedQueue" class=" org.kuali.rice.ksb.testclient1.ClientApp1SharedQueue" />


&lt;!-- RiceConfigurer Snippet -->
&lt;bean class=" org.kuali.rice.ksb.messaging.JavaServiceDefinition">
    &lt;property name="service" ref="sharedQueue" />
    &lt;property name="localServiceName" value="sharedQueue" />
    &lt;property name="serviceNameSpaceURI" value="testAppsSharedQueue" />
&lt;/bean>

&lt;... more .../></programlisting>
            <para>This is located in the Spring file of the application exposing the service (in
                other words, the location in which the actual invocation will occur). The client
                does not need a Spring configuration to invoke the service.</para>
            <para>There are two messaging call paradigms, called <emphasis role="italic"
                    >Topics</emphasis> and <emphasis role="italic">Queues</emphasis>. When any
                number of services is declared a Topic, then those services are invoked at least
                once or multiple times. If any number of services is declared a Queue, then one and
                only one service name will be invoked. </para>
        </sect2>
        <sect2>
            <title>Getting responses from service calls made with messaging</title>
            <para>You can use Callback objects to get responses from service calls made using
            messaging. Acquiring a service for use with a Callback:</para>
            <programlisting>QName serviceName = new QName("TestCl1", "testXmlAsyncService");
SimpleCallback callback = new SimpleCallback();
KEWXMLService testXmlAsyncService = (KEWXMLService) KSBServiceLocator.getMessageHelper().getServiceAsynchronously(serviceName, callback);

testXmlAsyncService.invoke("message content");</programlisting>
            <para>When the service is invoked asynchronously, the AsynchronousCallback object's (the
                SimpleCallback class above) callback method is called.</para>
            <para>When message persistence is turned on, this object is serialized with any method
                call made through the messaging API. Take into consideration that this object (and
                the result of a method call) may survive machine restart and therefore it’s
                recommended that you NOT depend on certain transient in-memory resources.</para>
        </sect2>
    </sect1>
    <sect1>
        <title>Failover</title>
        <sect2>
            <title>Service call failover</title>
            <para>Failover works the same whether making direct service calls or using
                messaging.</para>
            <para>Services exported to the bus have automatic failover from the client’s
                perspective. For example, if service A is deployed on machines 1 and 2 and a client
                happens to get a proxy that points to machine 1 but machine 1 crashes, the KSB will
                automatically detect that the exception is a result of some network issue and direct
                the call to machine 2. KSB then removes machine 1 from the registry so new clients
                to the bus don't try to acquire the service. When machine 1 returns to the network
                it will register itself with the service registry and therefore the bus.</para>
            <para>When a message calls a service, the failover rules determine which service KSB
                assigns (topic or queue) to the message.</para>
        </sect2>
        <sect2>
            <title>Failover with queues</title>
            <para>Because queues require only one call between all beans bound to the queue, if a
                single call to a queue fails, failover to the next bean occurs. If successful, the
                call is done. If it is not successful, it continues until a suitable bean is found.
                If none is found, the message is marked for retry later. Eventually, the message
                either goes to KSB exception messaging or successfully completes.</para>
        </sect2>
        <sect2>
            <title>Failover with topics</title>
            <para>If a machine in a topic is unavailable, a failed call to that machine will
                continue to be retried until that call is successful or that call goes into KSB
                exception messaging.</para>
        </sect2>
    </sect1>
    <sect1>
        <title>KSB Exception Messaging</title>
        <para>Exception Messaging is the set of services and configuration options that handle
            messages that cannot be delivered successfully. Exception Messaging is primarily used by
            configuring your service using the properties outlined in KSB Module Configuration. When
            services are configured to use message persistence and there is a problem invoking a
            service, the persisted message or service call is relied upon to make another call to
            that service until the call is either:<orderedlist>
                <listitem>
                    <para>Successful </para>
                </listitem>
                <listitem>
                    <para>Certain configuration policies have been met and the message goes into the
                        Exception state </para>
                </listitem>
            </orderedlist></para>
        <para>The Exception state means that KSB can't doing anything more with this message. The
            message will not invoke properly. That generally means that some sort of technical
            intervention is required by both the consumer and the provider of the service to
            determine what the problem is.</para>
        <para>All Exception behavior is configurable at the service level by setting the name of the
            class to be used as MessageExceptionHandler. This class determines what to do when a
            client of a service cannot invoke a message. The DefaultMessageExceptionHandler is
            enough to meet most requirements. </para>
        <para>When a message is put into the Exception state, KSB puts it back into the message
            store and marks it with a status of 'E'. At that point, it is up to the person
            responsible for monitoring this node on the bus to determine what to do with the
            message.</para>
        <para>Because the node exposing the service configures the MessageExceptionHandler, any
            clients depending on the service need that MessageExceptionHandler and any dependent
            code and configuration. </para>
    </sect1>
    <sect1>
        <title>KSB Messaging Paradigms</title>
        <para>KSB supports two types of messaging paradigms; Queues and Topics, and the differences
            are explained below. These are very similar to JMS messaging concepts. An open source
            solution was not used for KSB messaging because an open source JMS provider wasn’t found
            that provided JTA synchronization, discovery, failover, and load balancing. Many claim
            such features, but when put to the test in real world scenarios (i.e., machines going
            down and coming back up, databases failing, network connectivity issues); none managed
            to reliably deliver messages.</para>
        <para>The advantage here is that we can apply these messaging concepts to any support
            protocol with which we can communicate.</para>
        <sect2>
            <title>Queues</title>
            <para>When any number of services is bound to a queue and a method is invoked, one and
                only one service gets the invocation.</para>
        </sect2>
        <sect2>
            <title>Topics</title>
            <para>When any number of services is bound to a topic and a method is invoked, all
                services are invoked AT LEAST once or multiple times.</para>
        </sect2>
        <sect2>
            <title>Message Fetcher</title>
            <para><emphasis role="italic">edu.iu.uis.eden.messaging.MessageFetcher</emphasis> is a
                Runnable that needs to be configured by the client application to retrieve stored
                messages from the database that weren’t processed when the node went down. This can
                happen for many reasons. The machine can be under load and just crash. </para>
            <para>When message persistence is enabled, a service that fails or throws an Exception
                stores preprocessed messages in the database until they can be resent. This makes
                certain that a crash or emergency restart of your machine will not result in message
                loss. </para>
            <para>The KSB does not automatically fetch all these messages and attempt to invoke them
                when it starts, because often the KSB is started when the services the messages are
                bound for are not yet started. For now, you need to decide when to call the run
                method on the MessageFetcher. Because it's a Runnable, you could also put the
                MessageFetcher in the KSBThreadPool that is available on the KSBServiceLocator. You
                could wrap it in a TimerTask, etc. All that is required is this:</para>
            <programlisting>new MessageFetcher((Integer) null).run()</programlisting>
            <para>Unfortunately, the cast to Integer is required. The MessageFetcher also has a
                constructor that takes a long variable as a parameter. This can be used to pull any
                message in the message store and put it in memory for invocation. <emphasis
                    role="italic">Integer</emphasis> is a fetch size; <emphasis role="italic"
                    >null</emphasis> means all.</para>
        </sect2>
    </sect1>
    <sect1>
        <title>Load Balancing</title>
        <para>Load balancing between service calls is automatic. If there are multiple nodes that
            expose services of the same name, clients will randomly acquire proxies to each endpoint
            bound to that name.</para>
    </sect1>
    <sect1>
        <title>Object Remoting</title>
        <para>Using KSB, it is possible to instantiate and invoke objects on other machines
            remotely. To accomplish this use an ObjectDefinition to inform KSB how to instantiate
            the object on the remote machine and which messageEntity you are targeting:</para>
        <programlisting>ObjectDefinition od = new ObjectDefinition(TestClient1ObjectToBeRemoted.class.getName(), "TestCl1");</programlisting>
        <para>Above is the default example, you can add constructor parameters and properties to be
            set during instantiation. Use the proxy to the object and invoke the object according to
            the interface you cast the object to.</para>
        <programlisting>RemotedObject remotedOjb = (RemotedObject) GlobalResourceLoader.getObject(od);

String returnParam = remotedOjb.invoke("call1");</programlisting>
        <para>There are some caveats when doing this:<orderedlist>
                <listitem>
                    <para>Do this only when using JTA. KSB relies on JTA to know when to clean up
                        the remote object on the remote machine. </para>
                </listitem>
                <listitem>
                    <para>The object will live during the currently running transaction on your
                        machine. Either JTA transaction completion or rollback triggers cleanup.
                    </para>
                </listitem>
                <listitem>
                    <para>The remote proxy will retain all non-Spring based interfaces of the object
                        on the remote machine. </para>
                </listitem>
                <listitem>
                    <para>The object must return Serializable objects for methods called and take
                        Serialized parameters. </para>
                </listitem>
                <listitem>
                    <para>This only works for Java clients. Objects are exported using Java for
                        Java. There is no SOAP remoting of objects. </para>
                </listitem>
            </orderedlist></para>
    </sect1>
    <sect1>
        <title>Publishing Services to KSB</title>
        <para>You can publish Services on the service bus either by configuring them directly in the
            application's KSBConfigurer module definition, or by using the KSBExporter bean. In
            either case, a ServiceDefinition is provided that specifies various bus settings and the
            target Spring bean.</para>
        <sect2>
            <title>KSBConfigurer</title>
            <para>A service can be exposed by explicitly registering it with the KSBConfigurer
            module, services property:</para>
            <programlisting>&lt;bean id="rice" class="org.kuali.rice.config.RiceConfigurer">
    &lt;property name="messageEntity" value="MYAPP" />
    &lt;property name="dataSource" ref="dataSource" />
    &lt;property name="transactionManager" ref="atomikosTransactionManager" />
    &lt;property name="userTransaction" ref="atomikosUserTransaction" />
    &lt;property name="rootConfig" ref="config" />
    &lt;property name="modules">
        &lt;list>
            &lt;bean class="org.kuali.rice.ksb.messaging.config.KSBConfigurer">
            &lt;property name="serviceServletUrl" value="${base url}/MYAPP/remoting/" />
                ...
                &lt;property name="services">
                    &lt;list>
                        &lt;bean class="edu.iu.uis.eden.messaging.SOAPServiceDefinition">
                            &lt;property name="service">
                                &lt;ref bean="mySoapService" />
                            &lt;/property>
                            &lt;property name="serviceInterface">&lt;value>org.myapp.services.MySOAPService&lt;/value>&lt;/property>
                            &lt;property name="localServiceName" value="myExposedSoapService" />
                        &lt;/bean>
                        &lt;bean class="edu.iu.uis.eden.messaging.JavaServiceDefinition">
                            &lt;property name="service">
                                &lt;ref bean="myJavaService" />
                            &lt;/property>
                            &lt;property name="serviceInterface">
                                &lt;value>org.myapp.services.MyJavaService&lt;/value>&lt;/property>
                            &lt;property name="localServiceName" value="myExposedJavaService" />
                        &lt;/bean>
</programlisting>
        </sect2>
        <sect2>
            <title>KSBExporter</title>
            <para>You can also publish Services in any context using the KSBExporter bean. Note that
            KSBConfigurer must also be defined in your RiceConfigurer.</para>
            <programlisting>&lt;bean class="edu.iu.uis.eden.messaging.KSBExporter">
    &lt;property name="serviceDefinition">
        &lt;bean class="edu.iu.uis.eden.messaging.JavaServiceDefinition">
            &lt;property name="service">
                &lt;ref bean="myJavaService" />
            &lt;/property>
            &lt;property name="serviceInterface">
                &lt;value>org.myapp.services.MyJavaService&lt;/value>
            &lt;/property>
            &lt;property name="localServiceName" value="myExposedJavaService" />
        &lt;/bean>
    &lt;/property>
&lt;/bean>

&lt;bean class="edu.iu.uis.eden.messaging.KSBExporter">
    &lt;property name="serviceDefinition">
        &lt;bean class="edu.iu.uis.eden.messaging.SOAPServiceDefinition">
            &lt;property name="service">
                &lt;ref bean="mySoapService" />
            &lt;/property>
            &lt;property name="serviceInterface">
                &lt;value>org.myapp.services.MySOAPService&lt;/value>
            &lt;/property>
            &lt;property name="localServiceName" value="myExposedSoapService" />
        &lt;/bean>
    &lt;/property>

&lt;/bean></programlisting>
        </sect2>
        <sect2>
            <title>ServiceDefinition properties</title>
            <para>ServiceDefinitions define how the service is published to the KSB. Currently KSB
                supports three types of services: Java RPC (via serialization over HTTP), SOAP, and
                JMS.</para>
            <sect3>
                <title>Basic parameters</title>
                <para>All service definitions support these properties:</para>
                <para>
                    <table frame="none">
                        <title>ServiceDefinition Properties</title>
                        <tgroup cols="3">
                            <colspec colname="c1" colnum="1" colwidth="1.0*"/>
                            <colspec colname="c2" colnum="2" colwidth="1.0*"/>
                            <colspec colname="c3" colnum="3" colwidth="1.0*"/>
                            <thead>
                                <row>
                                    <entry>Property</entry>
                                    <entry>Description</entry>
                                    <entry>Required</entry>
                                </row>
                            </thead>
                            <tbody>
                                <row>
                                    <entry>Service</entry>
                                    <entry>The reference to the target service bean</entry>
                                    <entry>yes</entry>
                                </row>
                                <row>
                                    <entry>localServiceName</entry>
                                    <entry>The "local" part of the service name; together with a
                                        namespace this forms a qualified name, or QName</entry>
                                    <entry>yes</entry>
                                </row>
                                <row>
                                    <entry>serviceNameSpaceURI</entry>
                                    <entry>The "namespace" part of the service name; together with a
                                        local name forms a qualified name, or QName</entry>
                                    <entry>Not required; if omitted, the <emphasis role="bold"
                                            >Core.currentContextConfig().getMessageEntity()</emphasis>
                                        is used when exporting the service</entry>
                                </row>
                                <row>
                                    <entry>serviceEndpoint</entry>
                                    <entry>URL at which the service can be invoked by a remote
                                        call</entry>
                                    <entry>Not required; defaults to the serviceServletUrl parameter
                                        defined in the Rice config</entry>
                                </row>
                                <row>
                                    <entry>retryAttempts</entry>
                                    <entry>Number of attempts to retry the service invocation on
                                        failure; for services with side-effects you are advised to
                                        omit this property </entry>
                                    <entry>Not required; defaults to 0</entry>
                                </row>
                                <row>
                                    <entry>millisToLive</entry>
                                    <entry>Number of milliseconds the call should persist before
                                        resulting in failure </entry>
                                    <entry>Not required; defaults to no limit (-1)</entry>
                                </row>
                                <row>
                                    <entry>Priority</entry>
                                    <entry>Priority</entry>
                                    <entry>Not required; defaults to 5</entry>
                                </row>
                                <row>
                                    <entry>MessageExceptionHandler</entry>
                                    <entry>Reference to a MessageExceptionHandler that should be
                                        invoked in case of exception</entry>
                                    <entry>Not required; default implementation handles retries and
                                        timeouts</entry>
                                </row>
                                <row>
                                    <entry>busSecurity</entry>
                                    <entry>Whether to enable bus security for the service</entry>
                                    <entry>Not required; defaults to <emphasis role="italic"
                                            >ON</emphasis></entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </table>
                </para>
            </sect3>
        </sect2>
        <sect2>
            <title>ServiceNameSpaceURI/MessageEntity</title>
            <para>ServiceNameSpaceURI is the same as the <emphasis role="italic">Message
                    Entity</emphasis> that composes the qualified name under which the service is
                exposed. When omitted, this namespace defaults to the message entity configured for
                Rice (e.g., in the RiceConfigurer), thereby qualifying the local name. Note:
                Although this implicit qualification occurs during export, you must always specify
                an explicit message entity when acquiring a resource, for example:</para>
            <programlisting>GlobalResourceLoader.getService(new QName("MYAPP", "myExposedSoapService"))</programlisting>
            <para>To consistently access services that you have exposed, but which may be running
                under implicitly qualified names, you may use the current message entity provided by
                the current context config. (This is mostly useful for internal Rice modules or
                other services that are intended to be run under varying client message
                entities.)</para>
            <programlisting>GlobalResourceLoader.getService(new QName(Core.getCurrentContextConfig().getMessageEntity(), "myExposedSoapService"))</programlisting>
        </sect2>
        <sect2>
            <title>SOAPServiceDefinition</title>
            <table frame="none">
                <title>SOAPServiceDefinition</title>
                <tgroup cols="3">
                    <colspec colname="c1" colnum="1" colwidth="1.0*"/>
                    <colspec colname="c2" colnum="2" colwidth="1.0*"/>
                    <colspec colname="c3" colnum="3" colwidth="1.0*"/>
                    <thead>
                        <row>
                            <entry>Property</entry>
                            <entry>Description</entry>
                            <entry>Required</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>serviceInterface</entry>
                            <entry>The interface to expose and from which to generate the
                                WSDL</entry>
                            <entry>Not required; if omitted the first interface implemented by the
                                class is used</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </sect2>
        <sect2>
            <title>JavaServiceDefinition</title>
            <table frame="none">
                <title>JavaServiceDefinition</title>
                <tgroup cols="3">
                    <colspec colname="c1" colnum="1" colwidth="1.0*"/>
                    <colspec colname="c2" colnum="2" colwidth="1.0*"/>
                    <colspec colname="c3" colnum="3" colwidth="1.0*"/>
                    <thead>
                        <row>
                            <entry>Property</entry>
                            <entry>Description</entry>
                            <entry>Required</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>serviceInterface</entry>
                            <entry>The interface to expose </entry>
                            <entry>Not required; if omitted, all application-layer interfaces
                                implemented by the class are exposed</entry>
                        </row>
                        <row>
                            <entry>serviceInterfaces</entry>
                            <entry>A list of interfaces to expose</entry>
                            <entry>Not required; if omitted, all application-layer interfaces
                                implemented by the class are exposed</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </sect2>
        <sect2>
            <title>Publishing Rice services</title>
            <para>We show how you can "import" Rice services into the client Spring application
                context in Configuring KSB Client in Spring. Using this technique, you can also
                publish Rice services on the KSB:</para>
            <programlisting>&lt;!-- import a Rice service from the ResourceLoader stack -->
&lt;bean id="aRiceService" class="org.kuali.rice.resourceloader.support.ResourceLoaderServiceFactoryBean"/>


&lt;!-- if Rice does not publish this service on the bus, one can explicitly publish it -->
&lt;bean class="edu.iu.uis.eden.messaging.KSBExporter">
    &lt;property name="serviceDefinition">
        &lt;bean class="edu.iu.uis.eden.messaging.JavaServiceDefinition">
            &lt;property name="service">
                &lt;ref bean="aRiceService"/>
            &lt;/property>
            &lt;property name="serviceInterface">
                &lt;value>org.kuali.rice...SomeInterface&lt;/value>
            &lt;/property>
            &lt;property name="localServiceName" value="aPublishedRiceService" />
        &lt;/bean>
    &lt;/property>
&lt;/bean></programlisting>
            <warning><para>Not all Rice services are intended for public use. Do not arbitrarily expose them
                on the bus</para></warning>
        </sect2>
    </sect1>
    <sect1>
        <title>Store and Forward</title>
        <sect2>
            <title>Overview</title>
            <para>Typically, when a method invocation is made on a service through messaging, the
                call is made remotely to the deployed service behind the scenes. This is fine, but
                sometimes it is better to have the invocation store and forward to the remote
                machine and then make the invocation there. In most cases, this provides better
                performance. If you are running a batch job and want to send numerous invocations,
                but don't want to wait for each and every invocation to take place before
                terminating the job, this is definitely a better way to go. </para>
            <para>To enable store and forward, set this parameter in the XML configuration for each
            application setup:</para>
            <programlisting>&lt;param name="bus.storeAndForward">true&lt;/param></programlisting>
            <para>This feature only works for Java. This parameter will make any Java-based service
                store and forward. You should consider using it with every Java service.</para>
        </sect2>
        <sect2>
            <title>Implementation</title>
            <para>Store and forward behavior affects how calling code invokes remote services when
                using the asynchronous or message-style invocation. </para>
            <para>Typically, invoking a service through asynchronous messaging will simply queue the
                call to be made at some point by a local thread, persisting or not persisting the
                message to the database in the meantime based on the message.persistence
                configuration parameter. </para>
            <para>When store and forward is enabled, the call to the service is not made directly.
                Instead, a call to a remote forwarding service is made and that service will queue
                the call on the remote node.</para>
            <warning><para>Whether or not store and forward is enabled, the method invocation is made
                asynchronously, and the service call run on the target server. However with call and
                forward enabled, the caller thread does not block as long on the call, presumably
                because the ForwardedCallHandler implementation is much simpler.</para></warning>
            <para>When you enable store and forward, the <emphasis role="bold"
                    >RemotedServiceRegistry</emphasis>, which is responsible for keeping a table of
                services that the local node has deployed and/or published, will publish a special
                "forwarding" service alongside each published Java service. This forwarding service
                definition will be similar to the original service, except that the implementation
                will be a <emphasis role="bold">ForwardedCallHandler</emphasis>, and it will simply
                re-dispatch the persisted message.</para>
            <para>The <emphasis role="bold">MessageServiceInvoker</emphasis>, which is responsible
                for executing service invocations, will first consult the <emphasis role="bold"
                    >storeAndForward</emphasis> flag, and, if enabled, will attempt to obtain not
                the actual service, but instead the special "forwarding" version of the service. It
                will then invoke that forwarding version of the service, instead of the actual
                service.</para>
            <para>To avoid infinite recursion on forwarded service invocations (in other words, the
                    <emphasis role="bold">MessageServiceInvoker</emphasis> called by the <emphasis
                    role="bold">ForwardedCallHandler</emphasis> itself invoking the forwarded
                version of the service again), the ForwardedCallHandler sets a property on the
                method call (<emphasis role="bold">isIgnoreStoreAndForward</emphasis>) that prevents
                store-and-forward from being used again on the delivered message. The <emphasis
                    role="bold">MessageServiceInvoker</emphasis> checks this flag on the call before
                attempting to forward a message.</para>
        </sect2>
    </sect1>
    <sect1>
        <title>The ResourceLoader Stack</title>
        <sect2>
            <title>Overview</title>
            <para>Rice is composed of a set of modules that provide distinct functionality and
                expose various services. <itemizedlist>
                    <listitem>
                        <para>Services in Rice are accessible by the <emphasis role="bold"
                                >ResourceLoader</emphasis>, which can be thought of as analogous to
                            Spring's <emphasis role="italic">BeanFactory</emphasis> interface. (In
                            fact, Rice modules themselves back ResourceLoaders with Spring bean
                            factories.) </para>
                    </listitem>
                    <listitem>
                        <para>Services can be acquired by name. (Rice adds several additional
                            concepts, including qualification of service names by namespaces.)
                        </para>
                    </listitem>
                    <listitem>
                        <para>When the <emphasis role="bold">RiceConfigurer</emphasis> is
                            instantiated, it constructs a GlobalResourceLoader that is composed of
                            an initial <emphasis role="italic">RootResourceLoader</emphasis> (which
                            may be provided by the application via the RiceConfigurer), as well as
                            resource loaders supplied by each module:</para>
                        <figure><title>Global Resource Loader</title>
                            <mediaobject>
                                <imageobject>
                                    <imagedata fileref="../images/global_resource_loader.png" scalefit="1">  
                                    </imagedata>
                                </imageobject>
                            </mediaobject>
                        </figure>
                    </listitem>
                </itemizedlist></para>
            <para>The <emphasis role="bold">GlobalResourceLoader</emphasis> is the top-level entry
                point through which all application code should go to obtain services. The <emphasis
                    role="bold">getService</emphasis> call will iterate through each registered
                ResourceLoader, looking for the service of the specified name. If the service is
                found, it is returned, but if it is <emphasis role="italic">not</emphasis> found,
                ultimately the call will reach the <emphasis role="bold"
                    >RemoteResourceLoader</emphasis>. The Root ResourceLoader is registered by the
                KSB module that exposes services that have been registered on the bus.</para>
        </sect2>
        <sect2>
            <title>Accessing and overriding Rice services and beans from Spring</title>
            <sect3>
                <title>ResourceLoaderFactoryBean</title>
                <para>In addition to programmatically acquiring service references, you can also
                    import Rice services into a Spring context with the help of the <emphasis
                        role="bold">ResourceLoaderServiceFactoryBean</emphasis>:</para>
                <para>This bean is <emphasis role="italic">bean-name-aware</emphasis> and will
                    produce a bean of the same name obtained from Rice's resource loader stack. The
                    bean can then be wired in Spring like any other bean.</para>
            </sect3>
            <sect3>
                <title>Using the RiceService annotation to inject Rice beans</title>
                <para>As an alternative to the <emphasis role="bold"
                        >ResourceLoaderServiceFactoryBean</emphasis> style of importing Rice beans,
                    you can use the <emphasis role="bold">@RiceService</emphasis> annotation in
                    client application beans (in conjunction with the <emphasis role="bold"
                        >GRLServiceInjectionPostProcessor</emphasis> bean factory post processor) to
                    auto-wire Rice beans into client application services. This is essentially a
                    style of Spring autowiring </para>
                <caution>
                    <para>In later versions of the Spring framework, Spring has made autowiring support
                        more flexible. However, in the version that Rice uses, autowiring is built-in
                        and cannot be extended; which is why Rice has its own post-processor
                        implementation.</para>
                </caution>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>First, define the <emphasis role="bold"
                                    >GRLServiceInjectionPostProcessor</emphasis> in your application
                                Spring context. Spring will run this post-processor during bean
                                initialization and it will look for <emphasis role="italic"
                                    >@RiceService</emphasis> fields or methods to inject. </para>
                            <programlisting>&lt;beans>
    &lt;bean class="org.kuali.rice.core.util.GRLServiceInjectionPostProcessor"/>

    ...
&lt;/beans></programlisting>
                        </listitem>
                        <listitem>
                            <para>Add the @RiceService annotation to any field or method (either,
                                not both, for the same property) that you wish to have injected with
                                a RiceService. <itemizedlist>
                                    <listitem>
                                        <para>You must specify the <emphasis role="bold"
                                                >name</emphasis> of the service you want to
                                            retrieve. To specify namespace, prefix with <emphasis
                                                role="bold">{NAMESPACE}</emphasis>. For example,
                                            {KEW}actionListService. If a namespace is not specified,
                                            the current context namespace will be used. </para>
                                    </listitem>
                                    <listitem>
                                        <para>If you want to obtain the service from a specific,
                                            named ResourceLoader, you may specify the name of the
                                            ResourceLoader (refer to the particular ResourceLoader
                                            source to determine its name). </para>
                                    </listitem>
                                </itemizedlist></para>
                                <programlisting>@RiceService(name="workflowDocumentService")
protected WorkflowDocumentService workflowDocumentService;</programlisting>
                        </listitem>
                    </orderedlist>
                </para>
            </sect3>
            <sect3>
                <title>Installing an application root resource loader</title>
                <para>Applications can install their own root ResourceLoader to override beans
                    defined by Rice. To do so, inject a bean that implements the ResourceLoader
                    interface into the RiceConfigurer rootResourceLoader property. For
                    example:</para>
                <programlisting>&lt;!-- a Rice bean we want to override in our application -->
&lt;bean id="overriddenRiceBean" class="my.app.package.MyRiceServiceImpl"/>

&lt;!-- supplies services from this Spring context -->
&lt;bean id="appResourceLoader" class="org.kuali.rice.resourceloader.SpringBeanFactoryResourceLoader"/>
&lt;bean id="rice" class="org.kuali.rice.config.RiceConfigurer">
    &lt;property name="dataSource" ref="standaloneDataSource" />
    &lt;property name="transactionManager" ref="atomikosTransactionManager" />
    &lt;property name="userTransaction" ref="atomikosUserTransaction" />
    &lt;property name="rootConfig" ref="config" />
    &lt;property name="environment" value="${environment}" />
    &lt;property name="rootResourceLoader" ref="appResourceLoader"/>
    &lt;property name="modules">
        &lt;list>
            &lt;bean class="org.kuali.rice.ksb.messaging.config.KSBConfigurer">
                &lt;property name="serviceServletUrl" value="${serviceServletUrl}" />
                &lt;property name="authorizationService">
                    &lt;bean class="edu.iu.uis.eden.authorization.WorkgroupAuthorizationServiceImpl">
                        &lt;property name="workgroupName" value="WorkflowAdmin" />
                    &lt;/bean>
                &lt;/property>
            &lt;/bean>
            &lt;bean class="org.kuali.workflow.config.KEWConfigurer">
                &lt;property name="clientProtocol" value="local" />
            &lt;/bean>
            &lt;bean class="org.kuali.notification.config.KENConfigurer" />
        &lt;/list>
    &lt;/property>
&lt;/bean></programlisting>
                <warning>
                    <para><emphasis role="bold">Application ResourceLoader and Circular
                            Dependencies</emphasis></para>
                    <para>Be careful when mixing registration of an application root resourceloader and
                        lookup of Rice services through the GlobalResourceLoader. If you are using an
                        application resourceloader to override a Rice bean, but one of your application
                        beans requires that bean to be injected during startup, you may create a
                        circular dependency. In this case, you will either have to make sure you are not
                        unintentionally exposing application beans (which may not yet have been fully
                        initialized by Spring) in the application resourceloader, or you will have to
                        arrange for the GRL lookup to occur lazily, after Spring initialization has
                        completed (either programmatically or through a proxy).</para>
                </warning>
            </sect3>
            <sect3>
                <title>Overriding Rice services: Alternate method</title>
                <para>A Rice-enabled webapp (including the Rice Standalone distribution) contains a
                    RiceConfigurer, typically defined in an xml Spring context file. This
                    RiceConfigurer loads the Rice modules. Each module has its own ResourceLoader,
                    which is typically backed by an XML Spring context file. Overriding and/or
                    setting global beans and/or services (such as data sources and transaction
                    managers) is done as described above. However, because in each module services
                    are injected into each other, overriding module services involves overriding the
                    respective module’s Spring context file.</para>
                <warning>
                    <para>There is no standard way to do this across modules. The KEW module has a flag
                        for additional or replacement Spring context files, but others do not.To do so,
                        one must override the module's Spring context file by placing a replacement in
                        the appropriate location in the WEB-INF/classes directory, which will take
                        precedence over the Rice-provided files in WEB-INF/lib.</para>
                </warning>
                <figure><title>Application Resources Properties Tree</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata
                                fileref="../images/directory_tree_ApplicationResources_properties.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>
                <para>The cleanest way to do this is take an unadulterated copy of the respective
                    Rice Spring file, rename it, and then &lt;import> it from your override Spring
                    file. That way one does not have to copy and maintain the entire contents of the
                    original Spring context file, e.g., to override a single KNS service without
                    taking a copy of the entire KNS Spring context:</para>
                <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN//EN" "http://www.springframework.org/dtd/spring-beans.dtd">
&lt;!-- override of KNSSpringBeans.xml to override encryption service -->
&lt;beans>

    &lt;!-- copy of original is imported -->
    &lt;import resource="classpath:/KNSSpringBeans-0.9.2.1.xml"/>

    &lt;!-- override encryption services -->
    &lt;bean id="encryptionService" class="edu.my.school.service.impl.MyEncryptionServiceImpl" lazy-init="true">
        &lt;property name="cipherAlgorithm" value="${encryption.cipherAlg}"/>
        &lt;property name="keyAlgorithm" value="${encryption.keyAlg}"/>
        &lt;property name="key" value="${encryption.key}"/>
        &lt;property name="enabled" value="${encryption.busEncryption}"/>
    &lt;/bean>

&lt;/beans></programlisting>
            </sect3>
        </sect2>
    </sect1>
    <sect1>
        <title>KSB Security</title>
        <sect2>
            <title>Overview</title>
            <para>Acegi handles the security layer for KSB. Acegi uses remote method invocation to
                hold the application’s security context and to propagate this object through to the
                service layer. </para>
        </sect2>
        <sect2>
            <title>Security types</title>
            <para>There are four security types you can use to propagate the security context object:<itemizedlist>
                    <listitem>
                        <para>Java </para>
                    </listitem>
                    <listitem>
                        <para>RMI </para>
                    </listitem>
                    <listitem>
                        <para>JMS </para>
                    </listitem>
                    <listitem>
                        <para>SOAP : WS-Security + Username Token + more </para>
                    </listitem>
                </itemizedlist></para>
        </sect2>
        <sect2>
            <title>CredentialsSource</title>
            <para>The CredentialsSource is an interface that helps obtain security credentials. It
                encapsulates the actual source of credentials. The three ways to obtain the source are:<itemizedlist>
                    <listitem>
                        <para>CasCredentialsSource - Username and Cas (Proxy) Ticket </para>
                    </listitem>
                    <listitem>
                        <para>KerberosCredentialsSource - Username and Kerberos Ticket </para>
                    </listitem>
                    <listitem>
                        <para>TestCredentialsSource - Username and Password </para>
                    </listitem>
                </itemizedlist></para>
            <sect3>
                <title>KSB security: Server side configuration</title>
                <para>Here is a code snippet that shows the changes needed to configure KSB security
                on the server side:</para>
                <programlisting>&lt;bean id="ksbConfigurer" class="edu.iu.uis.eden.config.spring.KSBSpringConfigurer">
    &lt;!-- Other properties removed -->
    &lt;property name="registryUrl" value="http://..." />
    &lt;property name="services">
        &lt;list>
            &lt;bean class="edu.iu.uis.eden.messaging.SOAPServiceDefinition">
                &lt;property name="service">
                    &lt;ref bean="soapService" />
                &lt;/property>
                &lt;property name="localServiceName" value="soapLocalName"/>
                &lt;property name="serviceNameSpaceURI" value="soapNameSpace"/>
                &lt;property name="serviceInterface" value="org.kuali.ksb.examples.SOAPEchoService"/>
                &lt;property name="priority" value="3"/>
                &lt;property name="retryAttempts" value="1" />
                &lt;property name="busSecurity" value="false">&lt;/property>
    
                &lt;!-- Valid Values: BASIC, SecurityContext -->
                &lt;property name="credentialsPropagationStrategy" value="BASIC"/>
                &lt;!-- Valid Values: CAS, KERBEROS -->
                &lt;property name="credentialsSourceType" value="CAS"/>
            &lt;/bean>
            &lt;bean class="edu.iu.uis.eden.messaging.JavaServiceDefinition">
                &lt;property name="service" ref="echoService">&lt;/property>
                &lt;property name="localServiceName" value="javaLocalName" />
                &lt;property name="serviceNameSpaceURI" value="javaNameSpace"/>
                &lt;property name="serviceInterface" value="org.kuali.ksb.examples.EchoService"/>
                &lt;property name="priority" value="5" />
                &lt;property name="retryAttempts" value="1" />
                &lt;property name="busSecurity" value="true" />
                &lt;!-- Valid Values: BASIC, SecurityContext -->
                &lt;property name="credentialsPropagationStrategy" value="SecurityContext"/>
                &lt;!-- Valid Values: CAS, KERBEROS -->
                &lt;property name="credentialsSourceType" value="CAS"/>
            &lt;/bean>
            &lt;!-- Other services removed -->
        &lt;/list>
    &lt;/property>
&lt;/bean></programlisting>
            </sect3>
            <sect3>
                <title>KSB security: Client side configuration</title>
                <programlisting>&lt;bean id="ksbConfigurer" class="edu.iu.uis.eden.config.spring.KSBSpringConfigurer">
    &lt;!-- Other properties removed -->
    &lt;property name="registryUrl" value="http://..." />
    &lt;property name="credentialsSources">
        &lt;property name="casCredentialsSource">
            &lt;!-- Whatever properties CAS needs -->
        &lt;/property>
        &lt;property name="kerberosCredentialsSource">
            &lt;!-- Whatever properties Kerberos needs -->
        &lt;/property>
    &lt;/property>
&lt;/bean>
</programlisting>
            </sect3>
        </sect2>
        <sect2>
            <title>KSB connector and exporter code</title>
            <sect3>
                <title>Connectors</title>
                <para>Connectors are used by a client to connect to a service that is usually
                    exposed through the KSB registry. The Service Connector factory provides a bean
                    that holds a proxy to a remote service with some contextual information. The
                    factory determines the type of proxy to invoke based on the service definition.
                    The service definition used by the server is serialized to the database and
                    de-serialized by the client. There are different types of connectors supported
                    by KSB, most notable are SOAP and Java over HTTP. </para>
            </sect3>
            <sect3>
                <title>Exporters</title>
                <para>Services, when exported, can be secured using standard Acegi methods. A
                    security manager and an interceptor help organize the set of Business Objects
                    that are exported.</para>
            </sect3>
        </sect2>
        <sect2>
            <title>Bus Security</title>
            <sect3>
                <title>Generating the Keystore</title>
                <para>For client applications to be able to consume secured services hosted from a
                    Rice server, the implementer must generate a keystore. As an initial setup, KSB
                    security relies on the creation of a keystore using the JVM keytool as
                    follows:</para>
            </sect3>
            <sect3>
                <title>Step 1: Create the Keystore</title>
                <para>The first step is to create the keystore and generate a public-private key
                    combination for the client application. When using secured services on the KSB,
                    we require the client applications transfer their messages digitally signed so
                    that Rice can verify the messages authenticity. This is why we must generate
                    these keys.</para>
                <para>Generate your initial Rice keystore as follows:</para>
                <programlisting></programlisting>
                <caution>
                    <para>keypass and storepass should be the same.</para>
                    <para>r1c3pw is the password used for the provided example.</para>
                </caution>
            </sect3>
            <sect3>
                <title>Step 2: Sign the Key</title>
                <para>This generates the keystore in a file called "rice_keystore" in the current
                    directory and generates an RSA key with the alias of "rice". Since there is no
                    certificate signing authority to sign our key, we must sign it ourselves. To do
                    this, execute the following command:</para>
                <programlisting>keytool  -selfcert -validity 9999 -alias rice -keystore rice.keystore -keypass r1c3pw -storepass r1c3pw</programlisting>
            </sect3>
            <sect3>
                <title>Step 3: Generate the Certificate</title>
                <para>After the application's certificate has been signed, we must export it so that
                    it can be imported into the Rice keystore. To export a certificate, execute the
                    following command:</para>
                <programlisting>keytool  -export -alias rice -file rice.cert -keystore rice.keystore -storepass r1c3pw</programlisting>
            </sect3>
            <sect3>
                <title>Step 4: Import Application Certificates</title>
                <para>The client application's certificate can be imported using the following
                    command:</para>
                <programlisting>keytool  -import -alias rice -file client.application.cert.file -keystore rice.keystore -storepass r1c3pw</programlisting>
                <para>The keystore file will end up deployed wherever your keystores are stored so
                    hang on to both of these files and don't lose them! Also, notice that we
                    specified a validity of 9999 days for the keystore and cert. This is so you do
                    not have to continually update these keystores. This will be determined by your
                    computing standards on how you handle key management.</para>
            </sect3>
            <sect3>
                <title>Configure KSB to use the keystore</title>
                <para>The following params are needed in the xml config to allow the ksb to use the
                    keystore:</para>
                <programlisting>&lt;param name="keystore.file">/usr/local/rice/rice.keystore&lt;/param>
&lt;param name="keystore.alias">rice&lt;/param>
&lt;param name="keystore.password"> password &lt;/param>
</programlisting>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para>keystore.file - is the location of the keystore </para>
                        </listitem>
                        <listitem>
                            <para>keystore.alias - is the alias used in creating the keystore above
                            </para>
                        </listitem>
                        <listitem>
                            <para>keystore.password - this is the password of the alias AND the
                                keystore. This assumes that the keystore is up in such a way that
                                these are the same. </para>
                        </listitem>
                    </itemizedlist>
                </para>
            </sect3>
        </sect2>
    </sect1>
    <sect1>
        <title>Queue and Topic invocation</title>
        <para>When you deploy a service, you can configure it for queue or for topic invocation
            using the <emphasis role="bold">setQueue</emphasis> property on the <emphasis
                role="bold">ServiceDefinition</emphasis>. The default is to register it as a
            queue-style service. The distinction between queue and topic invocation occurs when
            there is more than one service registered under the same <emphasis role="bold"
                >QName</emphasis>.</para>
        <sect2>
            <title>Queue invocation</title>
            <para>Remote service proxies obtained through the resource loader stack using <emphasis
                    role="bold">getService(QName)</emphasis> (ultimately through the <emphasis
                    role="bold">RemoteResourceServiceLocator</emphasis>) are inherently synchronous.
                In the presence of multiple service registrations, the <emphasis role="bold"
                    >RemoteResourceServiceLocator</emphasis> will choose one at random.</para>
            <para>When invoking services asynchronously through the <emphasis role="bold"
                    >MessageHelper</emphasis>, an asynchronous service call proxy will be
                constructed with all available service definitions. The <emphasis role="bold"
                    >MessageServiceInvoker</emphasis> is called to invoke each service. If the
                service is defined as a queue service, then the <emphasis role="bold"
                    >RemoteResourceServiceLocator</emphasis> will be consulted in a similar fashion
                to determine a single service to call. After the first queue service invocation the
                    <emphasis role="bold">MessageServiceInvoker</emphasis> will return.</para>
        </sect2>
        <sect2>
            <title>Topic invocation</title>
            <para>The simplest way to invoke a topic service is using the <emphasis role="bold"
                    >MessageHelper</emphasis> functions to invoke the service asynchronously. As
                described above for an asynchronous queue invocation, an asynchronous service call
                proxy will be constructed with the list of all of the services registered as a topic
                under the given name. Each of these services will be independently obtained and
                invoked by the <emphasis role="bold">MessageServiceInvoker</emphasis>.</para>
            <para>Invoking a topic synchronously, however, requires use of a synchronous service
                call proxy to aggregate all of the topic's services. This functionality is not
                directly available via the <emphasis role="bold"
                    >RemoteResourceServiceLocator</emphasis> API because the <emphasis role="bold"
                    >RemoteResourceServiceLocator</emphasis> acts as a facade for direct service
                invocation.</para>
            <para>To invoke a topic synchronously, you can construct a <emphasis role="bold"
                    >SynchronousServiceCallProxy</emphasis> using <emphasis role="bold"
                    >SynchronousServiceCallProxy.createInstance</emphasis>, passing the list of
                    <emphasis role="bold">RemotedServiceHolder</emphasis> obtained using <emphasis
                    role="bold">RemoteResourceServiceLocator.getAllServices(QName)</emphasis>. This
                is done, for example, by <emphasis role="bold">MessageHelperImpl</emphasis> when the
                bus has been forced into synchronous mode via the <emphasis role="bold"
                    >message.delivery</emphasis> config param. </para>
            <para>The synchronous service call proxy is the same as the asynchronous service call
                proxy, except that it does not queue up the invocation, it will invoke it
                blockingly. The same queue/topic distinctions described above apply when you invoke
                a topic synchronously. Under the normal queue situation, use of the synchronous
                service call proxy is not necessary because, as mentioned above, remote services
                obtained through the <emphasis role="bold">RemoteResourceServiceLocator</emphasis>
                are naturally synchronous. You can see this in the example below:</para>
            <programlisting>List&lt;RemotedServiceHolder> servicesToProxy = KSBResourceLoaderFactory.getRemoteResourceLocator().getAllServices(qname);

SynchronousServiceCallProxy sscp = return SynchronousServiceCallProxy.createInstance(servicesToProxy, callback, context, value1, value2);</programlisting>
        </sect2>
    </sect1>
    <sect1>
        <title>KSB Parameters</title>
        <para>Here is a comprehensive set of configuration parameters used to configure the Kuali
            Service Bus.</para>
        <sect2>
            <title>Core Parameters</title>
            <para>
                <table frame="none">
                    <title>Core Parameters</title>
                    <tgroup cols="3">
                        <colspec colname="c1" colnum="1" colwidth="1.0*"/>
                        <colspec colname="c2" colnum="2" colwidth="1.0*"/>
                        <colspec colname="c3" colnum="3" colwidth="1.0*"/>
                        <thead>
                            <row>
                                <entry>Core </entry>
                                <entry>Description </entry>
                                <entry>Default</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>serviceServletUrl </entry>
                                <entry>URL that maps to the KSB Servlet. It handles incoming
                                    requests from the service bus.</entry>
                                <entry/>
                            </row>
                            <row>
                                <entry>rice.ksb.config.allowSelfSignedSSL</entry>
                                <entry>Indicates if self-signed certificates are permitted for https
                                    communication on the service bus</entry>
                                <entry>false</entry>
                            </row>
                            <row>
                                <entry>service.namespace</entry>
                                <entry>Default namespace for client application services</entry>
                                <entry/>
                            </row>
                            <row>
                                <entry>keystore.file </entry>
                                <entry>Path to the keystore file to use for security </entry>
                                <entry/>
                            </row>
                            <row>
                                <entry>keystore.alias </entry>
                                <entry>Alias of the standalone server's key </entry>
                                <entry/>
                            </row>
                            <row>
                                <entry>keystore.password </entry>
                                <entry>Password to access the keystore and the server's key </entry>
                                <entry/>
                            </row>
                            <row>
                                <entry>ksb.mode</entry>
                                <entry>Mode in which to load the KSB module</entry>
                                <entry>local</entry>
                            </row>
                            <row>
                                <entry>ksb.url</entry>
                                <entry>The URL of the KSB web application</entry>
                                <entry>${application.url}/ksb</entry>
                            </row>
                            <row>
                                <entry>rice.ksb.struts.config.files</entry>
                                <entry>The file that defines the struts context for the KRice KSB
                                    struts module</entry>
                                <entry>/ksb/WEB-INF/struts-config.xml</entry>
                            </row>
                            <row>
                                <entry>dev.mode</entry>
                                <entry>If <emphasis role="italic">true</emphasis>, application will
                                    not publish or consume services from the central service
                                    registry, but will maintain a local copy of the registry. This
                                    is intended only for client application development
                                    purposes.</entry>
                                <entry>false</entry>
                            </row>
                            <row>
                                <entry>bam.enabled</entry>
                                <entry><para>If <emphasis role="italic">true</emphasis>, will monitor and log the service calls made and
                                        general business activity performed to the database. </para><para><emphasis role="italic">Recommendation</emphasis>: Enable this only for testing purposes, as
                                        there is a significant performance impact when
                                        enabled.</para></entry>
                                <entry>false</entry>
                            </row>
                            <row>
                                <entry>message.persistence</entry>
                                <entry>If <emphasis role="italic">true</emphasis>, messages are
                                    stored in the database until sent. If <emphasis role="italic"
                                        >false</emphasis>, they are stored in memory.</entry>
                                <entry>true</entry>
                            </row>
                            <row>
                                <entry>message.delivery</entry>
                                <entry>Specifies whether messages are sent synchronously are
                                    asynchronously. Valid values are <emphasis role="italic"
                                        >synchronous</emphasis> or <emphasis role="italic"
                                        >async</emphasis></entry>
                                <entry>async</entry>
                            </row>
                            <row>
                                <entry>message.off</entry>
                                <entry>If set to <emphasis role="italic">true</emphasis>, then
                                    messages will not be sent but will instead pile up in the
                                    message queue. Intended for development and debugging purposes
                                    only.</entry>
                                <entry>false</entry>
                            </row>
                            <row>
                                <entry>Routing.ImmediateExceptionRouting</entry>
                                <entry>If <emphasis role="italic">true</emphasis>, messages will go
                                    immediately to exception routing if they fail, rather than being
                                    retried</entry>
                                <entry>false</entry>
                            </row>
                            <row>
                                <entry>RouteQueue.maxRetryAttempts</entry>
                                <entry>Default number of times to retry messages that fail to be
                                    delivered successfully.</entry>
                                <entry>5</entry>
                            </row>
                            <row>
                                <entry>RouteQueue.maxRetryAttemptsOverride</entry>
                                <entry>If set, will override the max retry setting for ALL services,
                                    even if they have their own custom retry setting.</entry>
                                <entry/>
                            </row>
                            <row>
                                <entry>ksb.org.quartz.*</entry>
                                <entry>Can define any property beginning with <emphasis
                                        role="italic">ksb.org.quartz</emphasis> and it will be
                                    passed to the internal KSB quartz configuration as a property
                                    beginning with <emphasis role="italic">org.quartz</emphasis>
                                    (more details below)</entry>
                                <entry/>
                            </row>
                            <row>
                                <entry>useQuartzDatabase</entry>
                                <entry>If <emphasis role="italic">true</emphasis>, then Quartz
                                    scheduler in Rice will use a database-backed job store; if
                                        <emphasis role="italic">false</emphasis>, then jobs will be
                                    stored in memory</entry>
                                <entry>true</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>
            <sect3>
                <title>serviceServletUrl</title>
                <para>The URL that resolves to the KSB servlet that handles incoming requests from
                    the service bus. All services exported onto the service bus use this value to
                    construct their endpoint URLs when they are published to the service registry.
                    See section below on configuring the <emphasis role="italic"
                        >KSBDispatcherServlet</emphasis>. This parameter should point to the
                    absolute URL of where that servlet is mapped. It should include a trailing
                    slash.</para>
            </sect3>
            <sect3>
                <title>service.namespace</title>
                <para>An identifier that indicates the name of the <emphasis role="italic"
                        >logical</emphasis> node on the service bus. If the application is running
                    in a cluster, this should be the same for each machine in the cluster. This is
                    used for namespacing of services, among other things. This can alternatively be
                    set using the <emphasis role="italic">serviceNamespace</emphasis> property on
                    RiceConfigurer directly. All services exported from the client application onto
                    the service bus use this value as their default namespace unless otherwise
                    specified.</para>
            </sect3>
            <sect3>
                <title>keystore.file, keystore.alias, keystore.password</title>
                <para>See the documentation below on keystore management.</para>
            </sect3>
            <sect3>
                <title>ksb.mode</title>
                <para>Mode in which to load the KSB module. Valid values are <emphasis role="italic"
                        >local</emphasis> and <emphasis role="italic">embedded</emphasis>. There is
                    currently no difference in how the KSB module loads based on these settings. It
                    will always try to load the KSB struts module if a <emphasis role="italic"
                        >KualiActionServlet</emphasis> is configured.</para>
            </sect3>
            <sect3>
                <title>ksb.url</title>
                <para>The URL of the KSB web application screens</para>
            </sect3>
            <sect3>
                <title>rice.ksb.struts.config.files</title>
                <para>The file that defines the struts context for the KRice KSB struts module. The
                    struts module is loaded automatically if a <emphasis role="italic"
                        >KualiActionServlet</emphasis> is configured in the <emphasis role="italic"
                        >web.xml</emphasis>.</para>
            </sect3>
            <sect3>
                <title>dev.mode</title>
                <para>Indicates whether this node should export and consume services from the entire
                    service bus. If set to <emphasis role="italic">false</emphasis>, then the
                    machine will not register its services in the global service registry. Instead,
                    it can only consume services that it has available locally. In addition to this,
                    other nodes on the service bus will not be able to "see" this node and will
                    therefore not forward any messages to it.</para>
            </sect3>
            <sect3>
                <title>message.persistence</title>
                <para>If <emphasis role="italic">true</emphasis>, then messages will be persisted to
                    the datastore. Otherwise, they will only be stored in memory. If message
                    persistence is not turned on and the server is shutdown while there are still
                    messages that need to be sent, those messages will be lost. For a production
                    environment, it is recommended that message persistence be set to <emphasis
                        role="italic">true</emphasis>.</para>
            </sect3>
            <sect3>
                <title>message.delivery</title>
                <para>Can be set to either <emphasis role="italic">synchronous</emphasis> or
                        <emphasis role="italic">async</emphasis>. If this is set to <emphasis
                        role="italic">synchronous</emphasis>, then messages that are sent in an
                    asynchronous fashion using the KSB API will instead be sent synchronously. This
                    is useful in certain development and unit testing scenarios. For a production
                    environment, it is recommended that message delivery be set to <emphasis
                        role="italic">async</emphasis>.</para>
            </sect3>
            <sect3>
                <title>message.off</title>
                <para>If set to <emphasis role="italic">true</emphasis> then asynchronous messages
                    will not be sent. In the case that message persistence is turned on, they will
                    be persisted in the message store and can even be picked up later using the
                    Message Fetcher. However, if message persistence is turned off, these messages
                    will be lost. This can be useful in certain debugging or testing
                    scenarios.</para>
            </sect3>
            <sect3>
                <title>RouteQueue.maxRetryAttempts</title>
                <para>Sets the default number of retries that will be executed if a message fails to
                    be sent. This retry count can also be customized for a specific service. (See
                    Exposing Services on the Bus)</para>
            </sect3>
            <sect3>
                <title>RouteQueue.timeIncrement</title>
                <para>Sets the default time increment between retry attempts. As with <emphasis
                        role="italic">RouteQueue.maxRetryAttempts</emphasis> this can also be
                    configured at the service level.</para>
            </sect3>
            <sect3>
                <title>RouteQueue.maxRetryAttemptsOverride</title>
                <para>If set with a number, it will temporarily set the retry attempts for ALL
                    services going into exception routing. A good way to prevent all messages in a
                    node that is having trouble from making it to exception routing is by setting
                    the number arbitrarily high. The <emphasis role="italic">message.off</emphasis>
                    param does the same thing.</para>
            </sect3>
            <sect3>
                <title>Routing.ImmediateExceptionRouting</title>
                <para>If set to <emphasis role="italic">true</emphasis>, then messages that fail to
                    be sent will not be re-tried. Instead their <emphasis role="italic"
                        >MessageExceptionHandler</emphasis> will be invoked immediately.</para>
            </sect3>
            <sect3>
                <title>useQuartzDatabase</title>
                <para>When using the embedded Quartz scheduler started by the KSB, indicates whether
                    that Quartz scheduler should store its entries in the database. If this is
                        <emphasis role="italic">true</emphasis>, then the appropriate Quartz
                    properties should be set as well (see ksb.org.quartz.* below).</para>
            </sect3>
            <sect3>
                <title>ksb.org.quartz.*</title>
                <para>Can be used to pass Quartz properties to the embedded Quartz scheduler. See
                    the configuration documentation on the Quartz site. Essentially, any property
                    prefixed with <emphasis role="bold">ksb.org.quartz</emphasis>. will have the
                        "<emphasis role="italic">ksb.</emphasis>" portion stripped and will be sent
                    as configuration parameters to the embedded Quartz scheduler.</para>
            </sect3>
        </sect2>
        <sect2>
            <title>KSB Configurer Properties</title>
            <para>In addition to the configuration parameters available in the KRice configuration
                system, the <emphasis role="italic">KSBConfigurer</emphasis> bean has some
                properties that can be injected to configure it:</para>
            <sect3>
                <title>exceptionMessagingScheduler</title>
                <para>By default, the KSB uses an embedded Quartz scheduler for scheduling the retry
                    of messages that fail to be sent. If desired, a Quartz scheduler can instead be
                    injected into the KSBConfigurer and it will use that scheduler instead. See
                    Quartz Scheduling for more detail.</para>
            </sect3>
            <sect3>
                <title>messageDataSource</title>
                <para>Specifies the <emphasis role="bold">javax.sql.DataSource</emphasis> to use for
                    storing the asynchronous message queue. If not specified, this defaults to the
                    DataSource injected into the RiceConfigurer.</para>
                <para>If this DataSource is injected, then the registryDataSource must also be
                    injected, and vice-versa. </para>
            </sect3>
            <sect3>
                <title>registryDataSource</title>
                <para>Specifies the<emphasis role="bold"> javax.sql.DataSource</emphasis> to use for
                    reading and writing from the Service Registry. If not specified, this defaults
                    to the DataSource injected into the RiceConfigurer.</para>
                <para>If this DataSource is injected, then the <emphasis role="bold"
                        >messageDataSource</emphasis> must also be injected, and vice-versa.</para>
            </sect3>
            <sect3>
                <title>overrideServices</title>
                <para>See Acquiring and invoking services</para>
            </sect3>
            <sect3>
                <title>Services</title>
                <para>See Acquiring and invoking services</para>
            </sect3>
        </sect2>
    </sect1>
    <sect1>
        <title>JAX-RS / RESTful services</title>
        <para>Rice now allows allows RESTful (JAX-RS) services to be exported and consumed on
            the Kuali Service Bus (KSB). For some background on REST, see <link
                xlink:href=" http://en.wikipedia.org/wiki/Representational_State_Transfer"
                >http://en.wikipedia.org/wiki/Representational_State_Transfer</link>.</para>
        <para>For details on JAX-RS, see <link xlink:href="http://jcp.org/en/jsr/detail?id=311"
            >JSR-311</link>.</para>
        <sect2>
            <title>Caveats</title>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>The KSB does <emphasis role="bold">not</emphasis> currently support
                            "busSecure" (digital signing of requests &amp; responses) REST services.
                            Attempting to set a REST service's "busSecure" property to "true" will
                            result in a RiceRuntimeException being thrown. Rice can be customized to
                            expose REST services in a secure way, e.g. using SSL and an
                            authentication mechanism such as client certificates, but that is beyond
                            the scope of this documentation. </para>
                    </listitem>
                    <listitem>
                        <para>If the JAX-RS annotations on your resource class don't cover all of
                            its public methods, then accessing the non-annotated methods over the
                            bus will result in an Exception being thrown. </para>
                    </listitem>
                </itemizedlist>
            </para>
        </sect2>
        <sect2>
            <title>A Simple Example</title>
            <para>To expose a simple JAX-RS annotated service on the bus, you can follow this recipe
                for your spring configuration (which comes from the Rice unit tests):</para>
            <programlisting>&lt;!-- The service implementation you want to expose -->

&lt;bean id="baseballCardCollectionService" class="org.kuali.rice.ksb.testclient1.BaseballCardCollectionServiceImpl"/>


&lt;!-- The service definition which tells the KSB to expose our RESTful service -->
&lt;bean class="org.kuali.rice.ksb.messaging.RESTServiceDefinition">
    &lt;property name="serviceNameSpaceURI" value="test" />


    &lt;!-- as noted earlier, the servicePath property of RESTServiceDefinition can't be set here  -->


    &lt;!-- The service to expose.  Refers to the bean above -->
    &lt;property name="service" ref="baseballCardCollectionService" />


    &lt;!-- The "Resource class", the class with the JAX-RS annotations on it.  Could be the same as the  -->
    &lt;!-- service implementation, or could be different, e.g. an interface or superclass    -->
  
    &lt;property name="resourceClass" 
value="org.kuali.rice.ksb.messaging.remotedservices.BaseballCardCollectionService" />


    &lt;!-- the name of the service, which will be part of the RESTful URLs used to access it -->
    &lt;property name="localServiceName" value="baseballCardCollectionService" />
&lt;/bean>
</programlisting>
            <para>The following java interface uses JAX-RS annotations to specify its RESTful
            interface:</para>
            <programlisting>// … eliding package and imports

@Path("/")
public interface BaseballCardCollectionService {
    @GET
    public List&lt;BaseballCard> getAll();


    /**
      * gets a card by it's (arbitrary) identifier
      */
    @GET
    @Path("/BaseballCard/id/{id}")
    public BaseballCard get(@PathParam("id") Integer id);
    /**
      * gets all the cards in the collection with the given player name
      */
    @GET
    @Path("/BaseballCard/playerName/{playerName}")
    public List&lt;BaseballCard> get(@PathParam("playerName") String playerName);


    /**
      * Add a card to the collection.  This is a non-idempotent method
      * (because you can add more than one of the same card), so we'll use @POST
      * @return the (arbitrary) numerical identifier assigned to this card by the service
      */
    @POST
    @Path("/BaseballCard")
    public Integer add(BaseballCard card);


    /**
      * update the card for the given identifier.  This will replace the card that was previously
      * associated with that identifier.
      */
    @PUT
    @Path("/BaseballCard/id/{id}")
    @Consumes("application/xml")
    public void update(@PathParam("id") Integer id, BaseballCard card);


    /**
      * delete the card with the given identifier.
      */
    @DELETE
    @Path("/BaseballCard/id/{id}")
    public void delete(@PathParam("id") Integer id);

    /**
      * This method lacks JAX-RS annotations
      */
    public void unannotatedMethod();
}</programlisting>
            <para>Acquisition and use of this service over the KSB looks just like that of any other
            KSB service. In the synchronous case:</para>
            <programlisting>BaseballCardCollectionService baseballCardCollection = (BaseballCardCollectionService) GlobalResourceLoader.getService(new QName("test", "baseballCardCollectionService");
);


List&lt;BaseballCard> allMyMickeyMantles = baseballCardCollection.get("Mickey Mantle");
// baseballCardCollection.&lt;other service method>(...)
// etc</programlisting>
        </sect2>
        <sect2>
            <title>Composite Services</title>
            <para>It is also possible to aggregate multiple Rice service implementations into a
                single RESTful service where requests to different sub-paths off of the base service
                URL can be handled by different underlying services. This may be desirable to expose
                a RESTful service that is more complex than could be cleanly factored into a single
                java service interface.</para>
            <para>The configuration for a composite RESTfull service looks a little bit different,
                and as might be expected given the one-to-many mapping from RESTful service to java
                services, there are some caveats to using that service over the KSB. Here is a
                simple example of a composite service definition (which also comes from the Rice
                unit tests):</para>
            <programlisting>&lt;bean class="org.kuali.rice.ksb.messaging.RESTServiceDefinition">
    &lt;property name="serviceNameSpaceURI" value="test" />
    &lt;property name="localServiceName" value="kms" />
    &lt;property name="resources">
        &lt;list>
            &lt;ref bean="inboxResource"/>
            &lt;ref bean="messageResource"/>
        &lt;/list>
    &lt;/property>
    &lt;property name="servicePath" value="/" />
&lt;/bean>


&lt;!-- the beans referenced above are just JAX-RS annotated Java services -->
&lt;bean id="inboxResource" class="org.kuali.rice.ksb.testclient1.InboxResourceImpl">
    &lt;!-- ... eliding bean properties ... -->
&lt;/bean>
&lt;bean id="messageResource" class="org.kuali.rice.ksb.testclient1.MessageResourceImpl">
    &lt;!-- ... eliding bean properties ... -->

&lt;/bean></programlisting>
            <para>As you can see in the bean definition above, the service name is kms, so the base
                service url would by default (in a dev environment) be <emphasis role="bold"
                    >http://localhost:8080/kr-dev/remoting/kms/</emphasis>. Acquiring a composite
                service such as this one on the KSB will actually return you a <emphasis role="bold"
                    >org.kuali.rice.ksb.messaging.serviceconnectors.ResourceFacade</emphasis>, which
                allows you to get the individual java services in a couple of ways, as shown in the
                following simple example:</para>
            <programlisting>ResourceFacade kmsService =
 (ResourceFacade) GlobalResourceLoader.getService(
new QName(NAMESPACE, KMS_SERVICE));


// Get service by resource name (url path)
InboxResource inboxResource = kmsService.getResource("inbox");
// Get service by resource class
MessageResource messageResource = kmsService.getResource(MessageResource.class);</programlisting>
        </sect2>
        <sect2>
            <title>Additional Service Definition Properties</title>
            <para>There are some properties on the RESTServiceDefinition object that let you do more
                advanced configuration:</para>
            <sect3>
                <title>Providers</title>
                <para>JAX-RS Providers allow you to define:<itemizedlist>
                        <listitem>
                            <para>ExceptionMappers which will handle specific Exception types with
                                specific Responses. </para>
                        </listitem>
                        <listitem>
                            <para>MessageBodyReaders and MessageBodyWriters that will convert custom
                                Java types to and from streams. </para>
                        </listitem>
                        <listitem>
                            <para>ContextResolver providers allow you to create special JAXBContexts
                                for specific types, which will gives you fine control over
                                marshalling, unmarshalling, and validation. </para>
                        </listitem>
                    </itemizedlist></para>
                <para>The JAX-RS specification calls for classes annotated with @Provider to be
                    automatically used in the underlying implementation, but the CXF project which
                    Rice uses under the hood does not (at the time of this writing) support this
                    configuration mechanism, so this configuration property is currently
                    necessary.</para>
            </sect3>
            <sect3>
                <title>Extension Mappings</title>
                <para>Ordinarily you need to set your ACCEPT header to ask for a specific
                    representation of a resource. ExtensionMappings let you map certain file
                    extensions to specific media types for your RESTful service, so your URLs can
                    then optionally specify a media type directly. For example you could map the
                        <emphasis role="bold">.xml</emphasis> extension to the media type <emphasis
                        role="bold">text/xml</emphasis>, and then tag .xml on to the end of your
                    resource URL to specify that representation.</para>
            </sect3>
            <sect3>
                <title>Language Mappings</title>
                <para>language mappings allow you a way to control the the Content-Language header,
                    which lets you specify which languages your service can accept and
                    provide.</para>
            </sect3>
            <sect3>
                <title>Additional Information</title>
                <para>For more information on what these properties provide, it may be helpful to
                    consult the JAX-RS specification, or the CXF documentation.</para>
            </sect3>
        </sect2>
    </sect1>
</chapter>
